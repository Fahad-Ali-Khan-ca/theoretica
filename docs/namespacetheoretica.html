<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Theoretica: theoretica Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Theoretica
   </div>
   <div id="projectbrief">A C++ numerical and automatic mathematical library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacetheoretica.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">theoretica Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Main namespace of the library which contains all functions and objects.  
<a href="namespacetheoretica.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetheoretica_1_1algebra"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1algebra.html">algebra</a></td></tr>
<tr class="memdesc:namespacetheoretica_1_1algebra"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear algebra routines. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetheoretica_1_1distribution"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1distribution.html">distribution</a></td></tr>
<tr class="memdesc:namespacetheoretica_1_1distribution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Probability distribution functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetheoretica_1_1regression"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1regression.html">regression</a></td></tr>
<tr class="memdesc:namespacetheoretica_1_1regression"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regression to a model. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetheoretica_1_1special"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1special.html">special</a></td></tr>
<tr class="memdesc:namespacetheoretica_1_1special"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetheoretica_1_1tables"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1tables.html">tables</a></td></tr>
<tr class="memdesc:namespacetheoretica_1_1tables"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tabulated values. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetheoretica_1_1taylor"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1taylor.html">taylor</a></td></tr>
<tr class="memdesc:namespacetheoretica_1_1taylor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Taylor series expansions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1complex.html">complex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex number in algebraic form \(a + ib\).  <a href="classtheoretica_1_1complex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1dual.html">dual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dual number class.  <a href="classtheoretica_1_1dual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1dual2.html">dual2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Second order dual number class.  <a href="classtheoretica_1_1dual2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1histogram.html">histogram</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Histogram class with running statistics.  <a href="classtheoretica_1_1histogram.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtheoretica_1_1is__complex__type.html">is_complex_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the given type is a specialization of the complex number class or not, using the static boolean element is_complex_type&lt;T&gt;::value.  <a href="structtheoretica_1_1is__complex__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtheoretica_1_1is__complex__type_3_01complex_3_01_t_01_4_01_4.html">is_complex_type&lt; complex&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the given type is a specialization of the complex number class or not, using the static boolean element is_complex_type&lt;T&gt;::value.  <a href="structtheoretica_1_1is__complex__type_3_01complex_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1mat.html">mat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic matrix with a fixed number of rows and columns.  <a href="classtheoretica_1_1mat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1mat_3_01_type_00_010_00_010_01_4.html">mat&lt; Type, 0, 0 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic matrix with a variable number of rows and columns.  <a href="classtheoretica_1_1mat_3_01_type_00_010_00_010_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multidual number algebra for functions of the form \(f: \mathbb{R}^n \rightarrow \mathbb{R}\).  <a href="classtheoretica_1_1multidual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current state of an ODE integration for an N dimensional differential equation.  <a href="structtheoretica_1_1ode__state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtheoretica_1_1ode__state_3_011_01_4.html">ode_state&lt; 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtheoretica_1_1pdf__sampler.html">pdf_sampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A probability density function sampler which generates pseudorandom numbers following asymptotically a given distribution \(f(x; \vec \theta)\).  <a href="structtheoretica_1_1pdf__sampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1phasor.html">phasor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex number in exponential form \(\rho e^{i \theta}\).  <a href="classtheoretica_1_1phasor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A polynomial of arbitrary order.  <a href="classtheoretica_1_1polynomial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pseudorandom number generator.  <a href="classtheoretica_1_1_p_r_n_g.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1quat.html">quat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quaternion class in the form \(a + bi + cj + dk\).  <a href="classtheoretica_1_1quat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1ratio.html">ratio</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">representing a ratio between two objects, like a fraction or a rational polynomial.  <a href="classtheoretica_1_1ratio.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1spline.html">spline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A natural cubic spline interpolation class.  <a href="classtheoretica_1_1spline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtheoretica_1_1spline__node.html">spline_node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cubic splines node for a given x interval.  <a href="structtheoretica_1_1spline__node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1vec.html">vec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An N-dimensional vector of Type elements.  <a href="classtheoretica_1_1vec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1vec_3_01_type_00_010_01_4.html">vec&lt; Type, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a721dc79a0eca4b349c67a746c26b26a4"><td class="memItemLeft" align="right" valign="top"><a id="a721dc79a0eca4b349c67a746c26b26a4" name="a721dc79a0eca4b349c67a746c26b26a4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>mat2</b> = <a class="el" href="classtheoretica_1_1mat.html">mat</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, 2, 2 &gt;</td></tr>
<tr class="memdesc:a721dc79a0eca4b349c67a746c26b26a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2x2 matrix with real entries. <br /></td></tr>
<tr class="separator:a721dc79a0eca4b349c67a746c26b26a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7eff567887e9025d2edd9870a31311"><td class="memItemLeft" align="right" valign="top"><a id="afb7eff567887e9025d2edd9870a31311" name="afb7eff567887e9025d2edd9870a31311"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>mat3</b> = <a class="el" href="classtheoretica_1_1mat.html">mat</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, 3, 3 &gt;</td></tr>
<tr class="memdesc:afb7eff567887e9025d2edd9870a31311"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3x3 matrix with real entries. <br /></td></tr>
<tr class="separator:afb7eff567887e9025d2edd9870a31311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac380be159592259cb223e6190e504197"><td class="memItemLeft" align="right" valign="top"><a id="ac380be159592259cb223e6190e504197" name="ac380be159592259cb223e6190e504197"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>mat4</b> = <a class="el" href="classtheoretica_1_1mat.html">mat</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, 4, 4 &gt;</td></tr>
<tr class="memdesc:ac380be159592259cb223e6190e504197"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 4x4 matrix with real entries. <br /></td></tr>
<tr class="separator:ac380be159592259cb223e6190e504197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6802641e18b86a3022282d01b1ce25de"><td class="memItemLeft" align="right" valign="top"><a id="a6802641e18b86a3022282d01b1ce25de" name="a6802641e18b86a3022282d01b1ce25de"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>cmat</b> = <a class="el" href="classtheoretica_1_1mat.html">mat</a>&lt; <a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt;&gt; &gt;</td></tr>
<tr class="memdesc:a6802641e18b86a3022282d01b1ce25de"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variable size matrix with complex entries. <br /></td></tr>
<tr class="separator:a6802641e18b86a3022282d01b1ce25de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c414bd3969089ec91fa95cfc94390cf"><td class="memItemLeft" align="right" valign="top"><a id="a9c414bd3969089ec91fa95cfc94390cf" name="a9c414bd3969089ec91fa95cfc94390cf"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>cmat2</b> = <a class="el" href="classtheoretica_1_1mat.html">mat</a>&lt; <a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;, 2, 2 &gt;</td></tr>
<tr class="memdesc:a9c414bd3969089ec91fa95cfc94390cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2x2 matrix with real entries. <br /></td></tr>
<tr class="separator:a9c414bd3969089ec91fa95cfc94390cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec5ec1cfb9d9d79780881e02e5d11b0"><td class="memItemLeft" align="right" valign="top"><a id="a2ec5ec1cfb9d9d79780881e02e5d11b0" name="a2ec5ec1cfb9d9d79780881e02e5d11b0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>cmat3</b> = <a class="el" href="classtheoretica_1_1mat.html">mat</a>&lt; <a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;, 3, 3 &gt;</td></tr>
<tr class="memdesc:a2ec5ec1cfb9d9d79780881e02e5d11b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3x3 matrix with real entries. <br /></td></tr>
<tr class="separator:a2ec5ec1cfb9d9d79780881e02e5d11b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ec29d91ae6c6a21a09cdaf95a85045"><td class="memItemLeft" align="right" valign="top"><a id="ae1ec29d91ae6c6a21a09cdaf95a85045" name="ae1ec29d91ae6c6a21a09cdaf95a85045"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>cmat4</b> = <a class="el" href="classtheoretica_1_1mat.html">mat</a>&lt; <a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;, 4, 4 &gt;</td></tr>
<tr class="memdesc:ae1ec29d91ae6c6a21a09cdaf95a85045"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 4x4 matrix with real entries. <br /></td></tr>
<tr class="separator:ae1ec29d91ae6c6a21a09cdaf95a85045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f21bd68ba64b172c29d9fce15c8712d"><td class="memItemLeft" align="right" valign="top"><a id="a1f21bd68ba64b172c29d9fce15c8712d" name="a1f21bd68ba64b172c29d9fce15c8712d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>vec2</b> = <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, 2 &gt;</td></tr>
<tr class="memdesc:a1f21bd68ba64b172c29d9fce15c8712d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2-dimensional vector with real elements. <br /></td></tr>
<tr class="separator:a1f21bd68ba64b172c29d9fce15c8712d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac512b7e62a96d6b2a94a64e642a34910"><td class="memItemLeft" align="right" valign="top"><a id="ac512b7e62a96d6b2a94a64e642a34910" name="ac512b7e62a96d6b2a94a64e642a34910"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>vec3</b> = <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, 3 &gt;</td></tr>
<tr class="memdesc:ac512b7e62a96d6b2a94a64e642a34910"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3-dimensional vector with real elements. <br /></td></tr>
<tr class="separator:ac512b7e62a96d6b2a94a64e642a34910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c9f34d374aba86cc459926c45825030"><td class="memItemLeft" align="right" valign="top"><a id="a4c9f34d374aba86cc459926c45825030" name="a4c9f34d374aba86cc459926c45825030"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>vec4</b> = <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, 4 &gt;</td></tr>
<tr class="memdesc:a4c9f34d374aba86cc459926c45825030"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 4-dimensional vector with real elements. <br /></td></tr>
<tr class="separator:a4c9f34d374aba86cc459926c45825030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83cf1314a448f23b10e74302550ed77f"><td class="memItemLeft" align="right" valign="top"><a id="a83cf1314a448f23b10e74302550ed77f" name="a83cf1314a448f23b10e74302550ed77f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>cvec</b> = <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt;&gt; &gt;</td></tr>
<tr class="memdesc:a83cf1314a448f23b10e74302550ed77f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variable size vector with complex elements. <br /></td></tr>
<tr class="separator:a83cf1314a448f23b10e74302550ed77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429fe8925be98f943d69ad693e24c1bb"><td class="memItemLeft" align="right" valign="top"><a id="a429fe8925be98f943d69ad693e24c1bb" name="a429fe8925be98f943d69ad693e24c1bb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>cvec2</b> = <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt;&gt;, 2 &gt;</td></tr>
<tr class="memdesc:a429fe8925be98f943d69ad693e24c1bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2-dimensional vector with complex elements. <br /></td></tr>
<tr class="separator:a429fe8925be98f943d69ad693e24c1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfc48b27b17470d8ac001a9f2008c4a"><td class="memItemLeft" align="right" valign="top"><a id="a9bfc48b27b17470d8ac001a9f2008c4a" name="a9bfc48b27b17470d8ac001a9f2008c4a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>cvec3</b> = <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt;&gt;, 3 &gt;</td></tr>
<tr class="memdesc:a9bfc48b27b17470d8ac001a9f2008c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3-dimensional vector with complex elements. <br /></td></tr>
<tr class="separator:a9bfc48b27b17470d8ac001a9f2008c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a30c2b68e61ebe0ede42b20f3354145"><td class="memItemLeft" align="right" valign="top"><a id="a0a30c2b68e61ebe0ede42b20f3354145" name="a0a30c2b68e61ebe0ede42b20f3354145"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>cvec4</b> = <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt;&gt;, 4 &gt;</td></tr>
<tr class="memdesc:a0a30c2b68e61ebe0ede42b20f3354145"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 4-dimensional vector with complex elements. <br /></td></tr>
<tr class="separator:a0a30c2b68e61ebe0ede42b20f3354145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac9a6f3d85bd0f6ae607178431e51a6"><td class="memTemplParams" colspan="2"><a id="a9ac9a6f3d85bd0f6ae607178431e51a6" name="a9ac9a6f3d85bd0f6ae607178431e51a6"></a>
template&lt;unsigned int N = 0&gt; </td></tr>
<tr class="memitem:a9ac9a6f3d85bd0f6ae607178431e51a6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>d_real</b> = <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;</td></tr>
<tr class="memdesc:a9ac9a6f3d85bd0f6ae607178431e51a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types for multivariate automatic differentiation. <br /></td></tr>
<tr class="separator:a9ac9a6f3d85bd0f6ae607178431e51a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957eb38760002872205fe2b5c1a25f10"><td class="memTemplParams" colspan="2"><a id="a957eb38760002872205fe2b5c1a25f10" name="a957eb38760002872205fe2b5c1a25f10"></a>
template&lt;unsigned int N = 0&gt; </td></tr>
<tr class="memitem:a957eb38760002872205fe2b5c1a25f10"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>d_vec</b> = <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a9ac9a6f3d85bd0f6ae607178431e51a6">d_real</a>&lt; N &gt;, N &gt;</td></tr>
<tr class="separator:a957eb38760002872205fe2b5c1a25f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f1da297b159938c8b3fb2dc9121e0d"><td class="memTemplParams" colspan="2"><a id="a23f1da297b159938c8b3fb2dc9121e0d" name="a23f1da297b159938c8b3fb2dc9121e0d"></a>
template&lt;typename Type  = real&gt; </td></tr>
<tr class="memitem:a23f1da297b159938c8b3fb2dc9121e0d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bicomplex</b> = <a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; <a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; Type &gt; &gt;</td></tr>
<tr class="memdesc:a23f1da297b159938c8b3fb2dc9121e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bi-complex number. <br /></td></tr>
<tr class="separator:a23f1da297b159938c8b3fb2dc9121e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049966946220f1f7e5eae57293703066"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> = double</td></tr>
<tr class="memdesc:a049966946220f1f7e5eae57293703066"><td class="mdescLeft">&#160;</td><td class="mdescRight">A real number, defined as a floating point type.  <a href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">More...</a><br /></td></tr>
<tr class="separator:a049966946220f1f7e5eae57293703066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60d62492ac4137c837c50b1fdc8a904"><td class="memItemLeft" align="right" valign="top"><a id="ad60d62492ac4137c837c50b1fdc8a904" name="ad60d62492ac4137c837c50b1fdc8a904"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>real_function</b> = std::function&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>)&gt;</td></tr>
<tr class="memdesc:ad60d62492ac4137c837c50b1fdc8a904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointer to a real function of real variable. <br /></td></tr>
<tr class="separator:ad60d62492ac4137c837c50b1fdc8a904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7620593d89c6c46fc98e488683382d1"><td class="memItemLeft" align="right" valign="top"><a id="ae7620593d89c6c46fc98e488683382d1" name="ae7620593d89c6c46fc98e488683382d1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>complex_function</b> = std::function&lt; <a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt;&gt;(<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt;&gt;)&gt;</td></tr>
<tr class="memdesc:ae7620593d89c6c46fc98e488683382d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointer to a complex function of complex variable. <br /></td></tr>
<tr class="separator:ae7620593d89c6c46fc98e488683382d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a0bafb035970e4921b84f75661e2b1"><td class="memItemLeft" align="right" valign="top"><a id="ac7a0bafb035970e4921b84f75661e2b1" name="ac7a0bafb035970e4921b84f75661e2b1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>stat_function</b> = std::function&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;)&gt;</td></tr>
<tr class="memdesc:ac7a0bafb035970e4921b84f75661e2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointer to a probability distribution function where the first argument is the variable and the second argument is a vector of the parameters of the distribution. <br /></td></tr>
<tr class="separator:ac7a0bafb035970e4921b84f75661e2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb53498374f76292a3da8bb8c785341"><td class="memItemLeft" align="right" valign="top"><a id="adcb53498374f76292a3da8bb8c785341" name="adcb53498374f76292a3da8bb8c785341"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>polyn_recurr_formula</b> = std::function&lt; <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;(<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;, <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;, unsigned int)&gt;</td></tr>
<tr class="memdesc:adcb53498374f76292a3da8bb8c785341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polynomial sequence recurrence formula type Used for computing orthogonal polynomial basis elements. <br /></td></tr>
<tr class="separator:adcb53498374f76292a3da8bb8c785341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f8bd44356f8184466e4cc0d6986fe5"><td class="memItemLeft" align="right" valign="top"><a id="a99f8bd44356f8184466e4cc0d6986fe5" name="a99f8bd44356f8184466e4cc0d6986fe5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pseudorandom_function</b> = uint64_t(*)(uint64_t, std::vector&lt; uint64_t &gt; &amp;)</td></tr>
<tr class="memdesc:a99f8bd44356f8184466e4cc0d6986fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pseudorandom function pointer. <br /></td></tr>
<tr class="separator:a99f8bd44356f8184466e4cc0d6986fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17352cbe273b80ae0f08eac818eba84e"><td class="memItemLeft" align="right" valign="top"><a id="a17352cbe273b80ae0f08eac818eba84e" name="a17352cbe273b80ae0f08eac818eba84e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pdf_sampling_function</b> = <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*)(const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;)</td></tr>
<tr class="memdesc:a17352cbe273b80ae0f08eac818eba84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A p.d.f sampling function taking as input the parameters of the distribution and a pseudorandom number generator. <br /></td></tr>
<tr class="separator:a17352cbe273b80ae0f08eac818eba84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a47d8f770edb576685f4b8752f2eb9760"><td class="memItemLeft" align="right" valign="top"><a id="a47d8f770edb576685f4b8752f2eb9760" name="a47d8f770edb576685f4b8752f2eb9760"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a47d8f770edb576685f4b8752f2eb9760">MATH_ERRCODE</a> { <br />
&#160;&#160;<b>NO_ERROR</b> = 0x00
, <b>DIV_BY_ZERO</b> = 0x01
, <b>OUT_OF_DOMAIN</b> = 0x02
, <b>OUT_OF_RANGE</b> = 0x04
, <br />
&#160;&#160;<b>IMPOSSIBLE_OPERATION</b> = 0x08
, <b>NO_ALGO_CONVERGENCE</b> = 0x10
, <b>INVALID_ARGUMENT</b> = 0x20
<br />
 }</td></tr>
<tr class="memdesc:a47d8f770edb576685f4b8752f2eb9760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Math error enumeration. <br /></td></tr>
<tr class="separator:a47d8f770edb576685f4b8752f2eb9760"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af8286ffe7f1090f451c53c06dd8849b7"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:af8286ffe7f1090f451c53c06dd8849b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#af8286ffe7f1090f451c53c06dd8849b7">lp_norm</a> (const Vector &amp;v, unsigned int p)</td></tr>
<tr class="memdesc:af8286ffe7f1090f451c53c06dd8849b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Norms.  <a href="namespacetheoretica.html#af8286ffe7f1090f451c53c06dd8849b7">More...</a><br /></td></tr>
<tr class="separator:af8286ffe7f1090f451c53c06dd8849b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d0f113bf884c2e04dbc257b9aaed2f"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a72d0f113bf884c2e04dbc257b9aaed2f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a72d0f113bf884c2e04dbc257b9aaed2f">l1_norm</a> (const Vector &amp;v)</td></tr>
<tr class="memdesc:a72d0f113bf884c2e04dbc257b9aaed2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the L1 norm of a vector.  <a href="namespacetheoretica.html#a72d0f113bf884c2e04dbc257b9aaed2f">More...</a><br /></td></tr>
<tr class="separator:a72d0f113bf884c2e04dbc257b9aaed2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f58265a7030cb73e6aadc39b6f0599"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:ae3f58265a7030cb73e6aadc39b6f0599"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ae3f58265a7030cb73e6aadc39b6f0599">l2_norm</a> (const Vector &amp;v)</td></tr>
<tr class="memdesc:ae3f58265a7030cb73e6aadc39b6f0599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the L2 norm of a vector.  <a href="namespacetheoretica.html#ae3f58265a7030cb73e6aadc39b6f0599">More...</a><br /></td></tr>
<tr class="separator:ae3f58265a7030cb73e6aadc39b6f0599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b1bad8257e5090708d2fba48d2d2a0"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:ab5b1bad8257e5090708d2fba48d2d2a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ab5b1bad8257e5090708d2fba48d2d2a0">linf_norm</a> (const Vector &amp;v)</td></tr>
<tr class="memdesc:ab5b1bad8257e5090708d2fba48d2d2a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Linf norm of a vector.  <a href="namespacetheoretica.html#ab5b1bad8257e5090708d2fba48d2d2a0">More...</a><br /></td></tr>
<tr class="separator:ab5b1bad8257e5090708d2fba48d2d2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd69de2551fd07855f64a36e1b3132fe"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:acd69de2551fd07855f64a36e1b3132fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#acd69de2551fd07855f64a36e1b3132fe">euclidean_distance</a> (const Vector &amp;v1, const Vector &amp;v2)</td></tr>
<tr class="memdesc:acd69de2551fd07855f64a36e1b3132fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distances.  <a href="namespacetheoretica.html#acd69de2551fd07855f64a36e1b3132fe">More...</a><br /></td></tr>
<tr class="separator:acd69de2551fd07855f64a36e1b3132fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241982835f6919ce0689b3afee77f150"><td class="memTemplParams" colspan="2"><a id="a241982835f6919ce0689b3afee77f150" name="a241982835f6919ce0689b3afee77f150"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a241982835f6919ce0689b3afee77f150"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>distance</b> (const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;v1, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;v2)</td></tr>
<tr class="memdesc:a241982835f6919ce0689b3afee77f150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Euclidean distance between two vectors. <br /></td></tr>
<tr class="separator:a241982835f6919ce0689b3afee77f150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4072e50f928983654dd1b9054218d4b6"><td class="memItemLeft" align="right" valign="top"><a id="a4072e50f928983654dd1b9054218d4b6" name="a4072e50f928983654dd1b9054218d4b6"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>euclidean_distance</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b)</td></tr>
<tr class="memdesc:a4072e50f928983654dd1b9054218d4b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Euclidian distance between two values. <br /></td></tr>
<tr class="separator:a4072e50f928983654dd1b9054218d4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd7ad59889c6379feb35b7bbbb88120"><td class="memItemLeft" align="right" valign="top"><a id="aebd7ad59889c6379feb35b7bbbb88120" name="aebd7ad59889c6379feb35b7bbbb88120"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>distance</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b)</td></tr>
<tr class="memdesc:aebd7ad59889c6379feb35b7bbbb88120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Euclidian distance between two values. <br /></td></tr>
<tr class="separator:aebd7ad59889c6379feb35b7bbbb88120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeedcee97d02f52f7b936f49f85697201"><td class="memTemplParams" colspan="2"><a id="aeedcee97d02f52f7b936f49f85697201" name="aeedcee97d02f52f7b936f49f85697201"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeedcee97d02f52f7b936f49f85697201"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>distance</b> (<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z1, <a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z2)</td></tr>
<tr class="memdesc:aeedcee97d02f52f7b936f49f85697201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the distance between two complex numbers. <br /></td></tr>
<tr class="separator:aeedcee97d02f52f7b936f49f85697201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c3cde28b4a99620565dc3f5975853e"><td class="memTemplParams" colspan="2"><a id="a00c3cde28b4a99620565dc3f5975853e" name="a00c3cde28b4a99620565dc3f5975853e"></a>
template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a00c3cde28b4a99620565dc3f5975853e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>minkowski_distance</b> (const Vector &amp;v1, const Vector &amp;v2, unsigned int p)</td></tr>
<tr class="memdesc:a00c3cde28b4a99620565dc3f5975853e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Minkowski distance between two vectors. <br /></td></tr>
<tr class="separator:a00c3cde28b4a99620565dc3f5975853e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09993b93cbd658a8a17acc0b118023a"><td class="memItemLeft" align="right" valign="top"><a id="af09993b93cbd658a8a17acc0b118023a" name="af09993b93cbd658a8a17acc0b118023a"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>minkowski_distance</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int p)</td></tr>
<tr class="memdesc:af09993b93cbd658a8a17acc0b118023a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Minkowski distance between two values. <br /></td></tr>
<tr class="separator:af09993b93cbd658a8a17acc0b118023a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484f074222ea75d0d9b5693738f269f4"><td class="memTemplParams" colspan="2"><a id="a484f074222ea75d0d9b5693738f269f4" name="a484f074222ea75d0d9b5693738f269f4"></a>
template&lt;typename Vector , typename T  = real&gt; </td></tr>
<tr class="memitem:a484f074222ea75d0d9b5693738f269f4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>hermitian_distance</b> (const Vector &amp;v1, const Vector &amp;v2)</td></tr>
<tr class="memdesc:a484f074222ea75d0d9b5693738f269f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Hermitian distance between two vectors. <br /></td></tr>
<tr class="separator:a484f074222ea75d0d9b5693738f269f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f72a092a0ad88a1cb897fd14d56bb9"><td class="memTemplParams" colspan="2"><a id="a10f72a092a0ad88a1cb897fd14d56bb9" name="a10f72a092a0ad88a1cb897fd14d56bb9"></a>
template&lt;unsigned int N, typename T &gt; </td></tr>
<tr class="memitem:a10f72a092a0ad88a1cb897fd14d56bb9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>distance</b> (const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;, N &gt; &amp;v1, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;, N &gt; &amp;v2)</td></tr>
<tr class="memdesc:a10f72a092a0ad88a1cb897fd14d56bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Hermitian distance between two vectors. <br /></td></tr>
<tr class="separator:a10f72a092a0ad88a1cb897fd14d56bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5578d39435d846459810be6ae368c049"><td class="memTemplParams" colspan="2"><a id="a5578d39435d846459810be6ae368c049" name="a5578d39435d846459810be6ae368c049"></a>
template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a5578d39435d846459810be6ae368c049"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>manhattan_distance</b> (const Vector &amp;v1, const Vector &amp;v2)</td></tr>
<tr class="memdesc:a5578d39435d846459810be6ae368c049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Manhattan distance between two vectors. <br /></td></tr>
<tr class="separator:a5578d39435d846459810be6ae368c049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71ea5ee4186d1a50e136d66da390275"><td class="memTemplParams" colspan="2"><a id="ab71ea5ee4186d1a50e136d66da390275" name="ab71ea5ee4186d1a50e136d66da390275"></a>
template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:ab71ea5ee4186d1a50e136d66da390275"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chebyshev_distance</b> (const Vector &amp;v1, const Vector &amp;v2)</td></tr>
<tr class="memdesc:ab71ea5ee4186d1a50e136d66da390275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Chebyshev distance between two vectors. <br /></td></tr>
<tr class="separator:ab71ea5ee4186d1a50e136d66da390275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8a25b9768786c8dfbc7eb28a4c6bbc"><td class="memTemplParams" colspan="2"><a id="aaf8a25b9768786c8dfbc7eb28a4c6bbc" name="aaf8a25b9768786c8dfbc7eb28a4c6bbc"></a>
template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:aaf8a25b9768786c8dfbc7eb28a4c6bbc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>discrete_distance</b> (const Vector &amp;v1, const Vector &amp;v2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#aa34d8798921a9b3b78e885a455ff4211">MACH_EPSILON</a>)</td></tr>
<tr class="memdesc:aaf8a25b9768786c8dfbc7eb28a4c6bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the discrete distance between two vectors. <br /></td></tr>
<tr class="separator:aaf8a25b9768786c8dfbc7eb28a4c6bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0310752e7dbeba27557dd109d9739621"><td class="memTemplParams" colspan="2"><a id="a0310752e7dbeba27557dd109d9739621" name="a0310752e7dbeba27557dd109d9739621"></a>
template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a0310752e7dbeba27557dd109d9739621"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>canberra_distance</b> (const Vector &amp;v1, const Vector &amp;v2)</td></tr>
<tr class="memdesc:a0310752e7dbeba27557dd109d9739621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Canberra distance between two vectors. <br /></td></tr>
<tr class="separator:a0310752e7dbeba27557dd109d9739621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305fe36db0e361b1d819bc19aa14aa68"><td class="memTemplParams" colspan="2"><a id="a305fe36db0e361b1d819bc19aa14aa68" name="a305fe36db0e361b1d819bc19aa14aa68"></a>
template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a305fe36db0e361b1d819bc19aa14aa68"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cosine_distance</b> (const Vector &amp;v1, const Vector &amp;v2)</td></tr>
<tr class="memdesc:a305fe36db0e361b1d819bc19aa14aa68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cosine distance between two vectors. <br /></td></tr>
<tr class="separator:a305fe36db0e361b1d819bc19aa14aa68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3b63bafe8f2b4719fed0ac2902eacf"><td class="memTemplParams" colspan="2"><a id="ada3b63bafe8f2b4719fed0ac2902eacf" name="ada3b63bafe8f2b4719fed0ac2902eacf"></a>
template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:ada3b63bafe8f2b4719fed0ac2902eacf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>hamming_distance</b> (const Vector &amp;v1, const Vector &amp;v2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#aa34d8798921a9b3b78e885a455ff4211">MACH_EPSILON</a>)</td></tr>
<tr class="memdesc:ada3b63bafe8f2b4719fed0ac2902eacf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Hamming distance between two vectors. <br /></td></tr>
<tr class="separator:ada3b63bafe8f2b4719fed0ac2902eacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5531bef2c741e136c07dd1ddc3660306"><td class="memTemplParams" colspan="2"><a id="a5531bef2c741e136c07dd1ddc3660306" name="a5531bef2c741e136c07dd1ddc3660306"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a5531bef2c741e136c07dd1ddc3660306"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gradient</b> (<a class="el" href="namespacetheoretica.html#a9ac9a6f3d85bd0f6ae607178431e51a6">d_real</a>&lt; N &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">d_vec</a>&lt; N &gt;), const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;x)</td></tr>
<tr class="memdesc:a5531bef2c741e136c07dd1ddc3660306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient for a given \(\vec x\) of a function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\) using automatic differentiation. <br /></td></tr>
<tr class="separator:a5531bef2c741e136c07dd1ddc3660306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4cfba6b9e175dc58f81f902d5cf62d"><td class="memTemplParams" colspan="2"><a id="afb4cfba6b9e175dc58f81f902d5cf62d" name="afb4cfba6b9e175dc58f81f902d5cf62d"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:afb4cfba6b9e175dc58f81f902d5cf62d"><td class="memTemplItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gradient</b> (<a class="el" href="namespacetheoretica.html#a9ac9a6f3d85bd0f6ae607178431e51a6">d_real</a>&lt; N &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">d_vec</a>&lt; N &gt;))</td></tr>
<tr class="memdesc:afb4cfba6b9e175dc58f81f902d5cf62d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a function which computes the gradient of a given function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\) at a given \(\vec x\) using automatic differentiation. <br /></td></tr>
<tr class="separator:afb4cfba6b9e175dc58f81f902d5cf62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d99fa1f99736540520c2b251574362"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ab1d99fa1f99736540520c2b251574362"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ab1d99fa1f99736540520c2b251574362">gradient_mono</a> (<a class="el" href="classtheoretica_1_1dual.html">dual</a>(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1dual.html">dual</a>, N &gt;), const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;x)</td></tr>
<tr class="memdesc:ab1d99fa1f99736540520c2b251574362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient for a given \(\vec x\) of a function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\) using automatic differentiation.  <a href="namespacetheoretica.html#ab1d99fa1f99736540520c2b251574362">More...</a><br /></td></tr>
<tr class="separator:ab1d99fa1f99736540520c2b251574362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bbf7fafe033b9a96760d53fdad15ec0"><td class="memTemplParams" colspan="2"><a id="a0bbf7fafe033b9a96760d53fdad15ec0" name="a0bbf7fafe033b9a96760d53fdad15ec0"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a0bbf7fafe033b9a96760d53fdad15ec0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>divergence</b> (<a class="el" href="namespacetheoretica.html#a9ac9a6f3d85bd0f6ae607178431e51a6">d_real</a>&lt; N &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">d_vec</a>&lt; N &gt;), const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;x)</td></tr>
<tr class="memdesc:a0bbf7fafe033b9a96760d53fdad15ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the divergence for a given \(\vec x\) of a function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\) using automatic differentiation. <br /></td></tr>
<tr class="separator:a0bbf7fafe033b9a96760d53fdad15ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9aa5a3498e10f76c65636bf6782bb6f"><td class="memTemplParams" colspan="2"><a id="ad9aa5a3498e10f76c65636bf6782bb6f" name="ad9aa5a3498e10f76c65636bf6782bb6f"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ad9aa5a3498e10f76c65636bf6782bb6f"><td class="memTemplItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>divergence</b> (<a class="el" href="namespacetheoretica.html#a9ac9a6f3d85bd0f6ae607178431e51a6">d_real</a>&lt; N &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">d_vec</a>&lt; N &gt;))</td></tr>
<tr class="memdesc:ad9aa5a3498e10f76c65636bf6782bb6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a function which computes the divergence of a given function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\) at a given \(\vec x\) using automatic differentiation. <br /></td></tr>
<tr class="separator:ad9aa5a3498e10f76c65636bf6782bb6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f76a86b2f7a23e3b85bc9f464c31d5f"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a2f76a86b2f7a23e3b85bc9f464c31d5f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a2f76a86b2f7a23e3b85bc9f464c31d5f">divergence_mono</a> (<a class="el" href="classtheoretica_1_1dual.html">dual</a>(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1dual.html">dual</a>, N &gt;), const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;x)</td></tr>
<tr class="memdesc:a2f76a86b2f7a23e3b85bc9f464c31d5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the divergence for a given \(\vec x\) of a function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\) using automatic differentiation.  <a href="namespacetheoretica.html#a2f76a86b2f7a23e3b85bc9f464c31d5f">More...</a><br /></td></tr>
<tr class="separator:a2f76a86b2f7a23e3b85bc9f464c31d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8c7083308619ff1db937f1a3fb2b47"><td class="memTemplParams" colspan="2"><a id="aae8c7083308619ff1db937f1a3fb2b47" name="aae8c7083308619ff1db937f1a3fb2b47"></a>
template&lt;unsigned int N, unsigned int M&gt; </td></tr>
<tr class="memitem:aae8c7083308619ff1db937f1a3fb2b47"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1mat.html">mat</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, M, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>jacobian</b> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a9ac9a6f3d85bd0f6ae607178431e51a6">d_real</a>&lt; N &gt;, M &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">d_vec</a>&lt; N &gt;), const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;x)</td></tr>
<tr class="memdesc:aae8c7083308619ff1db937f1a3fb2b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the jacobian of a generic function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}^M\). <br /></td></tr>
<tr class="separator:aae8c7083308619ff1db937f1a3fb2b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f0d70a2a925f1ae0f0831650f8d1d4"><td class="memTemplParams" colspan="2"><a id="a62f0d70a2a925f1ae0f0831650f8d1d4" name="a62f0d70a2a925f1ae0f0831650f8d1d4"></a>
template&lt;unsigned int N, unsigned int M&gt; </td></tr>
<tr class="memitem:a62f0d70a2a925f1ae0f0831650f8d1d4"><td class="memTemplItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classtheoretica_1_1mat.html">mat</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, M, N &gt;(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>jacobian</b> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a9ac9a6f3d85bd0f6ae607178431e51a6">d_real</a>&lt; N &gt;, M &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">d_vec</a>&lt; N &gt;))</td></tr>
<tr class="memdesc:a62f0d70a2a925f1ae0f0831650f8d1d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a function which computes the jacobian of a generic function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}^M\) for a given $\vec x$. <br /></td></tr>
<tr class="separator:a62f0d70a2a925f1ae0f0831650f8d1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f2fa72e9d0a0e077ba5827c5388124"><td class="memTemplParams" colspan="2"><a id="a42f2fa72e9d0a0e077ba5827c5388124" name="a42f2fa72e9d0a0e077ba5827c5388124"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a42f2fa72e9d0a0e077ba5827c5388124"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>curl</b> (<a class="el" href="classtheoretica_1_1vec.html">d_vec</a>&lt; N &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">d_vec</a>&lt; N &gt;), const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;x)</td></tr>
<tr class="memdesc:a42f2fa72e9d0a0e077ba5827c5388124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the curl for a given \(\vec x\) of a vector field defined by \(f: \mathbb{R}^3 \rightarrow \mathbb{R}^3\) using automatic differentiation. <br /></td></tr>
<tr class="separator:a42f2fa72e9d0a0e077ba5827c5388124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca9e6529fd9e3c4da78e4bfbcde0cea"><td class="memTemplParams" colspan="2"><a id="aaca9e6529fd9e3c4da78e4bfbcde0cea" name="aaca9e6529fd9e3c4da78e4bfbcde0cea"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:aaca9e6529fd9e3c4da78e4bfbcde0cea"><td class="memTemplItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>curl</b> (<a class="el" href="classtheoretica_1_1vec.html">d_vec</a>&lt; N &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">d_vec</a>&lt; N &gt;))</td></tr>
<tr class="memdesc:aaca9e6529fd9e3c4da78e4bfbcde0cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a function which computes the curl for a given \(\vec x\) of a vector field defined by \(f: \mathbb{R}^3 \rightarrow \mathbb{R}^3\) using automatic differentiation. <br /></td></tr>
<tr class="separator:aaca9e6529fd9e3c4da78e4bfbcde0cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab34cedf5d18aaa1ee1ca9f148122310"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:aab34cedf5d18aaa1ee1ca9f148122310"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aab34cedf5d18aaa1ee1ca9f148122310">directional_derivative</a> (<a class="el" href="namespacetheoretica.html#a9ac9a6f3d85bd0f6ae607178431e51a6">d_real</a>&lt; N &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">d_vec</a>&lt; N &gt;), const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;x, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;v)</td></tr>
<tr class="memdesc:aab34cedf5d18aaa1ee1ca9f148122310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the directional derivative of a generic function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\).  <a href="namespacetheoretica.html#aab34cedf5d18aaa1ee1ca9f148122310">More...</a><br /></td></tr>
<tr class="separator:aab34cedf5d18aaa1ee1ca9f148122310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03d79f4e33fe2c37460a8d3b6c2d6c4"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ac03d79f4e33fe2c37460a8d3b6c2d6c4"><td class="memTemplItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ac03d79f4e33fe2c37460a8d3b6c2d6c4">directional_derivative</a> (<a class="el" href="namespacetheoretica.html#a9ac9a6f3d85bd0f6ae607178431e51a6">d_real</a>&lt; N &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">d_vec</a>&lt; N &gt;), const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;v)</td></tr>
<tr class="memdesc:ac03d79f4e33fe2c37460a8d3b6c2d6c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a function which computes the directional derivative of a generic function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\).  <a href="namespacetheoretica.html#ac03d79f4e33fe2c37460a8d3b6c2d6c4">More...</a><br /></td></tr>
<tr class="separator:ac03d79f4e33fe2c37460a8d3b6c2d6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f05390a7730f53ca6e280e93603e84"><td class="memTemplParams" colspan="2"><a id="aa8f05390a7730f53ca6e280e93603e84" name="aa8f05390a7730f53ca6e280e93603e84"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:aa8f05390a7730f53ca6e280e93603e84"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>laplacian</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1dual2.html">dual2</a>, N &gt;), const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;x)</td></tr>
<tr class="memdesc:aa8f05390a7730f53ca6e280e93603e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the laplacian differential operator for a generic function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\) at a given $\vec x$. <br /></td></tr>
<tr class="separator:aa8f05390a7730f53ca6e280e93603e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d8ff140ce51f3339ab8f1710cee791"><td class="memTemplParams" colspan="2"><a id="ae3d8ff140ce51f3339ab8f1710cee791" name="ae3d8ff140ce51f3339ab8f1710cee791"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ae3d8ff140ce51f3339ab8f1710cee791"><td class="memTemplItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>laplacian</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1dual2.html">dual2</a>, N &gt;))</td></tr>
<tr class="memdesc:ae3d8ff140ce51f3339ab8f1710cee791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a function which computes the laplacian differential operator for a generic function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\) at a given $\vec x$. <br /></td></tr>
<tr class="separator:ae3d8ff140ce51f3339ab8f1710cee791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ee9950a8eb3137d913d95ad9632f25"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ae6ee9950a8eb3137d913d95ad9632f25"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ae6ee9950a8eb3137d913d95ad9632f25">sturm_liouville</a> (<a class="el" href="namespacetheoretica.html#a9ac9a6f3d85bd0f6ae607178431e51a6">d_real</a>&lt; N &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">d_vec</a>&lt; N &gt;), <a class="el" href="namespacetheoretica.html#a9ac9a6f3d85bd0f6ae607178431e51a6">d_real</a>&lt; N &gt;(*H)(<a class="el" href="classtheoretica_1_1vec.html">d_vec</a>&lt; N &gt;), <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; eta)</td></tr>
<tr class="memdesc:ae6ee9950a8eb3137d913d95ad9632f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Sturm-Liouville operator on a generic function of the form \(f: \mathbb{R}^{2N} \rightarrow \mathbb{R}\) with respect to a given Hamiltonian function of the form \(H: \mathbb{R}^{2N} \rightarrow \mathbb{R}\) where the first N arguments are the coordinates in phase space and the last N arguments are the conjugate momenta, for a given point in phase space.  <a href="namespacetheoretica.html#ae6ee9950a8eb3137d913d95ad9632f25">More...</a><br /></td></tr>
<tr class="separator:ae6ee9950a8eb3137d913d95ad9632f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6629ddaf5a84d7a8f3159b749ef4db0"><td class="memItemLeft" align="right" valign="top"><a id="ae6629ddaf5a84d7a8f3159b749ef4db0" name="ae6629ddaf5a84d7a8f3159b749ef4db0"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>square</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:ae6629ddaf5a84d7a8f3159b749ef4db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square of a second order dual number. <br /></td></tr>
<tr class="separator:ae6629ddaf5a84d7a8f3159b749ef4db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6bc324bd8ae6bbd91b89c7491fe988"><td class="memItemLeft" align="right" valign="top"><a id="afd6bc324bd8ae6bbd91b89c7491fe988" name="afd6bc324bd8ae6bbd91b89c7491fe988"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cube</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:afd6bc324bd8ae6bbd91b89c7491fe988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cube of a second order dual number. <br /></td></tr>
<tr class="separator:afd6bc324bd8ae6bbd91b89c7491fe988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d712fc2f7470e40f65fd470cbb6982"><td class="memItemLeft" align="right" valign="top"><a id="a60d712fc2f7470e40f65fd470cbb6982" name="a60d712fc2f7470e40f65fd470cbb6982"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>conjugate</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a60d712fc2f7470e40f65fd470cbb6982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the conjugate of a second order dual number. <br /></td></tr>
<tr class="separator:a60d712fc2f7470e40f65fd470cbb6982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce493c565b387c0496eff49e137edb6"><td class="memItemLeft" align="right" valign="top"><a id="afce493c565b387c0496eff49e137edb6" name="afce493c565b387c0496eff49e137edb6"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pow</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x, int n)</td></tr>
<tr class="memdesc:afce493c565b387c0496eff49e137edb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the n-th power of a second order dual number. <br /></td></tr>
<tr class="separator:afce493c565b387c0496eff49e137edb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19dd33456cffdbba3f29d85061779e7c"><td class="memItemLeft" align="right" valign="top"><a id="a19dd33456cffdbba3f29d85061779e7c" name="a19dd33456cffdbba3f29d85061779e7c"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sqrt</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a19dd33456cffdbba3f29d85061779e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square root of a second order dual number. <br /></td></tr>
<tr class="separator:a19dd33456cffdbba3f29d85061779e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a34ba6bb56c26ba50c1b2c21d2da7e"><td class="memItemLeft" align="right" valign="top"><a id="ad7a34ba6bb56c26ba50c1b2c21d2da7e" name="ad7a34ba6bb56c26ba50c1b2c21d2da7e"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sin</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:ad7a34ba6bb56c26ba50c1b2c21d2da7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sine of a second order dual number. <br /></td></tr>
<tr class="separator:ad7a34ba6bb56c26ba50c1b2c21d2da7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97cec74fe963806729cbdd0d43de5cd3"><td class="memItemLeft" align="right" valign="top"><a id="a97cec74fe963806729cbdd0d43de5cd3" name="a97cec74fe963806729cbdd0d43de5cd3"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cos</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a97cec74fe963806729cbdd0d43de5cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cosine of a second order dual number. <br /></td></tr>
<tr class="separator:a97cec74fe963806729cbdd0d43de5cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81dcde719b69b4d63ecd3127cb289d9"><td class="memItemLeft" align="right" valign="top"><a id="ac81dcde719b69b4d63ecd3127cb289d9" name="ac81dcde719b69b4d63ecd3127cb289d9"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tan</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:ac81dcde719b69b4d63ecd3127cb289d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the tangent of a second order dual number. <br /></td></tr>
<tr class="separator:ac81dcde719b69b4d63ecd3127cb289d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5fed4cfa9af5d148c59a6005422edc"><td class="memItemLeft" align="right" valign="top"><a id="a9d5fed4cfa9af5d148c59a6005422edc" name="a9d5fed4cfa9af5d148c59a6005422edc"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cot</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a9d5fed4cfa9af5d148c59a6005422edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cotangent of a second order dual number. <br /></td></tr>
<tr class="separator:a9d5fed4cfa9af5d148c59a6005422edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3def790003197bb019f5933b4db45c44"><td class="memItemLeft" align="right" valign="top"><a id="a3def790003197bb019f5933b4db45c44" name="a3def790003197bb019f5933b4db45c44"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>exp</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a3def790003197bb019f5933b4db45c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the exponential of a second order dual number. <br /></td></tr>
<tr class="separator:a3def790003197bb019f5933b4db45c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec5b4f8c9f0d58d65415cec30915d16"><td class="memItemLeft" align="right" valign="top"><a id="a1ec5b4f8c9f0d58d65415cec30915d16" name="a1ec5b4f8c9f0d58d65415cec30915d16"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ln</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a1ec5b4f8c9f0d58d65415cec30915d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a second order dual number. <br /></td></tr>
<tr class="separator:a1ec5b4f8c9f0d58d65415cec30915d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e46804be47f0c4865014a4a763cf76"><td class="memItemLeft" align="right" valign="top"><a id="a29e46804be47f0c4865014a4a763cf76" name="a29e46804be47f0c4865014a4a763cf76"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>log2</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a29e46804be47f0c4865014a4a763cf76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a second order dual number. <br /></td></tr>
<tr class="separator:a29e46804be47f0c4865014a4a763cf76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5101414a44ee9cfda63aea95ea40ef97"><td class="memItemLeft" align="right" valign="top"><a id="a5101414a44ee9cfda63aea95ea40ef97" name="a5101414a44ee9cfda63aea95ea40ef97"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>log10</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a5101414a44ee9cfda63aea95ea40ef97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a second order dual number. <br /></td></tr>
<tr class="separator:a5101414a44ee9cfda63aea95ea40ef97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29720d3e71b280bb3ea048aa71bc3655"><td class="memItemLeft" align="right" valign="top"><a id="a29720d3e71b280bb3ea048aa71bc3655" name="a29720d3e71b280bb3ea048aa71bc3655"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>abs</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a29720d3e71b280bb3ea048aa71bc3655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the absolute value of a second order dual number. <br /></td></tr>
<tr class="separator:a29720d3e71b280bb3ea048aa71bc3655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3761005d81ac85b7297426bfc3f62ea2"><td class="memItemLeft" align="right" valign="top"><a id="a3761005d81ac85b7297426bfc3f62ea2" name="a3761005d81ac85b7297426bfc3f62ea2"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>asin</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a3761005d81ac85b7297426bfc3f62ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arcsine of a second order dual number. <br /></td></tr>
<tr class="separator:a3761005d81ac85b7297426bfc3f62ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf13d7437b2dbea2212cbff3d519b9e5"><td class="memItemLeft" align="right" valign="top"><a id="acf13d7437b2dbea2212cbff3d519b9e5" name="acf13d7437b2dbea2212cbff3d519b9e5"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>acos</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:acf13d7437b2dbea2212cbff3d519b9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arcosine of a second order dual number. <br /></td></tr>
<tr class="separator:acf13d7437b2dbea2212cbff3d519b9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0493013e208bb00505abbc4ca37f292"><td class="memItemLeft" align="right" valign="top"><a id="af0493013e208bb00505abbc4ca37f292" name="af0493013e208bb00505abbc4ca37f292"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>atan</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:af0493013e208bb00505abbc4ca37f292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arctangent of a second order dual number. <br /></td></tr>
<tr class="separator:af0493013e208bb00505abbc4ca37f292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f05865ec8d49e6abf889d81e1cd428"><td class="memItemLeft" align="right" valign="top"><a id="ad5f05865ec8d49e6abf889d81e1cd428" name="ad5f05865ec8d49e6abf889d81e1cd428"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>square</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:ad5f05865ec8d49e6abf889d81e1cd428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square of a dual number. <br /></td></tr>
<tr class="separator:ad5f05865ec8d49e6abf889d81e1cd428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab28b5c479cfd017f81b9806aa27838e"><td class="memItemLeft" align="right" valign="top"><a id="aab28b5c479cfd017f81b9806aa27838e" name="aab28b5c479cfd017f81b9806aa27838e"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cube</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:aab28b5c479cfd017f81b9806aa27838e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cube of a dual number. <br /></td></tr>
<tr class="separator:aab28b5c479cfd017f81b9806aa27838e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7b08c40c17a7b35ba2b1e3c6c3357b"><td class="memItemLeft" align="right" valign="top"><a id="aec7b08c40c17a7b35ba2b1e3c6c3357b" name="aec7b08c40c17a7b35ba2b1e3c6c3357b"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>conjugate</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:aec7b08c40c17a7b35ba2b1e3c6c3357b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the conjugate of a dual number. <br /></td></tr>
<tr class="separator:aec7b08c40c17a7b35ba2b1e3c6c3357b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad063ce053e951e9183799584090c0e"><td class="memItemLeft" align="right" valign="top"><a id="a4ad063ce053e951e9183799584090c0e" name="a4ad063ce053e951e9183799584090c0e"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pow</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x, int n)</td></tr>
<tr class="memdesc:a4ad063ce053e951e9183799584090c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the n-th power of a dual number. <br /></td></tr>
<tr class="separator:a4ad063ce053e951e9183799584090c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e64e0c5a3452708528e6fb46f97b84e"><td class="memItemLeft" align="right" valign="top"><a id="a6e64e0c5a3452708528e6fb46f97b84e" name="a6e64e0c5a3452708528e6fb46f97b84e"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sqrt</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a6e64e0c5a3452708528e6fb46f97b84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square root of a dual number. <br /></td></tr>
<tr class="separator:a6e64e0c5a3452708528e6fb46f97b84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8369c63cfe1b787c3916865de1ac534b"><td class="memItemLeft" align="right" valign="top"><a id="a8369c63cfe1b787c3916865de1ac534b" name="a8369c63cfe1b787c3916865de1ac534b"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sin</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a8369c63cfe1b787c3916865de1ac534b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sine of a dual number. <br /></td></tr>
<tr class="separator:a8369c63cfe1b787c3916865de1ac534b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39630b09f7294762464b1eb5301b508f"><td class="memItemLeft" align="right" valign="top"><a id="a39630b09f7294762464b1eb5301b508f" name="a39630b09f7294762464b1eb5301b508f"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cos</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a39630b09f7294762464b1eb5301b508f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cosine of a dual number. <br /></td></tr>
<tr class="separator:a39630b09f7294762464b1eb5301b508f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef33e5920ccf4cfe7f79c70ebc9dfbb"><td class="memItemLeft" align="right" valign="top"><a id="afef33e5920ccf4cfe7f79c70ebc9dfbb" name="afef33e5920ccf4cfe7f79c70ebc9dfbb"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tan</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:afef33e5920ccf4cfe7f79c70ebc9dfbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the tangent of a dual number. <br /></td></tr>
<tr class="separator:afef33e5920ccf4cfe7f79c70ebc9dfbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdf17b1485bdfb0f967caee134136b6"><td class="memItemLeft" align="right" valign="top"><a id="aacdf17b1485bdfb0f967caee134136b6" name="aacdf17b1485bdfb0f967caee134136b6"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cot</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:aacdf17b1485bdfb0f967caee134136b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cotangent of a dual number. <br /></td></tr>
<tr class="separator:aacdf17b1485bdfb0f967caee134136b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21974bc022495f59a7702ce937f4544c"><td class="memItemLeft" align="right" valign="top"><a id="a21974bc022495f59a7702ce937f4544c" name="a21974bc022495f59a7702ce937f4544c"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>exp</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a21974bc022495f59a7702ce937f4544c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the exponential of a dual number. <br /></td></tr>
<tr class="separator:a21974bc022495f59a7702ce937f4544c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8acf40b0d2b7e4f62d95dd4bec0b169d"><td class="memItemLeft" align="right" valign="top"><a id="a8acf40b0d2b7e4f62d95dd4bec0b169d" name="a8acf40b0d2b7e4f62d95dd4bec0b169d"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ln</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a8acf40b0d2b7e4f62d95dd4bec0b169d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a dual number. <br /></td></tr>
<tr class="separator:a8acf40b0d2b7e4f62d95dd4bec0b169d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d6466e16b24bd1dfac49fd0c50ed79"><td class="memItemLeft" align="right" valign="top"><a id="a30d6466e16b24bd1dfac49fd0c50ed79" name="a30d6466e16b24bd1dfac49fd0c50ed79"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>log2</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a30d6466e16b24bd1dfac49fd0c50ed79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a dual number. <br /></td></tr>
<tr class="separator:a30d6466e16b24bd1dfac49fd0c50ed79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254b955eacdab15792dcb9d871559499"><td class="memItemLeft" align="right" valign="top"><a id="a254b955eacdab15792dcb9d871559499" name="a254b955eacdab15792dcb9d871559499"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>log10</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a254b955eacdab15792dcb9d871559499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a dual number. <br /></td></tr>
<tr class="separator:a254b955eacdab15792dcb9d871559499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3796818092440b5f1745c67b1162ddcf"><td class="memItemLeft" align="right" valign="top"><a id="a3796818092440b5f1745c67b1162ddcf" name="a3796818092440b5f1745c67b1162ddcf"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>abs</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a3796818092440b5f1745c67b1162ddcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the absolute value of a dual number. <br /></td></tr>
<tr class="separator:a3796818092440b5f1745c67b1162ddcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892e7542b82c516e65023555a0e30f6b"><td class="memItemLeft" align="right" valign="top"><a id="a892e7542b82c516e65023555a0e30f6b" name="a892e7542b82c516e65023555a0e30f6b"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>asin</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a892e7542b82c516e65023555a0e30f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arcsine of a dual number. <br /></td></tr>
<tr class="separator:a892e7542b82c516e65023555a0e30f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7f07a4d7a0abca49824b5926f259f1"><td class="memItemLeft" align="right" valign="top"><a id="abd7f07a4d7a0abca49824b5926f259f1" name="abd7f07a4d7a0abca49824b5926f259f1"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>acos</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:abd7f07a4d7a0abca49824b5926f259f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arccosine of a dual number. <br /></td></tr>
<tr class="separator:abd7f07a4d7a0abca49824b5926f259f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9ae8cb187999582be3db40cf149f43"><td class="memItemLeft" align="right" valign="top"><a id="a6b9ae8cb187999582be3db40cf149f43" name="a6b9ae8cb187999582be3db40cf149f43"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>atan</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a6b9ae8cb187999582be3db40cf149f43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arctangent of a dual number. <br /></td></tr>
<tr class="separator:a6b9ae8cb187999582be3db40cf149f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8c95ef4ed4e4da6af87e9eee675f82"><td class="memItemLeft" align="right" valign="top"><a id="a1f8c95ef4ed4e4da6af87e9eee675f82" name="a1f8c95ef4ed4e4da6af87e9eee675f82"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sinh</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a1f8c95ef4ed4e4da6af87e9eee675f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic sine of a dual number. <br /></td></tr>
<tr class="separator:a1f8c95ef4ed4e4da6af87e9eee675f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8d81973a127a1e66c180cba58d08ee"><td class="memItemLeft" align="right" valign="top"><a id="a1b8d81973a127a1e66c180cba58d08ee" name="a1b8d81973a127a1e66c180cba58d08ee"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cosh</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a1b8d81973a127a1e66c180cba58d08ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic cosine of a dual number. <br /></td></tr>
<tr class="separator:a1b8d81973a127a1e66c180cba58d08ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf2c5dcfac28891e1e8a3accdf7dd21"><td class="memItemLeft" align="right" valign="top"><a id="afbf2c5dcfac28891e1e8a3accdf7dd21" name="afbf2c5dcfac28891e1e8a3accdf7dd21"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tanh</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:afbf2c5dcfac28891e1e8a3accdf7dd21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic tangent of a dual number. <br /></td></tr>
<tr class="separator:afbf2c5dcfac28891e1e8a3accdf7dd21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab864254bd5f629822f3d1fcee3cff6b7"><td class="memTemplParams" colspan="2"><a id="ab864254bd5f629822f3d1fcee3cff6b7" name="ab864254bd5f629822f3d1fcee3cff6b7"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ab864254bd5f629822f3d1fcee3cff6b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>square</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:ab864254bd5f629822f3d1fcee3cff6b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square of a multidual number. <br /></td></tr>
<tr class="separator:ab864254bd5f629822f3d1fcee3cff6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae356adeb60d93c78bd5d27ddf49a6c66"><td class="memTemplParams" colspan="2"><a id="ae356adeb60d93c78bd5d27ddf49a6c66" name="ae356adeb60d93c78bd5d27ddf49a6c66"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ae356adeb60d93c78bd5d27ddf49a6c66"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cube</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:ae356adeb60d93c78bd5d27ddf49a6c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cube of a multidual number. <br /></td></tr>
<tr class="separator:ae356adeb60d93c78bd5d27ddf49a6c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab554a86db7527158fdd4f3fa000989af"><td class="memTemplParams" colspan="2"><a id="ab554a86db7527158fdd4f3fa000989af" name="ab554a86db7527158fdd4f3fa000989af"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ab554a86db7527158fdd4f3fa000989af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>conjugate</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:ab554a86db7527158fdd4f3fa000989af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the conjugate of a multidual number. <br /></td></tr>
<tr class="separator:ab554a86db7527158fdd4f3fa000989af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb716c77e812d83d2aed787ff39b62e"><td class="memTemplParams" colspan="2"><a id="adfb716c77e812d83d2aed787ff39b62e" name="adfb716c77e812d83d2aed787ff39b62e"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:adfb716c77e812d83d2aed787ff39b62e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>pow</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x, int n)</td></tr>
<tr class="memdesc:adfb716c77e812d83d2aed787ff39b62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the n-th power of a multidual number. <br /></td></tr>
<tr class="separator:adfb716c77e812d83d2aed787ff39b62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aaa215522430587c6c8dc7971269fb5"><td class="memTemplParams" colspan="2"><a id="a8aaa215522430587c6c8dc7971269fb5" name="a8aaa215522430587c6c8dc7971269fb5"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a8aaa215522430587c6c8dc7971269fb5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sqrt</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:a8aaa215522430587c6c8dc7971269fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square root of a multidual number. <br /></td></tr>
<tr class="separator:a8aaa215522430587c6c8dc7971269fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1444ff9faf0b4b247468462d7b7cb01"><td class="memTemplParams" colspan="2"><a id="af1444ff9faf0b4b247468462d7b7cb01" name="af1444ff9faf0b4b247468462d7b7cb01"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:af1444ff9faf0b4b247468462d7b7cb01"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sin</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:af1444ff9faf0b4b247468462d7b7cb01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sine of a multidual number. <br /></td></tr>
<tr class="separator:af1444ff9faf0b4b247468462d7b7cb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ac8631aae8f4c3ae5dc63cbabc57c8"><td class="memTemplParams" colspan="2"><a id="ac8ac8631aae8f4c3ae5dc63cbabc57c8" name="ac8ac8631aae8f4c3ae5dc63cbabc57c8"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ac8ac8631aae8f4c3ae5dc63cbabc57c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cos</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:ac8ac8631aae8f4c3ae5dc63cbabc57c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cosine of a multidual number. <br /></td></tr>
<tr class="separator:ac8ac8631aae8f4c3ae5dc63cbabc57c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe9ca76dc4db09890a618a1d77da20b"><td class="memTemplParams" colspan="2"><a id="aafe9ca76dc4db09890a618a1d77da20b" name="aafe9ca76dc4db09890a618a1d77da20b"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:aafe9ca76dc4db09890a618a1d77da20b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tan</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:aafe9ca76dc4db09890a618a1d77da20b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the tangent of a multidual number. <br /></td></tr>
<tr class="separator:aafe9ca76dc4db09890a618a1d77da20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8839aa97612a40db14f1c8818b463d0"><td class="memTemplParams" colspan="2"><a id="ac8839aa97612a40db14f1c8818b463d0" name="ac8839aa97612a40db14f1c8818b463d0"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ac8839aa97612a40db14f1c8818b463d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cot</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:ac8839aa97612a40db14f1c8818b463d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cotangent of a multidual number. <br /></td></tr>
<tr class="separator:ac8839aa97612a40db14f1c8818b463d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311ed7edb65295b9284b3f10e5fa5f90"><td class="memTemplParams" colspan="2"><a id="a311ed7edb65295b9284b3f10e5fa5f90" name="a311ed7edb65295b9284b3f10e5fa5f90"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a311ed7edb65295b9284b3f10e5fa5f90"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>exp</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:a311ed7edb65295b9284b3f10e5fa5f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the exponential of a multidual number. <br /></td></tr>
<tr class="separator:a311ed7edb65295b9284b3f10e5fa5f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecb01797f9cac464a6dea02d5a73e34"><td class="memTemplParams" colspan="2"><a id="adecb01797f9cac464a6dea02d5a73e34" name="adecb01797f9cac464a6dea02d5a73e34"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:adecb01797f9cac464a6dea02d5a73e34"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ln</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:adecb01797f9cac464a6dea02d5a73e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a multidual number. <br /></td></tr>
<tr class="separator:adecb01797f9cac464a6dea02d5a73e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84cf28a3ec07fef45f28617946e62961"><td class="memTemplParams" colspan="2"><a id="a84cf28a3ec07fef45f28617946e62961" name="a84cf28a3ec07fef45f28617946e62961"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a84cf28a3ec07fef45f28617946e62961"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>log2</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:a84cf28a3ec07fef45f28617946e62961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a multidual number. <br /></td></tr>
<tr class="separator:a84cf28a3ec07fef45f28617946e62961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace737cd7c21a314c33915adf9956a640"><td class="memTemplParams" colspan="2"><a id="ace737cd7c21a314c33915adf9956a640" name="ace737cd7c21a314c33915adf9956a640"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ace737cd7c21a314c33915adf9956a640"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>log10</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:ace737cd7c21a314c33915adf9956a640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a multidual number. <br /></td></tr>
<tr class="separator:ace737cd7c21a314c33915adf9956a640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb87636665493a0584655ad754e4c53"><td class="memTemplParams" colspan="2"><a id="a4eb87636665493a0584655ad754e4c53" name="a4eb87636665493a0584655ad754e4c53"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a4eb87636665493a0584655ad754e4c53"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:a4eb87636665493a0584655ad754e4c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the absolute value of a multidual number. <br /></td></tr>
<tr class="separator:a4eb87636665493a0584655ad754e4c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9fac1b91317d696fc2b4ea479b30b9"><td class="memTemplParams" colspan="2"><a id="a5b9fac1b91317d696fc2b4ea479b30b9" name="a5b9fac1b91317d696fc2b4ea479b30b9"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a5b9fac1b91317d696fc2b4ea479b30b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>asin</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:a5b9fac1b91317d696fc2b4ea479b30b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arcsine of a multidual number. <br /></td></tr>
<tr class="separator:a5b9fac1b91317d696fc2b4ea479b30b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf0ac356621f93c30fc6bdd9a1977a3"><td class="memTemplParams" colspan="2"><a id="afcf0ac356621f93c30fc6bdd9a1977a3" name="afcf0ac356621f93c30fc6bdd9a1977a3"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:afcf0ac356621f93c30fc6bdd9a1977a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>acos</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:afcf0ac356621f93c30fc6bdd9a1977a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arccosine of a multidual number. <br /></td></tr>
<tr class="separator:afcf0ac356621f93c30fc6bdd9a1977a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f31ace8ee7a5730ba7f0b1a60df5835"><td class="memTemplParams" colspan="2"><a id="a0f31ace8ee7a5730ba7f0b1a60df5835" name="a0f31ace8ee7a5730ba7f0b1a60df5835"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a0f31ace8ee7a5730ba7f0b1a60df5835"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>atan</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:a0f31ace8ee7a5730ba7f0b1a60df5835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arctangent of a multidual number. <br /></td></tr>
<tr class="separator:a0f31ace8ee7a5730ba7f0b1a60df5835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c71523f7f9d97e48c2de258ef952500"><td class="memTemplParams" colspan="2"><a id="a8c71523f7f9d97e48c2de258ef952500" name="a8c71523f7f9d97e48c2de258ef952500"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a8c71523f7f9d97e48c2de258ef952500"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sinh</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:a8c71523f7f9d97e48c2de258ef952500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic sine of a multidual number. <br /></td></tr>
<tr class="separator:a8c71523f7f9d97e48c2de258ef952500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b0ad9b86faf6ab2d308f9f76d31010"><td class="memTemplParams" colspan="2"><a id="ae2b0ad9b86faf6ab2d308f9f76d31010" name="ae2b0ad9b86faf6ab2d308f9f76d31010"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ae2b0ad9b86faf6ab2d308f9f76d31010"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cosh</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:ae2b0ad9b86faf6ab2d308f9f76d31010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic cosine of a multidual number. <br /></td></tr>
<tr class="separator:ae2b0ad9b86faf6ab2d308f9f76d31010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa990eeebdd5fb8e93c96c4ed6ff91317"><td class="memTemplParams" colspan="2"><a id="aa990eeebdd5fb8e93c96c4ed6ff91317" name="aa990eeebdd5fb8e93c96c4ed6ff91317"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:aa990eeebdd5fb8e93c96c4ed6ff91317"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tanh</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:aa990eeebdd5fb8e93c96c4ed6ff91317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic tangent of a multidual number. <br /></td></tr>
<tr class="separator:aa990eeebdd5fb8e93c96c4ed6ff91317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db068fdfc750be0e45e3fcaa77fc458"><td class="memTemplParams" colspan="2">template&lt;typename T  = real&gt; </td></tr>
<tr class="memitem:a3db068fdfc750be0e45e3fcaa77fc458"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a3db068fdfc750be0e45e3fcaa77fc458">deriv_polynomial</a> (const <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a3db068fdfc750be0e45e3fcaa77fc458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the derivative of a polynomial.  <a href="namespacetheoretica.html#a3db068fdfc750be0e45e3fcaa77fc458">More...</a><br /></td></tr>
<tr class="separator:a3db068fdfc750be0e45e3fcaa77fc458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bbf1baa785f514b3e3a74f80fbd9546"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a5bbf1baa785f514b3e3a74f80fbd9546"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a5bbf1baa785f514b3e3a74f80fbd9546">deriv_central</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h=<a class="el" href="namespacetheoretica.html#a72dfe63d1cce5e9c204cba3493a4e598">DERIV_STEPSIZE</a>)</td></tr>
<tr class="memdesc:a5bbf1baa785f514b3e3a74f80fbd9546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derivative approximation using the central method.  <a href="namespacetheoretica.html#a5bbf1baa785f514b3e3a74f80fbd9546">More...</a><br /></td></tr>
<tr class="separator:a5bbf1baa785f514b3e3a74f80fbd9546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936dad7b99b64c874223aa537c3ad84f"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a936dad7b99b64c874223aa537c3ad84f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a936dad7b99b64c874223aa537c3ad84f">deriv_forward</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h=<a class="el" href="namespacetheoretica.html#a72dfe63d1cce5e9c204cba3493a4e598">DERIV_STEPSIZE</a>)</td></tr>
<tr class="memdesc:a936dad7b99b64c874223aa537c3ad84f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derivative approximation using the forward method.  <a href="namespacetheoretica.html#a936dad7b99b64c874223aa537c3ad84f">More...</a><br /></td></tr>
<tr class="separator:a936dad7b99b64c874223aa537c3ad84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fda7d7c90a088c8bdbf28b0908c71e8"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a0fda7d7c90a088c8bdbf28b0908c71e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a0fda7d7c90a088c8bdbf28b0908c71e8">deriv_backward</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h=<a class="el" href="namespacetheoretica.html#a72dfe63d1cce5e9c204cba3493a4e598">DERIV_STEPSIZE</a>)</td></tr>
<tr class="memdesc:a0fda7d7c90a088c8bdbf28b0908c71e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derivative approximation using the backward method.  <a href="namespacetheoretica.html#a0fda7d7c90a088c8bdbf28b0908c71e8">More...</a><br /></td></tr>
<tr class="separator:a0fda7d7c90a088c8bdbf28b0908c71e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f963a737accf2110a8ed71a5064320"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a93f963a737accf2110a8ed71a5064320"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a93f963a737accf2110a8ed71a5064320">deriv_ridders2</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h=<a class="el" href="namespacetheoretica.html#a72dfe63d1cce5e9c204cba3493a4e598">DERIV_STEPSIZE</a>)</td></tr>
<tr class="memdesc:a93f963a737accf2110a8ed71a5064320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ridder's derivative approximation of second degree.  <a href="namespacetheoretica.html#a93f963a737accf2110a8ed71a5064320">More...</a><br /></td></tr>
<tr class="separator:a93f963a737accf2110a8ed71a5064320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c5277448360f087fa63323020675c6"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a08c5277448360f087fa63323020675c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a08c5277448360f087fa63323020675c6">deriv_ridders</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h=0.01, unsigned int degree=3)</td></tr>
<tr class="memdesc:a08c5277448360f087fa63323020675c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ridder's derivative approximation of arbitrary degree.  <a href="namespacetheoretica.html#a08c5277448360f087fa63323020675c6">More...</a><br /></td></tr>
<tr class="separator:a08c5277448360f087fa63323020675c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13c23d95e0130b1e29ac617f313f27d"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:af13c23d95e0130b1e29ac617f313f27d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#af13c23d95e0130b1e29ac617f313f27d">deriv</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h=<a class="el" href="namespacetheoretica.html#a72dfe63d1cce5e9c204cba3493a4e598">DERIV_STEPSIZE</a>)</td></tr>
<tr class="memdesc:af13c23d95e0130b1e29ac617f313f27d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the best available algorithm to approximate the derivative of a real function.  <a href="namespacetheoretica.html#af13c23d95e0130b1e29ac617f313f27d">More...</a><br /></td></tr>
<tr class="separator:af13c23d95e0130b1e29ac617f313f27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad376dcd3be0e15133bbedf6ad1160587"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:ad376dcd3be0e15133bbedf6ad1160587"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ad376dcd3be0e15133bbedf6ad1160587">deriv2</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h=<a class="el" href="namespacetheoretica.html#a72dfe63d1cce5e9c204cba3493a4e598">DERIV_STEPSIZE</a>)</td></tr>
<tr class="memdesc:ad376dcd3be0e15133bbedf6ad1160587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the best available algorithm to approximate the second derivative of a real function.  <a href="namespacetheoretica.html#ad376dcd3be0e15133bbedf6ad1160587">More...</a><br /></td></tr>
<tr class="separator:ad376dcd3be0e15133bbedf6ad1160587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30054ccf81cf93e466c08361e4ff9fb"><td class="memTemplParams" colspan="2">template&lt;typename T  = real&gt; </td></tr>
<tr class="memitem:ad30054ccf81cf93e466c08361e4ff9fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ad30054ccf81cf93e466c08361e4ff9fb">integrate_polynomial</a> (const <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:ad30054ccf81cf93e466c08361e4ff9fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the indefinite integral of a polynomial.  <a href="namespacetheoretica.html#ad30054ccf81cf93e466c08361e4ff9fb">More...</a><br /></td></tr>
<tr class="separator:ad30054ccf81cf93e466c08361e4ff9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a48a7bb7296e78f5c1b0c5f5bcf4d93"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a1a48a7bb7296e78f5c1b0c5f5bcf4d93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a1a48a7bb7296e78f5c1b0c5f5bcf4d93">integral_midpoint</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int steps=<a class="el" href="namespacetheoretica.html#aa1f0e3448f94ada54d171499c0c95ae4">INTEGRATION_STEPS</a>)</td></tr>
<tr class="memdesc:a1a48a7bb7296e78f5c1b0c5f5bcf4d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate the definite integral of an arbitrary function using the midpoint method.  <a href="namespacetheoretica.html#a1a48a7bb7296e78f5c1b0c5f5bcf4d93">More...</a><br /></td></tr>
<tr class="separator:a1a48a7bb7296e78f5c1b0c5f5bcf4d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cbfca610e297e184c272140d991e987"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a4cbfca610e297e184c272140d991e987"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a4cbfca610e297e184c272140d991e987">integral_trapezoid</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int steps=<a class="el" href="namespacetheoretica.html#aa1f0e3448f94ada54d171499c0c95ae4">INTEGRATION_STEPS</a>)</td></tr>
<tr class="memdesc:a4cbfca610e297e184c272140d991e987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate the definite integral of an arbitrary function using the trapezoid method.  <a href="namespacetheoretica.html#a4cbfca610e297e184c272140d991e987">More...</a><br /></td></tr>
<tr class="separator:a4cbfca610e297e184c272140d991e987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f3d75e6a0c23d23a5e685145437ff5"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:ad5f3d75e6a0c23d23a5e685145437ff5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ad5f3d75e6a0c23d23a5e685145437ff5">integral_simpson</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int steps=<a class="el" href="namespacetheoretica.html#aa1f0e3448f94ada54d171499c0c95ae4">INTEGRATION_STEPS</a>)</td></tr>
<tr class="memdesc:ad5f3d75e6a0c23d23a5e685145437ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate the definite integral of an arbitrary function using Simpson's method.  <a href="namespacetheoretica.html#ad5f3d75e6a0c23d23a5e685145437ff5">More...</a><br /></td></tr>
<tr class="separator:ad5f3d75e6a0c23d23a5e685145437ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6c51cd5ff6287130ab25a6efbbe2e5"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a8f6c51cd5ff6287130ab25a6efbbe2e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a8f6c51cd5ff6287130ab25a6efbbe2e5">integral_romberg</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int iter=8)</td></tr>
<tr class="memdesc:a8f6c51cd5ff6287130ab25a6efbbe2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate the definite integral of an arbitrary function using Romberg's method accurate to the given order.  <a href="namespacetheoretica.html#a8f6c51cd5ff6287130ab25a6efbbe2e5">More...</a><br /></td></tr>
<tr class="separator:a8f6c51cd5ff6287130ab25a6efbbe2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b399a5f43e97fecaa0017297df12d3"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a15b399a5f43e97fecaa0017297df12d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a15b399a5f43e97fecaa0017297df12d3">integral_romberg_tol</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=INTEGRATION_TOL)</td></tr>
<tr class="memdesc:a15b399a5f43e97fecaa0017297df12d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate the definite integral of an arbitrary function using Romberg's method to the given tolerance.  <a href="namespacetheoretica.html#a15b399a5f43e97fecaa0017297df12d3">More...</a><br /></td></tr>
<tr class="separator:a15b399a5f43e97fecaa0017297df12d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96bf598b39c148bddb7ceebd7aa9b446"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a96bf598b39c148bddb7ceebd7aa9b446"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a96bf598b39c148bddb7ceebd7aa9b446">integral_gauss</a> (RealFunction f, const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;x, const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;w)</td></tr>
<tr class="memdesc:a96bf598b39c148bddb7ceebd7aa9b446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Gaussian quadrature using the given points and weights.  <a href="namespacetheoretica.html#a96bf598b39c148bddb7ceebd7aa9b446">More...</a><br /></td></tr>
<tr class="separator:a96bf598b39c148bddb7ceebd7aa9b446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72ca0802148fca511bdb53d2cf958a8"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:aa72ca0802148fca511bdb53d2cf958a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa72ca0802148fca511bdb53d2cf958a8">integral_gauss</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> *x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> *w, unsigned int n)</td></tr>
<tr class="memdesc:aa72ca0802148fca511bdb53d2cf958a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Gaussian quadrature using the given points and weights.  <a href="namespacetheoretica.html#aa72ca0802148fca511bdb53d2cf958a8">More...</a><br /></td></tr>
<tr class="separator:aa72ca0802148fca511bdb53d2cf958a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500bb7c67e29e96e7f6c3655b8f7d3b3"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a500bb7c67e29e96e7f6c3655b8f7d3b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a500bb7c67e29e96e7f6c3655b8f7d3b3">integral_gauss</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> *x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> *w, unsigned int n, <a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> Winv)</td></tr>
<tr class="memdesc:a500bb7c67e29e96e7f6c3655b8f7d3b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Gaussian quadrature using the given points and weights.  <a href="namespacetheoretica.html#a500bb7c67e29e96e7f6c3655b8f7d3b3">More...</a><br /></td></tr>
<tr class="separator:a500bb7c67e29e96e7f6c3655b8f7d3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2038787a4650a9610cdf4639901677a"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:ad2038787a4650a9610cdf4639901677a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ad2038787a4650a9610cdf4639901677a">integral_legendre</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> *x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> *w, unsigned int n)</td></tr>
<tr class="memdesc:ad2038787a4650a9610cdf4639901677a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Gauss-Legendre quadrature of arbitrary degree to approximate a definite integral providing the roots of the n degree Legendre polynomial.  <a href="namespacetheoretica.html#ad2038787a4650a9610cdf4639901677a">More...</a><br /></td></tr>
<tr class="separator:ad2038787a4650a9610cdf4639901677a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ca5edbbdee0a51f8c0bfddb4c71f69"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a62ca5edbbdee0a51f8c0bfddb4c71f69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a62ca5edbbdee0a51f8c0bfddb4c71f69">integral_legendre</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;x, const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;w)</td></tr>
<tr class="memdesc:a62ca5edbbdee0a51f8c0bfddb4c71f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Gauss-Legendre quadrature of arbitrary degree to approximate a definite integral providing the roots of the n degree Legendre polynomial.  <a href="namespacetheoretica.html#a62ca5edbbdee0a51f8c0bfddb4c71f69">More...</a><br /></td></tr>
<tr class="separator:a62ca5edbbdee0a51f8c0bfddb4c71f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f79a7b3f80ff901eba3340d1ba14a5"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:ad3f79a7b3f80ff901eba3340d1ba14a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ad3f79a7b3f80ff901eba3340d1ba14a5">integral_legendre</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;x)</td></tr>
<tr class="memdesc:ad3f79a7b3f80ff901eba3340d1ba14a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Gauss-Legendre quadrature of arbitrary degree to approximate a definite integral providing the roots of the n degree Legendre polynomial.  <a href="namespacetheoretica.html#ad3f79a7b3f80ff901eba3340d1ba14a5">More...</a><br /></td></tr>
<tr class="separator:ad3f79a7b3f80ff901eba3340d1ba14a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8406b9711bb256a289bb656c4c52e39"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:aa8406b9711bb256a289bb656c4c52e39"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa8406b9711bb256a289bb656c4c52e39">integral_legendre</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int n=16)</td></tr>
<tr class="memdesc:aa8406b9711bb256a289bb656c4c52e39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Gauss-Legendre quadrature of degree 2, 4, 8 or 16, using pre-computed values, to approximate an integral over [a, b].  <a href="namespacetheoretica.html#aa8406b9711bb256a289bb656c4c52e39">More...</a><br /></td></tr>
<tr class="separator:aa8406b9711bb256a289bb656c4c52e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a53869de63d5c2daf7790511ce8aac"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:aa4a53869de63d5c2daf7790511ce8aac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa4a53869de63d5c2daf7790511ce8aac">integral_laguerre</a> (RealFunction f, const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;x)</td></tr>
<tr class="memdesc:aa4a53869de63d5c2daf7790511ce8aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Gauss-Laguerre quadrature of arbitrary degree to approximate an integral over [0, +inf) providing the roots of the n degree Legendre polynomial.  <a href="namespacetheoretica.html#aa4a53869de63d5c2daf7790511ce8aac">More...</a><br /></td></tr>
<tr class="separator:aa4a53869de63d5c2daf7790511ce8aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c209d0975ad962d9b5e68a3661150ab"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a0c209d0975ad962d9b5e68a3661150ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a0c209d0975ad962d9b5e68a3661150ab">integral_laguerre</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;x)</td></tr>
<tr class="memdesc:a0c209d0975ad962d9b5e68a3661150ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Gauss-Laguerre quadrature of arbitrary degree to approximate an integral over [a, b] providing the roots of the n degree Legendre polynomial.  <a href="namespacetheoretica.html#a0c209d0975ad962d9b5e68a3661150ab">More...</a><br /></td></tr>
<tr class="separator:a0c209d0975ad962d9b5e68a3661150ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15d3b8d15def86bb228a46811100bca"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:ab15d3b8d15def86bb228a46811100bca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ab15d3b8d15def86bb228a46811100bca">integral_laguerre</a> (RealFunction f, unsigned int n=16)</td></tr>
<tr class="memdesc:ab15d3b8d15def86bb228a46811100bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Gauss-Laguerre quadrature of degree 2, 4, 8 or 16, using pre-computed values, to approximate an integral over [0, +inf).  <a href="namespacetheoretica.html#ab15d3b8d15def86bb228a46811100bca">More...</a><br /></td></tr>
<tr class="separator:ab15d3b8d15def86bb228a46811100bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe2540b2ff381a14b61588280cb9016"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:abbe2540b2ff381a14b61588280cb9016"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#abbe2540b2ff381a14b61588280cb9016">integral_hermite</a> (RealFunction f, const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;x)</td></tr>
<tr class="memdesc:abbe2540b2ff381a14b61588280cb9016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Gauss-Hermite quadrature of arbitrary degree to approximate an integral over (-inf, +inf) providing the roots of the n degree Hermite polynomial.  <a href="namespacetheoretica.html#abbe2540b2ff381a14b61588280cb9016">More...</a><br /></td></tr>
<tr class="separator:abbe2540b2ff381a14b61588280cb9016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd783739794f700157cc7f7d6f9d9632"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:abd783739794f700157cc7f7d6f9d9632"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#abd783739794f700157cc7f7d6f9d9632">integral_hermite</a> (RealFunction f, unsigned int n=16)</td></tr>
<tr class="memdesc:abd783739794f700157cc7f7d6f9d9632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Gauss-Hermite quadrature of degree 2, 4, 8 or 16, using pre-computed values, to approximate an integral over (-inf, +inf).  <a href="namespacetheoretica.html#abd783739794f700157cc7f7d6f9d9632">More...</a><br /></td></tr>
<tr class="separator:abd783739794f700157cc7f7d6f9d9632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c185da4a1deaea582889cbc534989e7"><td class="memItemLeft" align="right" valign="top"><a id="a3c185da4a1deaea582889cbc534989e7" name="a3c185da4a1deaea582889cbc534989e7"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>integral_inf_riemann</b> (<a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> step_sz=1, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tol=INTEGRATION_TOL, unsigned int max_iter=100)</td></tr>
<tr class="memdesc:a3c185da4a1deaea582889cbc534989e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate a function from a point up to infinity by integrating it by steps, stopping execution when the variation of the integral is small enough or the number of steps reaches a maximum value. <br /></td></tr>
<tr class="separator:a3c185da4a1deaea582889cbc534989e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae095e7eee4b03eddc3b035b2bde14a7e"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:ae095e7eee4b03eddc3b035b2bde14a7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ae095e7eee4b03eddc3b035b2bde14a7e">integral</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b)</td></tr>
<tr class="memdesc:ae095e7eee4b03eddc3b035b2bde14a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the best available algorithm to approximate the definite integral of a real function.  <a href="namespacetheoretica.html#ae095e7eee4b03eddc3b035b2bde14a7e">More...</a><br /></td></tr>
<tr class="separator:ae095e7eee4b03eddc3b035b2bde14a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29abada0134095a6d9a120c241ce461"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:aa29abada0134095a6d9a120c241ce461"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa29abada0134095a6d9a120c241ce461">integral</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tol)</td></tr>
<tr class="memdesc:aa29abada0134095a6d9a120c241ce461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the best available algorithm to approximate the definite integral of a real function to a given tolerance.  <a href="namespacetheoretica.html#aa29abada0134095a6d9a120c241ce461">More...</a><br /></td></tr>
<tr class="separator:aa29abada0134095a6d9a120c241ce461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d5877a3794df2193a5f7bada42ed2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a69d5877a3794df2193a5f7bada42ed2d">ode_euler</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*f)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>), <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt; s, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h)</td></tr>
<tr class="memdesc:a69d5877a3794df2193a5f7bada42ed2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate numerically a differential equation in one unknown using Euler's method.  <a href="namespacetheoretica.html#a69d5877a3794df2193a5f7bada42ed2d">More...</a><br /></td></tr>
<tr class="separator:a69d5877a3794df2193a5f7bada42ed2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac97182a0900bc58e53c78fa1b3eb2a"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a9ac97182a0900bc58e53c78fa1b3eb2a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a9ac97182a0900bc58e53c78fa1b3eb2a">ode_euler</a> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;(*f)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;), <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt; s, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h)</td></tr>
<tr class="memdesc:a9ac97182a0900bc58e53c78fa1b3eb2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate numerically a differential equation in N unknowns using Euler's method.  <a href="namespacetheoretica.html#a9ac97182a0900bc58e53c78fa1b3eb2a">More...</a><br /></td></tr>
<tr class="separator:a9ac97182a0900bc58e53c78fa1b3eb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ea0278567b60befbcb39c8bab85a15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ac7ea0278567b60befbcb39c8bab85a15">ode_midpoint</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*f)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>), <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt; s, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h)</td></tr>
<tr class="memdesc:ac7ea0278567b60befbcb39c8bab85a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate numerically a differential equation in one unknown using the midpoint method.  <a href="namespacetheoretica.html#ac7ea0278567b60befbcb39c8bab85a15">More...</a><br /></td></tr>
<tr class="separator:ac7ea0278567b60befbcb39c8bab85a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1d1c17fc6cb0d6c7920d22e3a01ba2"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a5b1d1c17fc6cb0d6c7920d22e3a01ba2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a5b1d1c17fc6cb0d6c7920d22e3a01ba2">ode_midpoint</a> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;(*f)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;), <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt; s, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h)</td></tr>
<tr class="memdesc:a5b1d1c17fc6cb0d6c7920d22e3a01ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate numerically a differential equation in N unknowns using the midpoint method.  <a href="namespacetheoretica.html#a5b1d1c17fc6cb0d6c7920d22e3a01ba2">More...</a><br /></td></tr>
<tr class="separator:a5b1d1c17fc6cb0d6c7920d22e3a01ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada01c01adb4d24ed0d699dc375821d0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ada01c01adb4d24ed0d699dc375821d0c">ode_heun</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*f)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>), <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt; s, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h)</td></tr>
<tr class="memdesc:ada01c01adb4d24ed0d699dc375821d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate numerically a differential equation in one unknown using Heun's method.  <a href="namespacetheoretica.html#ada01c01adb4d24ed0d699dc375821d0c">More...</a><br /></td></tr>
<tr class="separator:ada01c01adb4d24ed0d699dc375821d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffbc50c378374fca79ddda6cd19fac2"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:acffbc50c378374fca79ddda6cd19fac2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#acffbc50c378374fca79ddda6cd19fac2">ode_heun</a> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;(*f)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;), <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt; s, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h)</td></tr>
<tr class="memdesc:acffbc50c378374fca79ddda6cd19fac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate numerically a differential equation in N unknowns using Heun's method.  <a href="namespacetheoretica.html#acffbc50c378374fca79ddda6cd19fac2">More...</a><br /></td></tr>
<tr class="separator:acffbc50c378374fca79ddda6cd19fac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539a16b5d0d26731a5443e992c3a9631"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a539a16b5d0d26731a5443e992c3a9631">ode_rk2</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*f)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>), <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt; s, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h)</td></tr>
<tr class="memdesc:a539a16b5d0d26731a5443e992c3a9631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate numerically a differential equation in one unknown using Runge-Kutta's method of second order.  <a href="namespacetheoretica.html#a539a16b5d0d26731a5443e992c3a9631">More...</a><br /></td></tr>
<tr class="separator:a539a16b5d0d26731a5443e992c3a9631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d79a2989ae9ffe1f84e3011e6201db0"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a9d79a2989ae9ffe1f84e3011e6201db0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a9d79a2989ae9ffe1f84e3011e6201db0">ode_rk2</a> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;(*f)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;), <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt; s, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h)</td></tr>
<tr class="memdesc:a9d79a2989ae9ffe1f84e3011e6201db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate numerically a differential equation in N unknowns using Runge-Kutta's method of second order.  <a href="namespacetheoretica.html#a9d79a2989ae9ffe1f84e3011e6201db0">More...</a><br /></td></tr>
<tr class="separator:a9d79a2989ae9ffe1f84e3011e6201db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dac900a06e7496e947bdf4764d8ead2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a7dac900a06e7496e947bdf4764d8ead2">ode_rk4</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*f)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>), <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt; s, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h)</td></tr>
<tr class="memdesc:a7dac900a06e7496e947bdf4764d8ead2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate numerically a differential equation in one unknown using Runge-Kutta's method of fourth order.  <a href="namespacetheoretica.html#a7dac900a06e7496e947bdf4764d8ead2">More...</a><br /></td></tr>
<tr class="separator:a7dac900a06e7496e947bdf4764d8ead2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832fa924210cf7bb22186433282c8080"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a832fa924210cf7bb22186433282c8080"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a832fa924210cf7bb22186433282c8080">ode_rk4</a> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;(*f)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;), <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt; s, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h)</td></tr>
<tr class="memdesc:a832fa924210cf7bb22186433282c8080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate numerically a differential equation in N unknowns using Runge-Kutta's method of fourth order.  <a href="namespacetheoretica.html#a832fa924210cf7bb22186433282c8080">More...</a><br /></td></tr>
<tr class="separator:a832fa924210cf7bb22186433282c8080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c7edfdb6e58fbe8b6b3b2c51f75e4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a57c7edfdb6e58fbe8b6b3b2c51f75e4d">ode_k38</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*f)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>), <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt; s, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h)</td></tr>
<tr class="memdesc:a57c7edfdb6e58fbe8b6b3b2c51f75e4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate numerically a differential equation in one unknown using Kutta's 3/8 rule method.  <a href="namespacetheoretica.html#a57c7edfdb6e58fbe8b6b3b2c51f75e4d">More...</a><br /></td></tr>
<tr class="separator:a57c7edfdb6e58fbe8b6b3b2c51f75e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff6c39e5861b2783b0d5adac8a16499"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a0ff6c39e5861b2783b0d5adac8a16499"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a0ff6c39e5861b2783b0d5adac8a16499">ode_k38</a> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;(*f)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;), <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt; s, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h)</td></tr>
<tr class="memdesc:a0ff6c39e5861b2783b0d5adac8a16499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate numerically a differential equation in N unknowns using Kutta's 3/8 rule method.  <a href="namespacetheoretica.html#a0ff6c39e5861b2783b0d5adac8a16499">More...</a><br /></td></tr>
<tr class="separator:a0ff6c39e5861b2783b0d5adac8a16499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1848b188dc6aa193c71f8afb08df90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a7b1848b188dc6aa193c71f8afb08df90">ode_adams</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*f)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>), <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt; s0, <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt; s1, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h)</td></tr>
<tr class="memdesc:a7b1848b188dc6aa193c71f8afb08df90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate numerically a differential equation in N unknowns using the Dormand-Prince method of sixth order.  <a href="namespacetheoretica.html#a7b1848b188dc6aa193c71f8afb08df90">More...</a><br /></td></tr>
<tr class="separator:a7b1848b188dc6aa193c71f8afb08df90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb43d3fba56129243889f79fdbf83728"><td class="memTemplParams" colspan="2"><a id="aeb43d3fba56129243889f79fdbf83728" name="aeb43d3fba56129243889f79fdbf83728"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:aeb43d3fba56129243889f79fdbf83728"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ode_adams</b> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;(*f)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;), <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt; s0, <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt; s1, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h)</td></tr>
<tr class="memdesc:aeb43d3fba56129243889f79fdbf83728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate numerically a differential equation in N unknowns using the Adams-Bashforth linear multistep method of the second order. <br /></td></tr>
<tr class="separator:aeb43d3fba56129243889f79fdbf83728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634268d7a3fbf3e05cd11c8f98ab1421"><td class="memItemLeft" align="right" valign="top"><a id="a634268d7a3fbf3e05cd11c8f98ab1421" name="a634268d7a3fbf3e05cd11c8f98ab1421"></a>
<a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ode_adams3</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*f)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>), <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt; s0, <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt; s1, <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt; s2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h)</td></tr>
<tr class="memdesc:a634268d7a3fbf3e05cd11c8f98ab1421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate numerically a differential equation in 1 unknown using the Adams-Bashforth linear multistep method of third order. <br /></td></tr>
<tr class="separator:a634268d7a3fbf3e05cd11c8f98ab1421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8746a65c6b5bf54a5df9d1506645ef3"><td class="memTemplParams" colspan="2"><a id="ad8746a65c6b5bf54a5df9d1506645ef3" name="ad8746a65c6b5bf54a5df9d1506645ef3"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ad8746a65c6b5bf54a5df9d1506645ef3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ode_adams3</b> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;(*f)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;), <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt; s0, <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt; s1, <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt; s2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h)</td></tr>
<tr class="memdesc:ad8746a65c6b5bf54a5df9d1506645ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate numerically a differential equation in N unknowns using the Adams-Bashforth linear multistep method of third order. <br /></td></tr>
<tr class="separator:ad8746a65c6b5bf54a5df9d1506645ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3901b8b9a442e4b71368650c2ce1ee31"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3901b8b9a442e4b71368650c2ce1ee31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a3901b8b9a442e4b71368650c2ce1ee31">identity</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z)</td></tr>
<tr class="memdesc:a3901b8b9a442e4b71368650c2ce1ee31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex identity.  <a href="namespacetheoretica.html#a3901b8b9a442e4b71368650c2ce1ee31">More...</a><br /></td></tr>
<tr class="separator:a3901b8b9a442e4b71368650c2ce1ee31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4160ef942a7f710c85250f69e65def"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7d4160ef942a7f710c85250f69e65def"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a7d4160ef942a7f710c85250f69e65def">conjugate</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z)</td></tr>
<tr class="memdesc:a7d4160ef942a7f710c85250f69e65def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the conjugate of a complex number.  <a href="namespacetheoretica.html#a7d4160ef942a7f710c85250f69e65def">More...</a><br /></td></tr>
<tr class="separator:a7d4160ef942a7f710c85250f69e65def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9b9fcd589d1358fb90effc83e1fc04"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3e9b9fcd589d1358fb90effc83e1fc04"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a3e9b9fcd589d1358fb90effc83e1fc04">inverse</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z)</td></tr>
<tr class="memdesc:a3e9b9fcd589d1358fb90effc83e1fc04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the conjugate of a complex number.  <a href="namespacetheoretica.html#a3e9b9fcd589d1358fb90effc83e1fc04">More...</a><br /></td></tr>
<tr class="separator:a3e9b9fcd589d1358fb90effc83e1fc04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13ddee06543aa9aa3deb827efd44f63"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af13ddee06543aa9aa3deb827efd44f63"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#af13ddee06543aa9aa3deb827efd44f63">square</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z)</td></tr>
<tr class="memdesc:af13ddee06543aa9aa3deb827efd44f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square of a complex number.  <a href="namespacetheoretica.html#af13ddee06543aa9aa3deb827efd44f63">More...</a><br /></td></tr>
<tr class="separator:af13ddee06543aa9aa3deb827efd44f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc94802c6760bba16d0eaf5795dced7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9cc94802c6760bba16d0eaf5795dced7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a9cc94802c6760bba16d0eaf5795dced7">cube</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z)</td></tr>
<tr class="memdesc:a9cc94802c6760bba16d0eaf5795dced7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cube of a complex number.  <a href="namespacetheoretica.html#a9cc94802c6760bba16d0eaf5795dced7">More...</a><br /></td></tr>
<tr class="separator:a9cc94802c6760bba16d0eaf5795dced7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6500750eaa5ea09bf1a2fa8ca1c1d430"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6500750eaa5ea09bf1a2fa8ca1c1d430"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a6500750eaa5ea09bf1a2fa8ca1c1d430">exp</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z)</td></tr>
<tr class="memdesc:a6500750eaa5ea09bf1a2fa8ca1c1d430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex exponential.  <a href="namespacetheoretica.html#a6500750eaa5ea09bf1a2fa8ca1c1d430">More...</a><br /></td></tr>
<tr class="separator:a6500750eaa5ea09bf1a2fa8ca1c1d430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adefc7e5553fca6b62313bb2a3037e49b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adefc7e5553fca6b62313bb2a3037e49b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#adefc7e5553fca6b62313bb2a3037e49b">abs</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z)</td></tr>
<tr class="memdesc:adefc7e5553fca6b62313bb2a3037e49b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the modulus of a complex number.  <a href="namespacetheoretica.html#adefc7e5553fca6b62313bb2a3037e49b">More...</a><br /></td></tr>
<tr class="separator:adefc7e5553fca6b62313bb2a3037e49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dbb7d4dc0c7a5138e34212ddd8dcda2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2dbb7d4dc0c7a5138e34212ddd8dcda2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a2dbb7d4dc0c7a5138e34212ddd8dcda2">sin</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z)</td></tr>
<tr class="memdesc:a2dbb7d4dc0c7a5138e34212ddd8dcda2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computer the complex sine.  <a href="namespacetheoretica.html#a2dbb7d4dc0c7a5138e34212ddd8dcda2">More...</a><br /></td></tr>
<tr class="separator:a2dbb7d4dc0c7a5138e34212ddd8dcda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133da02105ffbd23a2f6f07c03b219f6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a133da02105ffbd23a2f6f07c03b219f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a133da02105ffbd23a2f6f07c03b219f6">cos</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z)</td></tr>
<tr class="memdesc:a133da02105ffbd23a2f6f07c03b219f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex cosine.  <a href="namespacetheoretica.html#a133da02105ffbd23a2f6f07c03b219f6">More...</a><br /></td></tr>
<tr class="separator:a133da02105ffbd23a2f6f07c03b219f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92971816c6dda74903738b66ff69fb9c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a92971816c6dda74903738b66ff69fb9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a92971816c6dda74903738b66ff69fb9c">tan</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z)</td></tr>
<tr class="memdesc:a92971816c6dda74903738b66ff69fb9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex tangent.  <a href="namespacetheoretica.html#a92971816c6dda74903738b66ff69fb9c">More...</a><br /></td></tr>
<tr class="separator:a92971816c6dda74903738b66ff69fb9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42af84f096a0f9e11fdb72d13990bd52"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a42af84f096a0f9e11fdb72d13990bd52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a42af84f096a0f9e11fdb72d13990bd52">sqrt</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z)</td></tr>
<tr class="memdesc:a42af84f096a0f9e11fdb72d13990bd52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex square root.  <a href="namespacetheoretica.html#a42af84f096a0f9e11fdb72d13990bd52">More...</a><br /></td></tr>
<tr class="separator:a42af84f096a0f9e11fdb72d13990bd52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa4a4d5af15f371b28d87d35b504aae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeaa4a4d5af15f371b28d87d35b504aae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aeaa4a4d5af15f371b28d87d35b504aae">ln</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z)</td></tr>
<tr class="memdesc:aeaa4a4d5af15f371b28d87d35b504aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex logarithm.  <a href="namespacetheoretica.html#aeaa4a4d5af15f371b28d87d35b504aae">More...</a><br /></td></tr>
<tr class="separator:aeaa4a4d5af15f371b28d87d35b504aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af336feea10e3a8928f2d2723578d3704"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af336feea10e3a8928f2d2723578d3704"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#af336feea10e3a8928f2d2723578d3704">asin</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z)</td></tr>
<tr class="memdesc:af336feea10e3a8928f2d2723578d3704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex arcsine.  <a href="namespacetheoretica.html#af336feea10e3a8928f2d2723578d3704">More...</a><br /></td></tr>
<tr class="separator:af336feea10e3a8928f2d2723578d3704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0086a4838097cdade9da3abb896ac14"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab0086a4838097cdade9da3abb896ac14"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ab0086a4838097cdade9da3abb896ac14">acos</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z)</td></tr>
<tr class="memdesc:ab0086a4838097cdade9da3abb896ac14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex arccosine.  <a href="namespacetheoretica.html#ab0086a4838097cdade9da3abb896ac14">More...</a><br /></td></tr>
<tr class="separator:ab0086a4838097cdade9da3abb896ac14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7f72fc6086b22ac864727ac0ee064b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abb7f72fc6086b22ac864727ac0ee064b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#abb7f72fc6086b22ac864727ac0ee064b">atan</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; z)</td></tr>
<tr class="memdesc:abb7f72fc6086b22ac864727ac0ee064b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex arctangent.  <a href="namespacetheoretica.html#abb7f72fc6086b22ac864727ac0ee064b">More...</a><br /></td></tr>
<tr class="separator:abb7f72fc6086b22ac864727ac0ee064b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2b51694a7dd4ded3a140f92366aaed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aca2b51694a7dd4ded3a140f92366aaed">mul_uint128</a> (uint64_t a, uint64_t b, uint64_t &amp;c_low, uint64_t &amp;c_high)</td></tr>
<tr class="memdesc:aca2b51694a7dd4ded3a140f92366aaed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two 64-bit integers and store the result in two 64-bit variables, keeping 128 bits of the result.  <a href="namespacetheoretica.html#aca2b51694a7dd4ded3a140f92366aaed">More...</a><br /></td></tr>
<tr class="separator:aca2b51694a7dd4ded3a140f92366aaed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672dbbc0ea824c71d7ca0dc26b346200"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a672dbbc0ea824c71d7ca0dc26b346200">mix_mum</a> (uint64_t a, uint64_t b)</td></tr>
<tr class="memdesc:a672dbbc0ea824c71d7ca0dc26b346200"><td class="mdescLeft">&#160;</td><td class="mdescRight">MUM bit mixing function, computes the 128-bit product of a and b and the XOR of their high and low 64-bit parts.  <a href="namespacetheoretica.html#a672dbbc0ea824c71d7ca0dc26b346200">More...</a><br /></td></tr>
<tr class="separator:a672dbbc0ea824c71d7ca0dc26b346200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a799e7fb0699a00697e98f1c952493fc9"><td class="memTemplParams" colspan="2">template&lt;typename UnsignedIntType &gt; </td></tr>
<tr class="memitem:a799e7fb0699a00697e98f1c952493fc9"><td class="memTemplItemLeft" align="right" valign="top">UnsignedIntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a799e7fb0699a00697e98f1c952493fc9">bit_rotate</a> (UnsignedIntType x, unsigned int i)</td></tr>
<tr class="memdesc:a799e7fb0699a00697e98f1c952493fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit rotation of unsigned integer types using shifts.  <a href="namespacetheoretica.html#a799e7fb0699a00697e98f1c952493fc9">More...</a><br /></td></tr>
<tr class="separator:a799e7fb0699a00697e98f1c952493fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8fa10e568fa3bfb88cd0f5449b94f0"><td class="memTemplParams" colspan="2"><a id="afe8fa10e568fa3bfb88cd0f5449b94f0" name="afe8fa10e568fa3bfb88cd0f5449b94f0"></a>
template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:afe8fa10e568fa3bfb88cd0f5449b94f0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>product</b> (const Vector &amp;X)</td></tr>
<tr class="memdesc:afe8fa10e568fa3bfb88cd0f5449b94f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product of a set of values. <br /></td></tr>
<tr class="separator:afe8fa10e568fa3bfb88cd0f5449b94f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8298cbf34bf300bc2c84d14264484ffd"><td class="memTemplParams" colspan="2"><a id="a8298cbf34bf300bc2c84d14264484ffd" name="a8298cbf34bf300bc2c84d14264484ffd"></a>
template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a8298cbf34bf300bc2c84d14264484ffd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>product_sum</b> (const Vector &amp;X, const Vector &amp;Y)</td></tr>
<tr class="memdesc:a8298cbf34bf300bc2c84d14264484ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum the products of two sets of values. <br /></td></tr>
<tr class="separator:a8298cbf34bf300bc2c84d14264484ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8799cd7d7645f496d0d2c9683688050b"><td class="memTemplParams" colspan="2"><a id="a8799cd7d7645f496d0d2c9683688050b" name="a8799cd7d7645f496d0d2c9683688050b"></a>
template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a8799cd7d7645f496d0d2c9683688050b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>product_sum_squares</b> (const Vector &amp;X, const Vector &amp;Y)</td></tr>
<tr class="memdesc:a8799cd7d7645f496d0d2c9683688050b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum the products of the squares of two sets of data. <br /></td></tr>
<tr class="separator:a8799cd7d7645f496d0d2c9683688050b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf60e1fdc60411ae615b952b7248b093"><td class="memTemplParams" colspan="2"><a id="abf60e1fdc60411ae615b952b7248b093" name="abf60e1fdc60411ae615b952b7248b093"></a>
template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:abf60e1fdc60411ae615b952b7248b093"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>product_sum</b> (const Vector &amp;X, const Vector &amp;Y, const Vector &amp;Z)</td></tr>
<tr class="memdesc:abf60e1fdc60411ae615b952b7248b093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum the products of three sets of values. <br /></td></tr>
<tr class="separator:abf60e1fdc60411ae615b952b7248b093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14178d5680aaca3da91f2f0dc8a86d4"><td class="memTemplParams" colspan="2"><a id="aa14178d5680aaca3da91f2f0dc8a86d4" name="aa14178d5680aaca3da91f2f0dc8a86d4"></a>
template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:aa14178d5680aaca3da91f2f0dc8a86d4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>quotient_sum</b> (const Vector &amp;X, const Vector &amp;Y)</td></tr>
<tr class="memdesc:aa14178d5680aaca3da91f2f0dc8a86d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum the quotients of two sets of values. <br /></td></tr>
<tr class="separator:aa14178d5680aaca3da91f2f0dc8a86d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4e70500501fc48d6ad18f8abfc1896"><td class="memTemplParams" colspan="2"><a id="aec4e70500501fc48d6ad18f8abfc1896" name="aec4e70500501fc48d6ad18f8abfc1896"></a>
template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:aec4e70500501fc48d6ad18f8abfc1896"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sum_squares</b> (const Vector &amp;X)</td></tr>
<tr class="memdesc:aec4e70500501fc48d6ad18f8abfc1896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum the squares of a set of values. <br /></td></tr>
<tr class="separator:aec4e70500501fc48d6ad18f8abfc1896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173a64c4f73cb7abd476b739005d94e7"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a173a64c4f73cb7abd476b739005d94e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a173a64c4f73cb7abd476b739005d94e7">sum_compensated</a> (const Vector &amp;X)</td></tr>
<tr class="memdesc:a173a64c4f73cb7abd476b739005d94e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sum of a set of values using the compensated Neumaier-Kahan-Babushka summation algorithm to reduce round-off error.  <a href="namespacetheoretica.html#a173a64c4f73cb7abd476b739005d94e7">More...</a><br /></td></tr>
<tr class="separator:a173a64c4f73cb7abd476b739005d94e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a97cfad96b9bb73d76b8f5cc20f2896"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a2a97cfad96b9bb73d76b8f5cc20f2896"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a2a97cfad96b9bb73d76b8f5cc20f2896">sum_pairwise</a> (const Vector &amp;X, size_t begin=0, size_t end=0, size_t base_size=128)</td></tr>
<tr class="memdesc:a2a97cfad96b9bb73d76b8f5cc20f2896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sum of a set of values using pairwise summation to reduce round-off error.  <a href="namespacetheoretica.html#a2a97cfad96b9bb73d76b8f5cc20f2896">More...</a><br /></td></tr>
<tr class="separator:a2a97cfad96b9bb73d76b8f5cc20f2896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20960b2923a0c3c41b4db5452fa1dbf3"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a20960b2923a0c3c41b4db5452fa1dbf3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a20960b2923a0c3c41b4db5452fa1dbf3">sum</a> (const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;X)</td></tr>
<tr class="memdesc:a20960b2923a0c3c41b4db5452fa1dbf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sum of a vector of real values using pairwise summation to reduce round-off error.  <a href="namespacetheoretica.html#a20960b2923a0c3c41b4db5452fa1dbf3">More...</a><br /></td></tr>
<tr class="separator:a20960b2923a0c3c41b4db5452fa1dbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79e89f4decc976f7538fd4f5683d963"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ae79e89f4decc976f7538fd4f5683d963">sum</a> (const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;X)</td></tr>
<tr class="memdesc:ae79e89f4decc976f7538fd4f5683d963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sum of a vector of real values using pairwise summation to reduce round-off error.  <a href="namespacetheoretica.html#ae79e89f4decc976f7538fd4f5683d963">More...</a><br /></td></tr>
<tr class="separator:ae79e89f4decc976f7538fd4f5683d963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3305c4f7617c88a3e8ee4deb5b7ef0"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:aec3305c4f7617c88a3e8ee4deb5b7ef0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aec3305c4f7617c88a3e8ee4deb5b7ef0">sum</a> (const Vector &amp;X)</td></tr>
<tr class="memdesc:aec3305c4f7617c88a3e8ee4deb5b7ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sum of a set of values.  <a href="namespacetheoretica.html#aec3305c4f7617c88a3e8ee4deb5b7ef0">More...</a><br /></td></tr>
<tr class="separator:aec3305c4f7617c88a3e8ee4deb5b7ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a76a59d0419eb65ee9d89e7bd6c1db"><td class="memTemplParams" colspan="2"><a id="ac0a76a59d0419eb65ee9d89e7bd6c1db" name="ac0a76a59d0419eb65ee9d89e7bd6c1db"></a>
template&lt;typename Vector , typename Function &gt; </td></tr>
<tr class="memitem:ac0a76a59d0419eb65ee9d89e7bd6c1db"><td class="memTemplItemLeft" align="right" valign="top">Vector &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply</b> (Function f, Vector &amp;X)</td></tr>
<tr class="memdesc:ac0a76a59d0419eb65ee9d89e7bd6c1db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function to a set of values element-wise (vectorized evaluation). <br /></td></tr>
<tr class="separator:ac0a76a59d0419eb65ee9d89e7bd6c1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b898a8449d723a807854f805f8be23e"><td class="memTemplParams" colspan="2"><a id="a1b898a8449d723a807854f805f8be23e" name="a1b898a8449d723a807854f805f8be23e"></a>
template&lt;typename Vector1 , typename Vector2  = Vector1, typename Function &gt; </td></tr>
<tr class="memitem:a1b898a8449d723a807854f805f8be23e"><td class="memTemplItemLeft" align="right" valign="top">Vector2 &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map</b> (Function f, const Vector1 &amp;src, Vector2 &amp;dest)</td></tr>
<tr class="memdesc:a1b898a8449d723a807854f805f8be23e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a new vector obtained by applying the function element-wise (vectorized evaluation). <br /></td></tr>
<tr class="separator:a1b898a8449d723a807854f805f8be23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5113ceec31eaa10956e860523f7a18a"><td class="memTemplParams" colspan="2"><a id="ab5113ceec31eaa10956e860523f7a18a" name="ab5113ceec31eaa10956e860523f7a18a"></a>
template&lt;typename Vector1 , typename Vector2  = Vector1, typename Function &gt; </td></tr>
<tr class="memitem:ab5113ceec31eaa10956e860523f7a18a"><td class="memTemplItemLeft" align="right" valign="top">Vector1&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map</b> (Function f, const Vector1 &amp;X)</td></tr>
<tr class="memdesc:ab5113ceec31eaa10956e860523f7a18a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a new vector obtained by applying the function element-wise (vectorized evaluation). <br /></td></tr>
<tr class="separator:ab5113ceec31eaa10956e860523f7a18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a85d4034e2edc73c0175f1d3b6d1382"><td class="memTemplParams" colspan="2"><a id="a1a85d4034e2edc73c0175f1d3b6d1382" name="a1a85d4034e2edc73c0175f1d3b6d1382"></a>
template&lt;typename Vector1 , typename Vector2 , typename Vector3  = Vector1&gt; </td></tr>
<tr class="memitem:a1a85d4034e2edc73c0175f1d3b6d1382"><td class="memTemplItemLeft" align="right" valign="top">Vector3&#160;</td><td class="memTemplItemRight" valign="bottom"><b>concatenate</b> (const Vector1 &amp;v1, const Vector2 &amp;v2)</td></tr>
<tr class="memdesc:a1a85d4034e2edc73c0175f1d3b6d1382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two datasets to form a single one. <br /></td></tr>
<tr class="separator:a1a85d4034e2edc73c0175f1d3b6d1382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c3cffe1db6b2cb178d41bfc98b1c41"><td class="memTemplParams" colspan="2"><a id="a79c3cffe1db6b2cb178d41bfc98b1c41" name="a79c3cffe1db6b2cb178d41bfc98b1c41"></a>
template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a79c3cffe1db6b2cb178d41bfc98b1c41"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>max</b> (const Vector &amp;X)</td></tr>
<tr class="memdesc:a79c3cffe1db6b2cb178d41bfc98b1c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the maximum value inside a dataset. <br /></td></tr>
<tr class="separator:a79c3cffe1db6b2cb178d41bfc98b1c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133ae02c952df7352cfb3830a1616bc1"><td class="memTemplParams" colspan="2"><a id="a133ae02c952df7352cfb3830a1616bc1" name="a133ae02c952df7352cfb3830a1616bc1"></a>
template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a133ae02c952df7352cfb3830a1616bc1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>min</b> (const Vector &amp;X)</td></tr>
<tr class="memdesc:a133ae02c952df7352cfb3830a1616bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the minimum value inside a dataset. <br /></td></tr>
<tr class="separator:a133ae02c952df7352cfb3830a1616bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710c25d508e9e9ae9ed4e734fe4cd6f9"><td class="memItemLeft" align="right" valign="top"><a id="a710c25d508e9e9ae9ed4e734fe4cd6f9" name="a710c25d508e9e9ae9ed4e734fe4cd6f9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>th_errcode_to_errno</b> (<a class="el" href="namespacetheoretica.html#a47d8f770edb576685f4b8752f2eb9760">MATH_ERRCODE</a> err)</td></tr>
<tr class="memdesc:a710c25d508e9e9ae9ed4e734fe4cd6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a MATH_ERRCODE to errno error codes. <br /></td></tr>
<tr class="separator:a710c25d508e9e9ae9ed4e734fe4cd6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95680d1669eee1549fe112b9a846519"><td class="memItemLeft" align="right" valign="top"><a id="ae95680d1669eee1549fe112b9a846519" name="ae95680d1669eee1549fe112b9a846519"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>nan</b> ()</td></tr>
<tr class="memdesc:ae95680d1669eee1549fe112b9a846519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a quiet NaN number in floating point representation. <br /></td></tr>
<tr class="separator:ae95680d1669eee1549fe112b9a846519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e311a811c0c7e23c30e4496cfbe63d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a22e311a811c0c7e23c30e4496cfbe63d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a22e311a811c0c7e23c30e4496cfbe63d">is_nan</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a22e311a811c0c7e23c30e4496cfbe63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a generic variable is (equivalent to) a NaN number.  <a href="namespacetheoretica.html#a22e311a811c0c7e23c30e4496cfbe63d">More...</a><br /></td></tr>
<tr class="separator:a22e311a811c0c7e23c30e4496cfbe63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252ec9220e4dab52b18b400381624538"><td class="memItemLeft" align="right" valign="top"><a id="a252ec9220e4dab52b18b400381624538" name="a252ec9220e4dab52b18b400381624538"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>inf</b> ()</td></tr>
<tr class="memdesc:a252ec9220e4dab52b18b400381624538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return positive infinity in floating point representation. <br /></td></tr>
<tr class="separator:a252ec9220e4dab52b18b400381624538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e3b9080dde2e7542682cf79f0bbf50"><td class="memItemLeft" align="right" valign="top"><a id="ac8e3b9080dde2e7542682cf79f0bbf50" name="ac8e3b9080dde2e7542682cf79f0bbf50"></a>
<a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>identity</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:ac8e3b9080dde2e7542682cf79f0bbf50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identity. <br /></td></tr>
<tr class="separator:ac8e3b9080dde2e7542682cf79f0bbf50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cae4ecd47fdcd7dea25fa5ce03647cd"><td class="memItemLeft" align="right" valign="top"><a id="a6cae4ecd47fdcd7dea25fa5ce03647cd" name="a6cae4ecd47fdcd7dea25fa5ce03647cd"></a>
<a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>conjugate</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a6cae4ecd47fdcd7dea25fa5ce03647cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex conjugate of a real number (identity) <br /></td></tr>
<tr class="separator:a6cae4ecd47fdcd7dea25fa5ce03647cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726a5e18c863dc41040f5df134553fa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a726a5e18c863dc41040f5df134553fa9">square</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a726a5e18c863dc41040f5df134553fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square of a real number.  <a href="namespacetheoretica.html#a726a5e18c863dc41040f5df134553fa9">More...</a><br /></td></tr>
<tr class="separator:a726a5e18c863dc41040f5df134553fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bfa8d12242c241b6f56cebc9cdc60ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a6bfa8d12242c241b6f56cebc9cdc60ed">cube</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a6bfa8d12242c241b6f56cebc9cdc60ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cube of a real number.  <a href="namespacetheoretica.html#a6bfa8d12242c241b6f56cebc9cdc60ed">More...</a><br /></td></tr>
<tr class="separator:a6bfa8d12242c241b6f56cebc9cdc60ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68914a563241494dfe7ac42f0462920c"><td class="memTemplParams" colspan="2">template&lt;typename UnsignedIntType  = uint64_t&gt; </td></tr>
<tr class="memitem:a68914a563241494dfe7ac42f0462920c"><td class="memTemplItemLeft" align="right" valign="top">UnsignedIntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a68914a563241494dfe7ac42f0462920c">isqrt</a> (UnsignedIntType n)</td></tr>
<tr class="memdesc:a68914a563241494dfe7ac42f0462920c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the integer square root of a positive integer.  <a href="namespacetheoretica.html#a68914a563241494dfe7ac42f0462920c">More...</a><br /></td></tr>
<tr class="separator:a68914a563241494dfe7ac42f0462920c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad830de3729f8f2bea38d60ef706cf968"><td class="memTemplParams" colspan="2">template&lt;typename UnsignedIntType  = uint64_t&gt; </td></tr>
<tr class="memitem:ad830de3729f8f2bea38d60ef706cf968"><td class="memTemplItemLeft" align="right" valign="top">UnsignedIntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ad830de3729f8f2bea38d60ef706cf968">icbrt</a> (UnsignedIntType n)</td></tr>
<tr class="memdesc:ad830de3729f8f2bea38d60ef706cf968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the integer cubic root of a positive integer.  <a href="namespacetheoretica.html#ad830de3729f8f2bea38d60ef706cf968">More...</a><br /></td></tr>
<tr class="separator:ad830de3729f8f2bea38d60ef706cf968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e4cf02f9bcb4caf5371ee05d67df8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa2e4cf02f9bcb4caf5371ee05d67df8d">sqrt</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:aa2e4cf02f9bcb4caf5371ee05d67df8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square root of a real number.  <a href="namespacetheoretica.html#aa2e4cf02f9bcb4caf5371ee05d67df8d">More...</a><br /></td></tr>
<tr class="separator:aa2e4cf02f9bcb4caf5371ee05d67df8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c3b797f94ec5bc22b4c22f85417c93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a61c3b797f94ec5bc22b4c22f85417c93">cbrt</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a61c3b797f94ec5bc22b4c22f85417c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cubic root of x.  <a href="namespacetheoretica.html#a61c3b797f94ec5bc22b4c22f85417c93">More...</a><br /></td></tr>
<tr class="separator:a61c3b797f94ec5bc22b4c22f85417c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5177ff64d981840e149d1e282f1b27e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa5177ff64d981840e149d1e282f1b27e">abs</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:aa5177ff64d981840e149d1e282f1b27e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the absolute value of a real number.  <a href="namespacetheoretica.html#aa5177ff64d981840e149d1e282f1b27e">More...</a><br /></td></tr>
<tr class="separator:aa5177ff64d981840e149d1e282f1b27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61e39abd4fd4cd8cd83add5d0752e2f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ad61e39abd4fd4cd8cd83add5d0752e2f">sgn</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:ad61e39abd4fd4cd8cd83add5d0752e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sign of x (1 if positive, -1 if negative, 0 if null)  <a href="namespacetheoretica.html#ad61e39abd4fd4cd8cd83add5d0752e2f">More...</a><br /></td></tr>
<tr class="separator:ad61e39abd4fd4cd8cd83add5d0752e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad5c92586d6a0f841bfcd3759eff317"><td class="memItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#afad5c92586d6a0f841bfcd3759eff317">floor</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:afad5c92586d6a0f841bfcd3759eff317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the floor of x Computes the maximum integer number that is smaller than x.  <a href="namespacetheoretica.html#afad5c92586d6a0f841bfcd3759eff317">More...</a><br /></td></tr>
<tr class="separator:afad5c92586d6a0f841bfcd3759eff317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d079c3d95f2bc80c4619d13ff7263a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a85d079c3d95f2bc80c4619d13ff7263a">fract</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a85d079c3d95f2bc80c4619d13ff7263a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the fractional part of a real number.  <a href="namespacetheoretica.html#a85d079c3d95f2bc80c4619d13ff7263a">More...</a><br /></td></tr>
<tr class="separator:a85d079c3d95f2bc80c4619d13ff7263a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07569756dda099ecabf425371da6a31d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a07569756dda099ecabf425371da6a31d">max</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> y)</td></tr>
<tr class="memdesc:a07569756dda099ecabf425371da6a31d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the greatest number between two real numbers.  <a href="namespacetheoretica.html#a07569756dda099ecabf425371da6a31d">More...</a><br /></td></tr>
<tr class="separator:a07569756dda099ecabf425371da6a31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e295404d1712fb17851fe105715766e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5e295404d1712fb17851fe105715766e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a5e295404d1712fb17851fe105715766e">max</a> (T x, T y)</td></tr>
<tr class="memdesc:a5e295404d1712fb17851fe105715766e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two objects and return the greatest.  <a href="namespacetheoretica.html#a5e295404d1712fb17851fe105715766e">More...</a><br /></td></tr>
<tr class="separator:a5e295404d1712fb17851fe105715766e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac673920f8956ebea402eac4271f551ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ac673920f8956ebea402eac4271f551ba">min</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> y)</td></tr>
<tr class="memdesc:ac673920f8956ebea402eac4271f551ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the smallest number between two real numbers.  <a href="namespacetheoretica.html#ac673920f8956ebea402eac4271f551ba">More...</a><br /></td></tr>
<tr class="separator:ac673920f8956ebea402eac4271f551ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f4122359c1f32ba0741d098a5fbe69"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a70f4122359c1f32ba0741d098a5fbe69"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a70f4122359c1f32ba0741d098a5fbe69">min</a> (T x, T y)</td></tr>
<tr class="memdesc:a70f4122359c1f32ba0741d098a5fbe69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two objects and return the greatest.  <a href="namespacetheoretica.html#a70f4122359c1f32ba0741d098a5fbe69">More...</a><br /></td></tr>
<tr class="separator:a70f4122359c1f32ba0741d098a5fbe69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a4ad4c5446986fe2d255a03be337a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#af1a4ad4c5446986fe2d255a03be337a1">clamp</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b)</td></tr>
<tr class="memdesc:af1a4ad4c5446986fe2d255a03be337a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamp x between a and b.  <a href="namespacetheoretica.html#af1a4ad4c5446986fe2d255a03be337a1">More...</a><br /></td></tr>
<tr class="separator:af1a4ad4c5446986fe2d255a03be337a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf4d125306e3fffc7287aa42f9005a1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acdf4d125306e3fffc7287aa42f9005a1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#acdf4d125306e3fffc7287aa42f9005a1">clamp</a> (T x, T a, T b)</td></tr>
<tr class="memdesc:acdf4d125306e3fffc7287aa42f9005a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamp a value between two other values.  <a href="namespacetheoretica.html#acdf4d125306e3fffc7287aa42f9005a1">More...</a><br /></td></tr>
<tr class="separator:acdf4d125306e3fffc7287aa42f9005a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd0ef7aa0b136fbd1b4579cec14f369"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#abbd0ef7aa0b136fbd1b4579cec14f369">log2</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:abbd0ef7aa0b136fbd1b4579cec14f369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the binary logarithm of a real number.  <a href="namespacetheoretica.html#abbd0ef7aa0b136fbd1b4579cec14f369">More...</a><br /></td></tr>
<tr class="separator:abbd0ef7aa0b136fbd1b4579cec14f369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb04217fd0bd9dd23daaa186d3756d1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#adb04217fd0bd9dd23daaa186d3756d1e">log10</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:adb04217fd0bd9dd23daaa186d3756d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the base-10 logarithm of x.  <a href="namespacetheoretica.html#adb04217fd0bd9dd23daaa186d3756d1e">More...</a><br /></td></tr>
<tr class="separator:adb04217fd0bd9dd23daaa186d3756d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748eca731a8c05226332e5723b7a9d91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a748eca731a8c05226332e5723b7a9d91">ln</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a748eca731a8c05226332e5723b7a9d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of x.  <a href="namespacetheoretica.html#a748eca731a8c05226332e5723b7a9d91">More...</a><br /></td></tr>
<tr class="separator:a748eca731a8c05226332e5723b7a9d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50cd5107369678c27b30dbae079283c5"><td class="memTemplParams" colspan="2">template&lt;typename UnsignedIntType  = uint64_t&gt; </td></tr>
<tr class="memitem:a50cd5107369678c27b30dbae079283c5"><td class="memTemplItemLeft" align="right" valign="top">UnsignedIntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a50cd5107369678c27b30dbae079283c5">ilog2</a> (UnsignedIntType x)</td></tr>
<tr class="memdesc:a50cd5107369678c27b30dbae079283c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the integer logarithm of x.  <a href="namespacetheoretica.html#a50cd5107369678c27b30dbae079283c5">More...</a><br /></td></tr>
<tr class="separator:a50cd5107369678c27b30dbae079283c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9628d333f307cc0dfe8578f29146615"><td class="memTemplParams" colspan="2">template&lt;typename UnsignedIntType  = uint64_t&gt; </td></tr>
<tr class="memitem:aa9628d333f307cc0dfe8578f29146615"><td class="memTemplItemLeft" align="right" valign="top">UnsignedIntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa9628d333f307cc0dfe8578f29146615">pad2</a> (UnsignedIntType x)</td></tr>
<tr class="memdesc:aa9628d333f307cc0dfe8578f29146615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the smallest power 2 bigger or equal to x.  <a href="namespacetheoretica.html#aa9628d333f307cc0dfe8578f29146615">More...</a><br /></td></tr>
<tr class="separator:aa9628d333f307cc0dfe8578f29146615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13248f2e439afdb6f72e0f2c1e79cc55"><td class="memTemplParams" colspan="2">template&lt;typename T  = real&gt; </td></tr>
<tr class="memitem:a13248f2e439afdb6f72e0f2c1e79cc55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a13248f2e439afdb6f72e0f2c1e79cc55">pow</a> (T x, int n)</td></tr>
<tr class="memdesc:a13248f2e439afdb6f72e0f2c1e79cc55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the n-th power of x (where n is natural)  <a href="namespacetheoretica.html#a13248f2e439afdb6f72e0f2c1e79cc55">More...</a><br /></td></tr>
<tr class="separator:a13248f2e439afdb6f72e0f2c1e79cc55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e31c328bc34c0d2fca2aad3bf78ca7"><td class="memTemplParams" colspan="2">template&lt;typename T  = real&gt; </td></tr>
<tr class="memitem:a52e31c328bc34c0d2fca2aad3bf78ca7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a52e31c328bc34c0d2fca2aad3bf78ca7">ipow</a> (T x, unsigned int n, T neutral_element=T(1))</td></tr>
<tr class="memdesc:a52e31c328bc34c0d2fca2aad3bf78ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the n-th positive power of x (where n is natural)  <a href="namespacetheoretica.html#a52e31c328bc34c0d2fca2aad3bf78ca7">More...</a><br /></td></tr>
<tr class="separator:a52e31c328bc34c0d2fca2aad3bf78ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5b285f294e32d7e2a601152d67b4b2"><td class="memTemplParams" colspan="2"><a id="a8b5b285f294e32d7e2a601152d67b4b2" name="a8b5b285f294e32d7e2a601152d67b4b2"></a>
template&lt;typename IntType  = uint64_t&gt; </td></tr>
<tr class="memitem:a8b5b285f294e32d7e2a601152d67b4b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fact</b> (unsigned int n)</td></tr>
<tr class="memdesc:a8b5b285f294e32d7e2a601152d67b4b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the factorial of n. <br /></td></tr>
<tr class="separator:a8b5b285f294e32d7e2a601152d67b4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb032626b2f25bf5c31026c1ee6e639d"><td class="memTemplParams" colspan="2"><a id="adb032626b2f25bf5c31026c1ee6e639d" name="adb032626b2f25bf5c31026c1ee6e639d"></a>
template&lt;typename T  = uint64_t&gt; </td></tr>
<tr class="memitem:adb032626b2f25bf5c31026c1ee6e639d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>falling_fact</b> (T x, unsigned int n)</td></tr>
<tr class="memdesc:adb032626b2f25bf5c31026c1ee6e639d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the falling factorial of n. <br /></td></tr>
<tr class="separator:adb032626b2f25bf5c31026c1ee6e639d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd4867609a302e1846b9cbdb83f629f"><td class="memTemplParams" colspan="2"><a id="a1dd4867609a302e1846b9cbdb83f629f" name="a1dd4867609a302e1846b9cbdb83f629f"></a>
template&lt;typename T  = uint64_t&gt; </td></tr>
<tr class="memitem:a1dd4867609a302e1846b9cbdb83f629f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rising_fact</b> (T x, unsigned int n)</td></tr>
<tr class="memdesc:a1dd4867609a302e1846b9cbdb83f629f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the rising factorial of n. <br /></td></tr>
<tr class="separator:a1dd4867609a302e1846b9cbdb83f629f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a0989004608c56e6dd4bcc2bd148c7"><td class="memTemplParams" colspan="2"><a id="a56a0989004608c56e6dd4bcc2bd148c7" name="a56a0989004608c56e6dd4bcc2bd148c7"></a>
template&lt;typename IntType  = unsigned long long int&gt; </td></tr>
<tr class="memitem:a56a0989004608c56e6dd4bcc2bd148c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><b>double_fact</b> (unsigned int n)</td></tr>
<tr class="memdesc:a56a0989004608c56e6dd4bcc2bd148c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the double factorial of n. <br /></td></tr>
<tr class="separator:a56a0989004608c56e6dd4bcc2bd148c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61f8810fcedeaa35f54c834e934828e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ac61f8810fcedeaa35f54c834e934828e">exp</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:ac61f8810fcedeaa35f54c834e934828e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the real exponential.  <a href="namespacetheoretica.html#ac61f8810fcedeaa35f54c834e934828e">More...</a><br /></td></tr>
<tr class="separator:ac61f8810fcedeaa35f54c834e934828e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57235e0b29cc687c5084e5f0aa2515c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ae57235e0b29cc687c5084e5f0aa2515c">expm1</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:ae57235e0b29cc687c5084e5f0aa2515c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the exponential of x minus 1 more accurately for really small x.  <a href="namespacetheoretica.html#ae57235e0b29cc687c5084e5f0aa2515c">More...</a><br /></td></tr>
<tr class="separator:ae57235e0b29cc687c5084e5f0aa2515c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f12dd8e0fc650fa75c9961e51d1406c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a6f12dd8e0fc650fa75c9961e51d1406c">powf</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a)</td></tr>
<tr class="memdesc:a6f12dd8e0fc650fa75c9961e51d1406c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate x elevated to a real exponent.  <a href="namespacetheoretica.html#a6f12dd8e0fc650fa75c9961e51d1406c">More...</a><br /></td></tr>
<tr class="separator:a6f12dd8e0fc650fa75c9961e51d1406c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf52f04c3a1cefbb9dabab21cac0abbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#acf52f04c3a1cefbb9dabab21cac0abbb">root</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, int n)</td></tr>
<tr class="memdesc:acf52f04c3a1cefbb9dabab21cac0abbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the n-th root of x.  <a href="namespacetheoretica.html#acf52f04c3a1cefbb9dabab21cac0abbb">More...</a><br /></td></tr>
<tr class="separator:acf52f04c3a1cefbb9dabab21cac0abbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2ea0b1258dfe34df321901707d1808"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a2c2ea0b1258dfe34df321901707d1808">sin</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a2c2ea0b1258dfe34df321901707d1808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sine of a real number.  <a href="namespacetheoretica.html#a2c2ea0b1258dfe34df321901707d1808">More...</a><br /></td></tr>
<tr class="separator:a2c2ea0b1258dfe34df321901707d1808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af684d7159e22012dc5229c31eb66fceb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#af684d7159e22012dc5229c31eb66fceb">cos</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:af684d7159e22012dc5229c31eb66fceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cosine of a real number.  <a href="namespacetheoretica.html#af684d7159e22012dc5229c31eb66fceb">More...</a><br /></td></tr>
<tr class="separator:af684d7159e22012dc5229c31eb66fceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9d9a32dc2c9f00de35c1b1a49b218e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#abe9d9a32dc2c9f00de35c1b1a49b218e">tan</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:abe9d9a32dc2c9f00de35c1b1a49b218e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the tangent of x.  <a href="namespacetheoretica.html#abe9d9a32dc2c9f00de35c1b1a49b218e">More...</a><br /></td></tr>
<tr class="separator:abe9d9a32dc2c9f00de35c1b1a49b218e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6f43e74456bea35fb757f17db47da8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aec6f43e74456bea35fb757f17db47da8">cot</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:aec6f43e74456bea35fb757f17db47da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cotangent of x.  <a href="namespacetheoretica.html#aec6f43e74456bea35fb757f17db47da8">More...</a><br /></td></tr>
<tr class="separator:aec6f43e74456bea35fb757f17db47da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426b70abe4783e75806e1ae8c9e9e2bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a426b70abe4783e75806e1ae8c9e9e2bd">atan</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a426b70abe4783e75806e1ae8c9e9e2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arctangent.  <a href="namespacetheoretica.html#a426b70abe4783e75806e1ae8c9e9e2bd">More...</a><br /></td></tr>
<tr class="separator:a426b70abe4783e75806e1ae8c9e9e2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b06e5bf997c4447c10f2fa96649347"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a79b06e5bf997c4447c10f2fa96649347">asin</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a79b06e5bf997c4447c10f2fa96649347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arcsine.  <a href="namespacetheoretica.html#a79b06e5bf997c4447c10f2fa96649347">More...</a><br /></td></tr>
<tr class="separator:a79b06e5bf997c4447c10f2fa96649347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2d69e3a3387958a27d4a03ed478a99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a7f2d69e3a3387958a27d4a03ed478a99">acos</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a7f2d69e3a3387958a27d4a03ed478a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arccosine.  <a href="namespacetheoretica.html#a7f2d69e3a3387958a27d4a03ed478a99">More...</a><br /></td></tr>
<tr class="separator:a7f2d69e3a3387958a27d4a03ed478a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae6ab14a39d6132b6858934dadaaf3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a6ae6ab14a39d6132b6858934dadaaf3e">atan2</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> y, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a6ae6ab14a39d6132b6858934dadaaf3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 2 argument arctangent.  <a href="namespacetheoretica.html#a6ae6ab14a39d6132b6858934dadaaf3e">More...</a><br /></td></tr>
<tr class="separator:a6ae6ab14a39d6132b6858934dadaaf3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0650ea8e1435cc518e960bfcecf5b66e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a0650ea8e1435cc518e960bfcecf5b66e">sinh</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a0650ea8e1435cc518e960bfcecf5b66e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic sine.  <a href="namespacetheoretica.html#a0650ea8e1435cc518e960bfcecf5b66e">More...</a><br /></td></tr>
<tr class="separator:a0650ea8e1435cc518e960bfcecf5b66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fc03cbb1de8180e51183bb82c0bb28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a12fc03cbb1de8180e51183bb82c0bb28">cosh</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a12fc03cbb1de8180e51183bb82c0bb28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic cosine.  <a href="namespacetheoretica.html#a12fc03cbb1de8180e51183bb82c0bb28">More...</a><br /></td></tr>
<tr class="separator:a12fc03cbb1de8180e51183bb82c0bb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6b8fc4bb2609507cd1fae0f7d6c8a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aaf6b8fc4bb2609507cd1fae0f7d6c8a7">tanh</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:aaf6b8fc4bb2609507cd1fae0f7d6c8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic tangent.  <a href="namespacetheoretica.html#aaf6b8fc4bb2609507cd1fae0f7d6c8a7">More...</a><br /></td></tr>
<tr class="separator:aaf6b8fc4bb2609507cd1fae0f7d6c8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f957ad9b2354268f56ab1ca3843080"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a96f957ad9b2354268f56ab1ca3843080">coth</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a96f957ad9b2354268f56ab1ca3843080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic cotangent.  <a href="namespacetheoretica.html#a96f957ad9b2354268f56ab1ca3843080">More...</a><br /></td></tr>
<tr class="separator:a96f957ad9b2354268f56ab1ca3843080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c497fcd02e23df8fa0f197922c4e2c"><td class="memItemLeft" align="right" valign="top"><a id="a54c497fcd02e23df8fa0f197922c4e2c" name="a54c497fcd02e23df8fa0f197922c4e2c"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>asinh</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a54c497fcd02e23df8fa0f197922c4e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inverse hyperbolic sine. <br /></td></tr>
<tr class="separator:a54c497fcd02e23df8fa0f197922c4e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124297369ecba10c8516dc5a920aad1a"><td class="memItemLeft" align="right" valign="top"><a id="a124297369ecba10c8516dc5a920aad1a" name="a124297369ecba10c8516dc5a920aad1a"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>acosh</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a124297369ecba10c8516dc5a920aad1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inverse hyperbolic cosine. <br /></td></tr>
<tr class="separator:a124297369ecba10c8516dc5a920aad1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85064afd88800f3129e97d2e2955be4"><td class="memItemLeft" align="right" valign="top"><a id="ab85064afd88800f3129e97d2e2955be4" name="ab85064afd88800f3129e97d2e2955be4"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>atanh</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:ab85064afd88800f3129e97d2e2955be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inverse hyperbolic tangent. <br /></td></tr>
<tr class="separator:ab85064afd88800f3129e97d2e2955be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a76685197faa15403e24b836830cf5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a7a76685197faa15403e24b836830cf5d">sigmoid</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a7a76685197faa15403e24b836830cf5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sigmoid function.  <a href="namespacetheoretica.html#a7a76685197faa15403e24b836830cf5d">More...</a><br /></td></tr>
<tr class="separator:a7a76685197faa15403e24b836830cf5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1efe3bd7ff87719aab92b67cec535096"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a1efe3bd7ff87719aab92b67cec535096">sinc</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a1efe3bd7ff87719aab92b67cec535096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the normalized sinc function.  <a href="namespacetheoretica.html#a1efe3bd7ff87719aab92b67cec535096">More...</a><br /></td></tr>
<tr class="separator:a1efe3bd7ff87719aab92b67cec535096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024554cae44fb42700e8f68d235f0f15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a024554cae44fb42700e8f68d235f0f15">heaviside</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a024554cae44fb42700e8f68d235f0f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the heaviside function.  <a href="namespacetheoretica.html#a024554cae44fb42700e8f68d235f0f15">More...</a><br /></td></tr>
<tr class="separator:a024554cae44fb42700e8f68d235f0f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129bf1f1085a76b92999e0faeb30e831"><td class="memTemplParams" colspan="2">template&lt;typename IntType  = unsigned long long int&gt; </td></tr>
<tr class="memitem:a129bf1f1085a76b92999e0faeb30e831"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a129bf1f1085a76b92999e0faeb30e831">binomial_coeff</a> (unsigned int n, unsigned int m)</td></tr>
<tr class="memdesc:a129bf1f1085a76b92999e0faeb30e831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the binomial coefficient.  <a href="namespacetheoretica.html#a129bf1f1085a76b92999e0faeb30e831">More...</a><br /></td></tr>
<tr class="separator:a129bf1f1085a76b92999e0faeb30e831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286f4d2ae42de1965c86c999927f128b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a286f4d2ae42de1965c86c999927f128b">radians</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> <a class="el" href="namespacetheoretica.html#a840b8c27d0a8398f33858b1f8d55732d">degrees</a>)</td></tr>
<tr class="memdesc:a286f4d2ae42de1965c86c999927f128b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert degrees to radians.  <a href="namespacetheoretica.html#a286f4d2ae42de1965c86c999927f128b">More...</a><br /></td></tr>
<tr class="separator:a286f4d2ae42de1965c86c999927f128b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840b8c27d0a8398f33858b1f8d55732d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a840b8c27d0a8398f33858b1f8d55732d">degrees</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> <a class="el" href="namespacetheoretica.html#a286f4d2ae42de1965c86c999927f128b">radians</a>)</td></tr>
<tr class="memdesc:a840b8c27d0a8398f33858b1f8d55732d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert radians to degrees.  <a href="namespacetheoretica.html#a840b8c27d0a8398f33858b1f8d55732d">More...</a><br /></td></tr>
<tr class="separator:a840b8c27d0a8398f33858b1f8d55732d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321928d10b6606c1cba0232a613e6dfe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a321928d10b6606c1cba0232a613e6dfe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a321928d10b6606c1cba0232a613e6dfe">kronecker_delta</a> (T i, T j)</td></tr>
<tr class="memdesc:a321928d10b6606c1cba0232a613e6dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kronecker delta, equals 1 if i is equal to j, 0 otherwise.  <a href="namespacetheoretica.html#a321928d10b6606c1cba0232a613e6dfe">More...</a><br /></td></tr>
<tr class="separator:a321928d10b6606c1cba0232a613e6dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30aae7ee5989d1ae26c670c757483176"><td class="memTemplParams" colspan="2"><a id="a30aae7ee5989d1ae26c670c757483176" name="a30aae7ee5989d1ae26c670c757483176"></a>
template&lt;typename IntType  = unsigned long long int&gt; </td></tr>
<tr class="memitem:a30aae7ee5989d1ae26c670c757483176"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><b>catalan</b> (unsigned int n)</td></tr>
<tr class="memdesc:a30aae7ee5989d1ae26c670c757483176"><td class="mdescLeft">&#160;</td><td class="mdescRight">The n-th Catalan number. <br /></td></tr>
<tr class="separator:a30aae7ee5989d1ae26c670c757483176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b367e4460b8aec5f8c29282f671006"><td class="memTemplParams" colspan="2">template&lt;typename T  = real&gt; </td></tr>
<tr class="memitem:ab8b367e4460b8aec5f8c29282f671006"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ab8b367e4460b8aec5f8c29282f671006">lagrange_polynomial</a> (const std::vector&lt; <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; T, 2 &gt; &gt; &amp;points)</td></tr>
<tr class="memdesc:ab8b367e4460b8aec5f8c29282f671006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Lagrange polynomial interpolating a set of points.  <a href="namespacetheoretica.html#ab8b367e4460b8aec5f8c29282f671006">More...</a><br /></td></tr>
<tr class="separator:ab8b367e4460b8aec5f8c29282f671006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e8ede5b63e3e928ba06999468f33ef"><td class="memTemplParams" colspan="2">template&lt;typename VectorType  = std::vector&lt;real&gt;&gt; </td></tr>
<tr class="memitem:a25e8ede5b63e3e928ba06999468f33ef"><td class="memTemplItemLeft" align="right" valign="top">VectorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a25e8ede5b63e3e928ba06999468f33ef">chebyshev_nodes</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int n)</td></tr>
<tr class="memdesc:a25e8ede5b63e3e928ba06999468f33ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the n Chebyshev nodes on a given interval.  <a href="namespacetheoretica.html#a25e8ede5b63e3e928ba06999468f33ef">More...</a><br /></td></tr>
<tr class="separator:a25e8ede5b63e3e928ba06999468f33ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc2216d71f0d7147b5c0dacdeea80db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a9dc2216d71f0d7147b5c0dacdeea80db">interpolate_grid</a> (<a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int order)</td></tr>
<tr class="memdesc:a9dc2216d71f0d7147b5c0dacdeea80db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the interpolating polynomial of a real function on an equidistant point sample.  <a href="namespacetheoretica.html#a9dc2216d71f0d7147b5c0dacdeea80db">More...</a><br /></td></tr>
<tr class="separator:a9dc2216d71f0d7147b5c0dacdeea80db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f9a26f1ee40dea3fced3ee7e0c9aa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a88f9a26f1ee40dea3fced3ee7e0c9aa9">interpolate_chebyshev</a> (<a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int order)</td></tr>
<tr class="memdesc:a88f9a26f1ee40dea3fced3ee7e0c9aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the interpolating polynomial of a real function using Chebyshev nodes as sampling points.  <a href="namespacetheoretica.html#a88f9a26f1ee40dea3fced3ee7e0c9aa9">More...</a><br /></td></tr>
<tr class="separator:a88f9a26f1ee40dea3fced3ee7e0c9aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0edd44311fc206d96919ab11d1977a9"><td class="memItemLeft" align="right" valign="top"><a id="aa0edd44311fc206d96919ab11d1977a9" name="aa0edd44311fc206d96919ab11d1977a9"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lerp</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x1, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> interp)</td></tr>
<tr class="memdesc:aa0edd44311fc206d96919ab11d1977a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear interpolation. <br /></td></tr>
<tr class="separator:aa0edd44311fc206d96919ab11d1977a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab906f1a292b9290eaeb5b947b34561"><td class="memTemplParams" colspan="2"><a id="a9ab906f1a292b9290eaeb5b947b34561" name="a9ab906f1a292b9290eaeb5b947b34561"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a9ab906f1a292b9290eaeb5b947b34561"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>lerp</b> (const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;P1, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;P2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> interp)</td></tr>
<tr class="memdesc:a9ab906f1a292b9290eaeb5b947b34561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear interpolation. <br /></td></tr>
<tr class="separator:a9ab906f1a292b9290eaeb5b947b34561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a854543c4d5334c61247aed920937c7"><td class="memItemLeft" align="right" valign="top"><a id="a7a854543c4d5334c61247aed920937c7" name="a7a854543c4d5334c61247aed920937c7"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>invlerp</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x1, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> value)</td></tr>
<tr class="memdesc:a7a854543c4d5334c61247aed920937c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse linear interpolation. <br /></td></tr>
<tr class="separator:a7a854543c4d5334c61247aed920937c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7169371ce472198840dea64d46b21ca4"><td class="memTemplParams" colspan="2"><a id="a7169371ce472198840dea64d46b21ca4" name="a7169371ce472198840dea64d46b21ca4"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a7169371ce472198840dea64d46b21ca4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>invlerp</b> (const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;P1, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;P2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> value)</td></tr>
<tr class="memdesc:a7169371ce472198840dea64d46b21ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse linear interpolation. <br /></td></tr>
<tr class="separator:a7169371ce472198840dea64d46b21ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d55941e7aa059d066873e4116c531b0"><td class="memItemLeft" align="right" valign="top"><a id="a6d55941e7aa059d066873e4116c531b0" name="a6d55941e7aa059d066873e4116c531b0"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>remap</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> iFrom, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> iTo, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> oFrom, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> oTo, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> value)</td></tr>
<tr class="memdesc:a6d55941e7aa059d066873e4116c531b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remap a value from one range to another. <br /></td></tr>
<tr class="separator:a6d55941e7aa059d066873e4116c531b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71a4b01f78a3d0c9189041f667409b1"><td class="memTemplParams" colspan="2"><a id="aa71a4b01f78a3d0c9189041f667409b1" name="aa71a4b01f78a3d0c9189041f667409b1"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:aa71a4b01f78a3d0c9189041f667409b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>remap</b> (const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;iFrom, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;iTo, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;oFrom, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;oTo, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> value)</td></tr>
<tr class="memdesc:aa71a4b01f78a3d0c9189041f667409b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remap a vector value from one range to another. <br /></td></tr>
<tr class="separator:aa71a4b01f78a3d0c9189041f667409b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7403a0756ef5ec70b2a821373def40"><td class="memTemplParams" colspan="2"><a id="a5d7403a0756ef5ec70b2a821373def40" name="a5d7403a0756ef5ec70b2a821373def40"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a5d7403a0756ef5ec70b2a821373def40"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nlerp</b> (const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;P1, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;P2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> interp)</td></tr>
<tr class="memdesc:a5d7403a0756ef5ec70b2a821373def40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalized linear interpolation. <br /></td></tr>
<tr class="separator:a5d7403a0756ef5ec70b2a821373def40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe689c12108304dd74edc6b6e92ff84"><td class="memTemplParams" colspan="2"><a id="acfe689c12108304dd74edc6b6e92ff84" name="acfe689c12108304dd74edc6b6e92ff84"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:acfe689c12108304dd74edc6b6e92ff84"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>slerp</b> (const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;P1, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;P2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> t)</td></tr>
<tr class="memdesc:acfe689c12108304dd74edc6b6e92ff84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spherical interpolation. <br /></td></tr>
<tr class="separator:acfe689c12108304dd74edc6b6e92ff84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b8a327e65a2d21993a28009828faae"><td class="memItemLeft" align="right" valign="top"><a id="a75b8a327e65a2d21993a28009828faae" name="a75b8a327e65a2d21993a28009828faae"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>smoothstep</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x1, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> interp)</td></tr>
<tr class="memdesc:a75b8a327e65a2d21993a28009828faae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smoothstep interpolation. <br /></td></tr>
<tr class="separator:a75b8a327e65a2d21993a28009828faae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423c4bdba84ea280878dcef43b5df206"><td class="memItemLeft" align="right" valign="top"><a id="a423c4bdba84ea280878dcef43b5df206" name="a423c4bdba84ea280878dcef43b5df206"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>smootherstep</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x1, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> interp)</td></tr>
<tr class="memdesc:a423c4bdba84ea280878dcef43b5df206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smootherstep interpolation. <br /></td></tr>
<tr class="separator:a423c4bdba84ea280878dcef43b5df206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb40a700a725235c37a4ceeb1e09c7f6"><td class="memTemplParams" colspan="2"><a id="afb40a700a725235c37a4ceeb1e09c7f6" name="afb40a700a725235c37a4ceeb1e09c7f6"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:afb40a700a725235c37a4ceeb1e09c7f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>quadratic_bezier</b> (const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;P0, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;P1, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;P2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> t)</td></tr>
<tr class="memdesc:afb40a700a725235c37a4ceeb1e09c7f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quadratic Bezier curve. <br /></td></tr>
<tr class="separator:afb40a700a725235c37a4ceeb1e09c7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc018b01eb3df4f133863741a5ed343b"><td class="memTemplParams" colspan="2"><a id="acc018b01eb3df4f133863741a5ed343b" name="acc018b01eb3df4f133863741a5ed343b"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:acc018b01eb3df4f133863741a5ed343b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cubic_bezier</b> (const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;P0, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;P1, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;P2, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; P3, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> t)</td></tr>
<tr class="memdesc:acc018b01eb3df4f133863741a5ed343b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cubic Bezier curve. <br /></td></tr>
<tr class="separator:acc018b01eb3df4f133863741a5ed343b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9bfc7cddd25fd7dd7eb774e9ea1bef4"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ac9bfc7cddd25fd7dd7eb774e9ea1bef4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ac9bfc7cddd25fd7dd7eb774e9ea1bef4">bezier</a> (const std::vector&lt; <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &gt; &amp;points, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> t)</td></tr>
<tr class="memdesc:ac9bfc7cddd25fd7dd7eb774e9ea1bef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic Bezier curve in N dimensions.  <a href="namespacetheoretica.html#ac9bfc7cddd25fd7dd7eb774e9ea1bef4">More...</a><br /></td></tr>
<tr class="separator:ac9bfc7cddd25fd7dd7eb774e9ea1bef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99316012fec5500c779ddf8d4114b643"><td class="memTemplParams" colspan="2">template&lt;typename DataPoints  = std::vector&lt;vec2&gt;&gt; </td></tr>
<tr class="memitem:a99316012fec5500c779ddf8d4114b643"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structtheoretica_1_1spline__node.html">spline_node</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a99316012fec5500c779ddf8d4114b643">cubic_splines</a> (DataPoints p)</td></tr>
<tr class="memdesc:a99316012fec5500c779ddf8d4114b643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cubic splines interpolation of a set of data points.  <a href="namespacetheoretica.html#a99316012fec5500c779ddf8d4114b643">More...</a><br /></td></tr>
<tr class="separator:a99316012fec5500c779ddf8d4114b643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7bf96b1e850f0901d249adbfea8f382"><td class="memTemplParams" colspan="2">template&lt;typename Dataset1 , typename Dataset2 &gt; </td></tr>
<tr class="memitem:ae7bf96b1e850f0901d249adbfea8f382"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structtheoretica_1_1spline__node.html">spline_node</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ae7bf96b1e850f0901d249adbfea8f382">cubic_splines</a> (const Dataset1 &amp;x, const Dataset2 &amp;y)</td></tr>
<tr class="memdesc:ae7bf96b1e850f0901d249adbfea8f382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cubic splines interpolation of the sets of X and Y data points.  <a href="namespacetheoretica.html#ae7bf96b1e850f0901d249adbfea8f382">More...</a><br /></td></tr>
<tr class="separator:ae7bf96b1e850f0901d249adbfea8f382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30bf47b100bccb63fb06b68397a7c28c"><td class="memTemplParams" colspan="2"><a id="a30bf47b100bccb63fb06b68397a7c28c" name="a30bf47b100bccb63fb06b68397a7c28c"></a>
template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a30bf47b100bccb63fb06b68397a7c28c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>approx_max_goldensection</b> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b)</td></tr>
<tr class="memdesc:a30bf47b100bccb63fb06b68397a7c28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a function maximum using the Golden Section search algorithm. <br /></td></tr>
<tr class="separator:a30bf47b100bccb63fb06b68397a7c28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297397efe063a52c126c2232fc65d03a"><td class="memTemplParams" colspan="2"><a id="a297397efe063a52c126c2232fc65d03a" name="a297397efe063a52c126c2232fc65d03a"></a>
template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a297397efe063a52c126c2232fc65d03a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>approx_min_goldensection</b> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b)</td></tr>
<tr class="memdesc:a297397efe063a52c126c2232fc65d03a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a function minimum using the Golden Section search algorithm. <br /></td></tr>
<tr class="separator:a297397efe063a52c126c2232fc65d03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f27c104f6244cc0dda21b4bc46a225c"><td class="memTemplParams" colspan="2"><a id="a4f27c104f6244cc0dda21b4bc46a225c" name="a4f27c104f6244cc0dda21b4bc46a225c"></a>
template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a4f27c104f6244cc0dda21b4bc46a225c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>approx_max_newton</b> (RealFunction f, RealFunction Df, RealFunction D2f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:a4f27c104f6244cc0dda21b4bc46a225c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a function maximum given the function and the first two derivatives using Newton-Raphson. <br /></td></tr>
<tr class="separator:a4f27c104f6244cc0dda21b4bc46a225c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1efb73e66d3a6ca97a2904aa06f3f6"><td class="memTemplParams" colspan="2"><a id="a8a1efb73e66d3a6ca97a2904aa06f3f6" name="a8a1efb73e66d3a6ca97a2904aa06f3f6"></a>
template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a8a1efb73e66d3a6ca97a2904aa06f3f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>approx_min_newton</b> (RealFunction f, RealFunction Df, RealFunction D2f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:a8a1efb73e66d3a6ca97a2904aa06f3f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a function minimum given the function and the first two derivatives using Newton-Raphson. <br /></td></tr>
<tr class="separator:a8a1efb73e66d3a6ca97a2904aa06f3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec19c3cb57810dac37ac300c895bb50"><td class="memTemplParams" colspan="2"><a id="a9ec19c3cb57810dac37ac300c895bb50" name="a9ec19c3cb57810dac37ac300c895bb50"></a>
template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a9ec19c3cb57810dac37ac300c895bb50"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>approx_max_bisection</b> (RealFunction f, RealFunction Df, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b)</td></tr>
<tr class="memdesc:a9ec19c3cb57810dac37ac300c895bb50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a function maximum inside an interval given the function and its first derivative using bisection on the derivative. <br /></td></tr>
<tr class="separator:a9ec19c3cb57810dac37ac300c895bb50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2040484743eb55bcd56e4c79f20ea6e1"><td class="memTemplParams" colspan="2"><a id="a2040484743eb55bcd56e4c79f20ea6e1" name="a2040484743eb55bcd56e4c79f20ea6e1"></a>
template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a2040484743eb55bcd56e4c79f20ea6e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>approx_min_bisection</b> (RealFunction f, RealFunction Df, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b)</td></tr>
<tr class="memdesc:a2040484743eb55bcd56e4c79f20ea6e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a function minimum inside an interval given the function and its first derivative using bisection on the derivative. <br /></td></tr>
<tr class="separator:a2040484743eb55bcd56e4c79f20ea6e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9206e7284e0bf7c65a4d6ba3290cd8"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a6b9206e7284e0bf7c65a4d6ba3290cd8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a6b9206e7284e0bf7c65a4d6ba3290cd8">minimize_grad</a> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;, N &gt;), <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; guess=<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;(0), <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> gamma=<a class="el" href="namespacetheoretica.html#ab33f363492da480d62e2e0b5ad2c4ee9">MINGRAD_GAMMA</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#a5ebee50e5a5a80baaa6532a736ce7d55">MINGRAD_TOLERANCE</a>, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#acd4ef8ed777e402e2ae0c7f736ba20cb">MINGRAD_MAX_ITER</a>)</td></tr>
<tr class="memdesc:a6b9206e7284e0bf7c65a4d6ba3290cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a local minimum of the given multivariate function using fixed-step gradient descent.  <a href="namespacetheoretica.html#a6b9206e7284e0bf7c65a4d6ba3290cd8">More...</a><br /></td></tr>
<tr class="separator:a6b9206e7284e0bf7c65a4d6ba3290cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed9c4f8f3ecf08e0f2b062aebab37eb"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a2ed9c4f8f3ecf08e0f2b062aebab37eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a2ed9c4f8f3ecf08e0f2b062aebab37eb">maximize_grad</a> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;, N &gt;), <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; guess=<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;(0), <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> gamma=<a class="el" href="namespacetheoretica.html#ab33f363492da480d62e2e0b5ad2c4ee9">MINGRAD_GAMMA</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#a5ebee50e5a5a80baaa6532a736ce7d55">MINGRAD_TOLERANCE</a>, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#acd4ef8ed777e402e2ae0c7f736ba20cb">MINGRAD_MAX_ITER</a>)</td></tr>
<tr class="memdesc:a2ed9c4f8f3ecf08e0f2b062aebab37eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a local maximum of the given multivariate function using fixed-step gradient descent.  <a href="namespacetheoretica.html#a2ed9c4f8f3ecf08e0f2b062aebab37eb">More...</a><br /></td></tr>
<tr class="separator:a2ed9c4f8f3ecf08e0f2b062aebab37eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d1451b1f5fa91ec37aeedc52f5c1c8"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a54d1451b1f5fa91ec37aeedc52f5c1c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a54d1451b1f5fa91ec37aeedc52f5c1c8">minimize_lingrad</a> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;, N &gt;), <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; guess=<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;(0), <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#a5ebee50e5a5a80baaa6532a736ce7d55">MINGRAD_TOLERANCE</a>, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#acd4ef8ed777e402e2ae0c7f736ba20cb">MINGRAD_MAX_ITER</a>)</td></tr>
<tr class="memdesc:a54d1451b1f5fa91ec37aeedc52f5c1c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a local minimum of the given multivariate function using gradient descent with linear search.  <a href="namespacetheoretica.html#a54d1451b1f5fa91ec37aeedc52f5c1c8">More...</a><br /></td></tr>
<tr class="separator:a54d1451b1f5fa91ec37aeedc52f5c1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6abfd74878f161330c5564560dc7451"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ad6abfd74878f161330c5564560dc7451"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ad6abfd74878f161330c5564560dc7451">maximize_lingrad</a> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;, N &gt;), <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; guess=<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;(0), <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#a5ebee50e5a5a80baaa6532a736ce7d55">MINGRAD_TOLERANCE</a>, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#acd4ef8ed777e402e2ae0c7f736ba20cb">MINGRAD_MAX_ITER</a>)</td></tr>
<tr class="memdesc:ad6abfd74878f161330c5564560dc7451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a local maximum of the given multivariate function using gradient descent with linear search.  <a href="namespacetheoretica.html#ad6abfd74878f161330c5564560dc7451">More...</a><br /></td></tr>
<tr class="separator:ad6abfd74878f161330c5564560dc7451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1756ced9e0ae717d8eef965c993af5fe"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a1756ced9e0ae717d8eef965c993af5fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a1756ced9e0ae717d8eef965c993af5fe">minimize</a> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;, N &gt;), <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; guess=<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;(0), <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#a5ebee50e5a5a80baaa6532a736ce7d55">MINGRAD_TOLERANCE</a>)</td></tr>
<tr class="memdesc:a1756ced9e0ae717d8eef965c993af5fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the best available algorithm to find a local minimum of the given multivariate function.  <a href="namespacetheoretica.html#a1756ced9e0ae717d8eef965c993af5fe">More...</a><br /></td></tr>
<tr class="separator:a1756ced9e0ae717d8eef965c993af5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9ca806c04b6433f5e23a9a0fa25d4d"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:acd9ca806c04b6433f5e23a9a0fa25d4d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#acd9ca806c04b6433f5e23a9a0fa25d4d">maximize</a> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;, N &gt;), <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; guess=<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;(0), <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#a5ebee50e5a5a80baaa6532a736ce7d55">MINGRAD_TOLERANCE</a>)</td></tr>
<tr class="memdesc:acd9ca806c04b6433f5e23a9a0fa25d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the best available algorithm to find a local maximum of the given multivariate function.  <a href="namespacetheoretica.html#acd9ca806c04b6433f5e23a9a0fa25d4d">More...</a><br /></td></tr>
<tr class="separator:acd9ca806c04b6433f5e23a9a0fa25d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab918c2760ce54c9d49e15d942078b470"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ab918c2760ce54c9d49e15d942078b470"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ab918c2760ce54c9d49e15d942078b470">multiroot_newton</a> (<a class="el" href="classtheoretica_1_1vec.html">d_vec</a>&lt; N &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">d_vec</a>&lt; N &gt;), <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; guess=<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;(0), <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#a5ebee50e5a5a80baaa6532a736ce7d55">MINGRAD_TOLERANCE</a>, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#acd4ef8ed777e402e2ae0c7f736ba20cb">MINGRAD_MAX_ITER</a>)</td></tr>
<tr class="memdesc:ab918c2760ce54c9d49e15d942078b470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate the root of a multivariate function using Newton's method with pure Jacobian.  <a href="namespacetheoretica.html#ab918c2760ce54c9d49e15d942078b470">More...</a><br /></td></tr>
<tr class="separator:ab918c2760ce54c9d49e15d942078b470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c11855cee4c627ff303e9b50845a75"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a64c11855cee4c627ff303e9b50845a75"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetheoretica.html#a1f21bd68ba64b172c29d9fce15c8712d">vec2</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a64c11855cee4c627ff303e9b50845a75">find_root_intervals</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int steps=10)</td></tr>
<tr class="memdesc:a64c11855cee4c627ff303e9b50845a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find candidate intervals for root finding.  <a href="namespacetheoretica.html#a64c11855cee4c627ff303e9b50845a75">More...</a><br /></td></tr>
<tr class="separator:a64c11855cee4c627ff303e9b50845a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04969926a4834b77f3efd544ae91f8a4"><td class="memTemplParams" colspan="2"><a id="a04969926a4834b77f3efd544ae91f8a4" name="a04969926a4834b77f3efd544ae91f8a4"></a>
template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a04969926a4834b77f3efd544ae91f8a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>root_bisection</b> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#a28fc38a93f999c3c98056f3dac665f42">BISECTION_APPROX_TOL</a>)</td></tr>
<tr class="memdesc:a04969926a4834b77f3efd544ae91f8a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a root of an arbitrary function using bisection inside a compact interval [a, b] where f(a) * f(b) &lt; 0. <br /></td></tr>
<tr class="separator:a04969926a4834b77f3efd544ae91f8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0fb37bfbf8861bc1ec621200e4d8d09"><td class="memTemplParams" colspan="2"><a id="aa0fb37bfbf8861bc1ec621200e4d8d09" name="aa0fb37bfbf8861bc1ec621200e4d8d09"></a>
template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:aa0fb37bfbf8861bc1ec621200e4d8d09"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>root_newton</b> (RealFunction f, RealFunction Df, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:aa0fb37bfbf8861bc1ec621200e4d8d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a root of an arbitrary function using Newton's method. <br /></td></tr>
<tr class="separator:aa0fb37bfbf8861bc1ec621200e4d8d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89aae9512bed56bdb44d2b5394aa6d0e"><td class="memItemLeft" align="right" valign="top"><a id="a89aae9512bed56bdb44d2b5394aa6d0e" name="a89aae9512bed56bdb44d2b5394aa6d0e"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>root_newton</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a>(*f)(<a class="el" href="classtheoretica_1_1dual.html">dual</a>), <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:a89aae9512bed56bdb44d2b5394aa6d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a root of an arbitrary function using Newton's method, computing the derivative using automatic differentiation. <br /></td></tr>
<tr class="separator:a89aae9512bed56bdb44d2b5394aa6d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b85ffa21b3b0cf30029565a1f6693f"><td class="memItemLeft" align="right" valign="top"><a id="a89b85ffa21b3b0cf30029565a1f6693f" name="a89b85ffa21b3b0cf30029565a1f6693f"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>root_newton_polyn</b> (<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; p, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:a89b85ffa21b3b0cf30029565a1f6693f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a root of a polynomial using Newton's method. <br /></td></tr>
<tr class="separator:a89b85ffa21b3b0cf30029565a1f6693f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa801269604efdfd3b558948555da3d51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa801269604efdfd3b558948555da3d51">root_newton</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt;&gt;(*f)(<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt;&gt;), <a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt;&gt;(*df)(<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt;&gt;), <a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt;&gt; guess=<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt;&gt;(0, 0), <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#ae3a871a5ce0e15ea45205f3e15eec423">NEWTON_RAPHSON_TOL</a>, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#a09bde3716d7598748a55fa65c9abb6e3">MAX_NEWTON_ITER</a>)</td></tr>
<tr class="memdesc:aa801269604efdfd3b558948555da3d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a root of an arbitrary complex function using Newton's method,.  <a href="namespacetheoretica.html#aa801269604efdfd3b558948555da3d51">More...</a><br /></td></tr>
<tr class="separator:aa801269604efdfd3b558948555da3d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ec9b2753a108bba753d27e179b641a"><td class="memTemplParams" colspan="2"><a id="a09ec9b2753a108bba753d27e179b641a" name="a09ec9b2753a108bba753d27e179b641a"></a>
template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a09ec9b2753a108bba753d27e179b641a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>root_halley</b> (RealFunction f, RealFunction Df, RealFunction D2f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:a09ec9b2753a108bba753d27e179b641a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a root of an arbitrary function using Halley's method. <br /></td></tr>
<tr class="separator:a09ec9b2753a108bba753d27e179b641a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8def14947889f0121eee98ebf8edca57"><td class="memItemLeft" align="right" valign="top"><a id="a8def14947889f0121eee98ebf8edca57" name="a8def14947889f0121eee98ebf8edca57"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>root_halley</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>(*f)(<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>), <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:a8def14947889f0121eee98ebf8edca57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a root of an arbitrary function using Halley's method. <br /></td></tr>
<tr class="separator:a8def14947889f0121eee98ebf8edca57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eabe0e9854df5f4efdc54ab05d00362"><td class="memItemLeft" align="right" valign="top"><a id="a1eabe0e9854df5f4efdc54ab05d00362" name="a1eabe0e9854df5f4efdc54ab05d00362"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>root_halley_polyn</b> (<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; p, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:a1eabe0e9854df5f4efdc54ab05d00362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a root of a polynomial using Halley's method. <br /></td></tr>
<tr class="separator:a1eabe0e9854df5f4efdc54ab05d00362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9273bd81e15300cf5519966bd9baeb"><td class="memTemplParams" colspan="2"><a id="a5f9273bd81e15300cf5519966bd9baeb" name="a5f9273bd81e15300cf5519966bd9baeb"></a>
template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a5f9273bd81e15300cf5519966bd9baeb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>root_steffensen</b> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:a5f9273bd81e15300cf5519966bd9baeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a root of an arbitrary function using Steffensen's method. <br /></td></tr>
<tr class="separator:a5f9273bd81e15300cf5519966bd9baeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae280f0a4bdc4ed84e2bb4b37a9083a74"><td class="memItemLeft" align="right" valign="top"><a id="ae280f0a4bdc4ed84e2bb4b37a9083a74" name="ae280f0a4bdc4ed84e2bb4b37a9083a74"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>root_steffensen_polyn</b> (<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; p, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:ae280f0a4bdc4ed84e2bb4b37a9083a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a root of a polynomial using Steffensen's method. <br /></td></tr>
<tr class="separator:ae280f0a4bdc4ed84e2bb4b37a9083a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c5c8826f494eeff734a2980defb72c"><td class="memTemplParams" colspan="2"><a id="ac8c5c8826f494eeff734a2980defb72c" name="ac8c5c8826f494eeff734a2980defb72c"></a>
template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:ac8c5c8826f494eeff734a2980defb72c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>root_chebyshev</b> (RealFunction f, RealFunction Df, RealFunction D2f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:ac8c5c8826f494eeff734a2980defb72c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a root of an arbitrary function using Chebyshev's method. <br /></td></tr>
<tr class="separator:ac8c5c8826f494eeff734a2980defb72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959ae94aff9e106e30cf5cf76f229780"><td class="memItemLeft" align="right" valign="top"><a id="a959ae94aff9e106e30cf5cf76f229780" name="a959ae94aff9e106e30cf5cf76f229780"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>root_chebyshev</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>(*f)(<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>), <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:a959ae94aff9e106e30cf5cf76f229780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a root of an arbitrary function using Chebyshev's method. <br /></td></tr>
<tr class="separator:a959ae94aff9e106e30cf5cf76f229780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc74296da58460d3ce7bd6e1f99584d"><td class="memItemLeft" align="right" valign="top"><a id="afdc74296da58460d3ce7bd6e1f99584d" name="afdc74296da58460d3ce7bd6e1f99584d"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>root_chebyshev_polyn</b> (<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; p, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:afdc74296da58460d3ce7bd6e1f99584d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a root of a polynomial using Chebyshev's method. <br /></td></tr>
<tr class="separator:afdc74296da58460d3ce7bd6e1f99584d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20336c8a6fb0653a8fe5c5f8bdf867f4"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a20336c8a6fb0653a8fe5c5f8bdf867f4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a20336c8a6fb0653a8fe5c5f8bdf867f4">roots</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#a28fc38a93f999c3c98056f3dac665f42">BISECTION_APPROX_TOL</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> steps=10)</td></tr>
<tr class="memdesc:a20336c8a6fb0653a8fe5c5f8bdf867f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the roots of a function inside a given interval.  <a href="namespacetheoretica.html#a20336c8a6fb0653a8fe5c5f8bdf867f4">More...</a><br /></td></tr>
<tr class="separator:a20336c8a6fb0653a8fe5c5f8bdf867f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389c95a049e94d34f94da914afdde6d6"><td class="memTemplParams" colspan="2">template&lt;typename Field &gt; </td></tr>
<tr class="memitem:a389c95a049e94d34f94da914afdde6d6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Field &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a389c95a049e94d34f94da914afdde6d6">roots</a> (<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; Field &gt; p, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#a28fc38a93f999c3c98056f3dac665f42">BISECTION_APPROX_TOL</a>, unsigned int steps=0)</td></tr>
<tr class="memdesc:a389c95a049e94d34f94da914afdde6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the roots of a polynomial.  <a href="namespacetheoretica.html#a389c95a049e94d34f94da914afdde6d6">More...</a><br /></td></tr>
<tr class="separator:a389c95a049e94d34f94da914afdde6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5adf7d2f3094d32dd9d4059ec86247db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a5adf7d2f3094d32dd9d4059ec86247db">gen_polyn_recurr</a> (<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; P0, <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; P1, <a class="el" href="namespacetheoretica.html#adcb53498374f76292a3da8bb8c785341">polyn_recurr_formula</a> f, unsigned int n)</td></tr>
<tr class="memdesc:a5adf7d2f3094d32dd9d4059ec86247db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a polynomial basis using a recursion formula.  <a href="namespacetheoretica.html#a5adf7d2f3094d32dd9d4059ec86247db">More...</a><br /></td></tr>
<tr class="separator:a5adf7d2f3094d32dd9d4059ec86247db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed24464894a5a23896554578641576ac"><td class="memItemLeft" align="right" valign="top"><a id="aed24464894a5a23896554578641576ac" name="aed24464894a5a23896554578641576ac"></a>
<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>legendre_polyn_recurr</b> (<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; P0, <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; P1, unsigned int l)</td></tr>
<tr class="memdesc:aed24464894a5a23896554578641576ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursion formula for Legendre polynomials. <br /></td></tr>
<tr class="separator:aed24464894a5a23896554578641576ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa95392d9bfc3ddf34f3e82f4b6ae78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#acaa95392d9bfc3ddf34f3e82f4b6ae78">legendre_polynomial</a> (unsigned int n)</td></tr>
<tr class="memdesc:acaa95392d9bfc3ddf34f3e82f4b6ae78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the nth Legendre polynomial.  <a href="namespacetheoretica.html#acaa95392d9bfc3ddf34f3e82f4b6ae78">More...</a><br /></td></tr>
<tr class="separator:acaa95392d9bfc3ddf34f3e82f4b6ae78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca937d779d223cab3a43b4236876491a"><td class="memItemLeft" align="right" valign="top"><a id="aca937d779d223cab3a43b4236876491a" name="aca937d779d223cab3a43b4236876491a"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>legendre_polyn_normalization</b> (unsigned int n)</td></tr>
<tr class="memdesc:aca937d779d223cab3a43b4236876491a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalization constant for the nth Legendre polynomial. <br /></td></tr>
<tr class="separator:aca937d779d223cab3a43b4236876491a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c34c73635e03e3c7064a035b122eed"><td class="memItemLeft" align="right" valign="top"><a id="a68c34c73635e03e3c7064a035b122eed" name="a68c34c73635e03e3c7064a035b122eed"></a>
std::function&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>assoc_legendre_polynomial</b> (unsigned int l, int m)</td></tr>
<tr class="separator:a68c34c73635e03e3c7064a035b122eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3085278cb86c36246eca175bc1ee9f"><td class="memItemLeft" align="right" valign="top"><a id="a7d3085278cb86c36246eca175bc1ee9f" name="a7d3085278cb86c36246eca175bc1ee9f"></a>
<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>assoc_legendre_polynomial_even</b> (unsigned int l, int m)</td></tr>
<tr class="separator:a7d3085278cb86c36246eca175bc1ee9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5a48283ac42a9362f25d977d066cf3"><td class="memItemLeft" align="right" valign="top"><a id="a0b5a48283ac42a9362f25d977d066cf3" name="a0b5a48283ac42a9362f25d977d066cf3"></a>
<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>laguerre_polyn_recurr</b> (<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; L0, <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; L1, unsigned int i)</td></tr>
<tr class="memdesc:a0b5a48283ac42a9362f25d977d066cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursion formula for Laguerre polynomials. <br /></td></tr>
<tr class="separator:a0b5a48283ac42a9362f25d977d066cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62665bb64745df12234614b05c2dfb3"><td class="memItemLeft" align="right" valign="top"><a id="af62665bb64745df12234614b05c2dfb3" name="af62665bb64745df12234614b05c2dfb3"></a>
<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>laguerre_polynomial</b> (unsigned int n)</td></tr>
<tr class="memdesc:af62665bb64745df12234614b05c2dfb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the nth Laguerre polynomial. <br /></td></tr>
<tr class="separator:af62665bb64745df12234614b05c2dfb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeafda1fc6155cc96c62d9d777d8f709"><td class="memItemLeft" align="right" valign="top"><a id="aaeafda1fc6155cc96c62d9d777d8f709" name="aaeafda1fc6155cc96c62d9d777d8f709"></a>
<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>general_laguerre_polyn_recurr</b> (<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; L0, <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; L1, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> alpha, unsigned int i)</td></tr>
<tr class="memdesc:aaeafda1fc6155cc96c62d9d777d8f709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursion formula for Generalized Laguerre polynomials. <br /></td></tr>
<tr class="separator:aaeafda1fc6155cc96c62d9d777d8f709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e5e8380097d9ad25a51413bcb244d3"><td class="memItemLeft" align="right" valign="top"><a id="ab3e5e8380097d9ad25a51413bcb244d3" name="ab3e5e8380097d9ad25a51413bcb244d3"></a>
<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>general_laguerre_polynomial</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> alpha, unsigned int n)</td></tr>
<tr class="memdesc:ab3e5e8380097d9ad25a51413bcb244d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the nth Laguerre polynomial. <br /></td></tr>
<tr class="separator:ab3e5e8380097d9ad25a51413bcb244d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da3a4e4195c5c77e99db62ae442fa19"><td class="memItemLeft" align="right" valign="top"><a id="a2da3a4e4195c5c77e99db62ae442fa19" name="a2da3a4e4195c5c77e99db62ae442fa19"></a>
<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>hermite_polyn_recurr</b> (<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; H0, <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; H1, unsigned int i)</td></tr>
<tr class="memdesc:a2da3a4e4195c5c77e99db62ae442fa19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursion formula for Hermite polynomials. <br /></td></tr>
<tr class="separator:a2da3a4e4195c5c77e99db62ae442fa19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd97a0d6d99915f065567958760164f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#afd97a0d6d99915f065567958760164f4">hermite_polynomial</a> (unsigned int n)</td></tr>
<tr class="memdesc:afd97a0d6d99915f065567958760164f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the nth Hermite polynomial.  <a href="namespacetheoretica.html#afd97a0d6d99915f065567958760164f4">More...</a><br /></td></tr>
<tr class="separator:afd97a0d6d99915f065567958760164f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7659e1b121c8c96e884b95bb4ae45ebc"><td class="memItemLeft" align="right" valign="top"><a id="a7659e1b121c8c96e884b95bb4ae45ebc" name="a7659e1b121c8c96e884b95bb4ae45ebc"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>hermite_polyn_normalization</b> (unsigned int n)</td></tr>
<tr class="memdesc:a7659e1b121c8c96e884b95bb4ae45ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalization constant for the nth Hermite polynomial. <br /></td></tr>
<tr class="separator:a7659e1b121c8c96e884b95bb4ae45ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e77e33cee4661bf1a52bec32fa434c"><td class="memItemLeft" align="right" valign="top"><a id="ac8e77e33cee4661bf1a52bec32fa434c" name="ac8e77e33cee4661bf1a52bec32fa434c"></a>
<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>chebyshev_polyn_recurr</b> (<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; T0, <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; T1, unsigned int i)</td></tr>
<tr class="memdesc:ac8e77e33cee4661bf1a52bec32fa434c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursion formula for Chebyshev polynomials The formula is the same for first and second kind polynomials. <br /></td></tr>
<tr class="separator:ac8e77e33cee4661bf1a52bec32fa434c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085e34f437a529b59778090e0cb122e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a085e34f437a529b59778090e0cb122e5">chebyshev1_polynomial</a> (unsigned int n)</td></tr>
<tr class="memdesc:a085e34f437a529b59778090e0cb122e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the nth Chebyshev polynomial of the first kind.  <a href="namespacetheoretica.html#a085e34f437a529b59778090e0cb122e5">More...</a><br /></td></tr>
<tr class="separator:a085e34f437a529b59778090e0cb122e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3450aa75a960635e9f33a6dabb22752b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a3450aa75a960635e9f33a6dabb22752b">chebyshev2_polynomial</a> (unsigned int n)</td></tr>
<tr class="memdesc:a3450aa75a960635e9f33a6dabb22752b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the nth Chebyshev polynomial of the second kind.  <a href="namespacetheoretica.html#a3450aa75a960635e9f33a6dabb22752b">More...</a><br /></td></tr>
<tr class="separator:a3450aa75a960635e9f33a6dabb22752b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebbaeffb922b25d5f1758296b473939f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aebbaeffb922b25d5f1758296b473939f">legendre_roots</a> (unsigned int n)</td></tr>
<tr class="memdesc:aebbaeffb922b25d5f1758296b473939f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Roots of the n-th Legendre polynomial.  <a href="namespacetheoretica.html#aebbaeffb922b25d5f1758296b473939f">More...</a><br /></td></tr>
<tr class="separator:aebbaeffb922b25d5f1758296b473939f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40aca2488b0466c4934fd050d3718760"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a40aca2488b0466c4934fd050d3718760">legendre_weights</a> (const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;<a class="el" href="namespacetheoretica.html#a20336c8a6fb0653a8fe5c5f8bdf867f4">roots</a>)</td></tr>
<tr class="memdesc:a40aca2488b0466c4934fd050d3718760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legendre weights for Gauss-Legendre quadrature of n-th order.  <a href="namespacetheoretica.html#a40aca2488b0466c4934fd050d3718760">More...</a><br /></td></tr>
<tr class="separator:a40aca2488b0466c4934fd050d3718760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b528fc8814c1dd197a21d49f1ad6c93"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a4b528fc8814c1dd197a21d49f1ad6c93">laguerre_weights</a> (const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;<a class="el" href="namespacetheoretica.html#a20336c8a6fb0653a8fe5c5f8bdf867f4">roots</a>)</td></tr>
<tr class="memdesc:a4b528fc8814c1dd197a21d49f1ad6c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Laguerre weights for Gauss-Laguerre quadrature of n-th order.  <a href="namespacetheoretica.html#a4b528fc8814c1dd197a21d49f1ad6c93">More...</a><br /></td></tr>
<tr class="separator:a4b528fc8814c1dd197a21d49f1ad6c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04806d2927b08fe51b37c5a1c517de35"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a04806d2927b08fe51b37c5a1c517de35">hermite_weights</a> (const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;<a class="el" href="namespacetheoretica.html#a20336c8a6fb0653a8fe5c5f8bdf867f4">roots</a>)</td></tr>
<tr class="memdesc:a04806d2927b08fe51b37c5a1c517de35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hermite weights for Gauss-Hermite quadrature of n-th order.  <a href="namespacetheoretica.html#a04806d2927b08fe51b37c5a1c517de35">More...</a><br /></td></tr>
<tr class="separator:a04806d2927b08fe51b37c5a1c517de35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07652c066aaca0e41b16a21554bc5a28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a07652c066aaca0e41b16a21554bc5a28">integral_crude</a> (<a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g, unsigned int N=1000)</td></tr>
<tr class="memdesc:a07652c066aaca0e41b16a21554bc5a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate an integral by using Crude Monte Carlo integration.  <a href="namespacetheoretica.html#a07652c066aaca0e41b16a21554bc5a28">More...</a><br /></td></tr>
<tr class="separator:a07652c066aaca0e41b16a21554bc5a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301de055cdb4b0a9888d68dc8382b5cf"><td class="memTemplParams" colspan="2">template&lt;unsigned int S&gt; </td></tr>
<tr class="memitem:a301de055cdb4b0a9888d68dc8382b5cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a301de055cdb4b0a9888d68dc8382b5cf">integral_crude</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, S &gt;), <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a1f21bd68ba64b172c29d9fce15c8712d">vec2</a>, S &gt; extremes, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g, unsigned int N=1000)</td></tr>
<tr class="memdesc:a301de055cdb4b0a9888d68dc8382b5cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate an integral by using Crude Monte Carlo integration.  <a href="namespacetheoretica.html#a301de055cdb4b0a9888d68dc8382b5cf">More...</a><br /></td></tr>
<tr class="separator:a301de055cdb4b0a9888d68dc8382b5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c69bea27399e4d430e877b538ce777"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a11c69bea27399e4d430e877b538ce777">integral_quasi_crude</a> (<a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int N=1000)</td></tr>
<tr class="memdesc:a11c69bea27399e4d430e877b538ce777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate an integral by using Crude Quasi-Monte Carlo integration by sampling from the Weyl sequence.  <a href="namespacetheoretica.html#a11c69bea27399e4d430e877b538ce777">More...</a><br /></td></tr>
<tr class="separator:a11c69bea27399e4d430e877b538ce777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad6a42bf9fd0176e622e01e0f7446a9"><td class="memTemplParams" colspan="2">template&lt;unsigned int S&gt; </td></tr>
<tr class="memitem:abad6a42bf9fd0176e622e01e0f7446a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#abad6a42bf9fd0176e622e01e0f7446a9">integral_quasi_crude</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, S &gt;), <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a1f21bd68ba64b172c29d9fce15c8712d">vec2</a>, S &gt; extremes, unsigned int N, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, S &gt; alpha)</td></tr>
<tr class="memdesc:abad6a42bf9fd0176e622e01e0f7446a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate an integral by using Crude Quasi-Monte Carlo integration by sampling from the Weyl sequence.  <a href="namespacetheoretica.html#abad6a42bf9fd0176e622e01e0f7446a9">More...</a><br /></td></tr>
<tr class="separator:abad6a42bf9fd0176e622e01e0f7446a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed022df42e2b7152fc916433acbfbcc"><td class="memTemplParams" colspan="2">template&lt;unsigned int S&gt; </td></tr>
<tr class="memitem:a4ed022df42e2b7152fc916433acbfbcc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a4ed022df42e2b7152fc916433acbfbcc">integral_quasi_crude</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, S &gt;), <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a1f21bd68ba64b172c29d9fce15c8712d">vec2</a>, S &gt; extremes, unsigned int N=1000, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> alpha=0)</td></tr>
<tr class="memdesc:a4ed022df42e2b7152fc916433acbfbcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate an integral by using Crude Quasi-Monte Carlo integration by sampling from the Weyl sequence.  <a href="namespacetheoretica.html#a4ed022df42e2b7152fc916433acbfbcc">More...</a><br /></td></tr>
<tr class="separator:a4ed022df42e2b7152fc916433acbfbcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369a64e60df5e45af0bb4581a9f213da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a369a64e60df5e45af0bb4581a9f213da">integral_hom</a> (<a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> c, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> d, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g, unsigned int N=1000)</td></tr>
<tr class="memdesc:a369a64e60df5e45af0bb4581a9f213da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate an integral by using Hit-or-miss Monte Carlo integration.  <a href="namespacetheoretica.html#a369a64e60df5e45af0bb4581a9f213da">More...</a><br /></td></tr>
<tr class="separator:a369a64e60df5e45af0bb4581a9f213da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd8b0a1c223e7bc79b04046d4e8502da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#afd8b0a1c223e7bc79b04046d4e8502da">integral_hom</a> (<a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> f_max, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g, unsigned int N=1000)</td></tr>
<tr class="memdesc:afd8b0a1c223e7bc79b04046d4e8502da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate an integral by using Hit-or-miss Monte Carlo integration.  <a href="namespacetheoretica.html#afd8b0a1c223e7bc79b04046d4e8502da">More...</a><br /></td></tr>
<tr class="separator:afd8b0a1c223e7bc79b04046d4e8502da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2655b89d203adc197979dafd29fe518b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a2655b89d203adc197979dafd29fe518b">integral_quasi_hom</a> (<a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> c, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> d, unsigned int N=1000)</td></tr>
<tr class="memdesc:a2655b89d203adc197979dafd29fe518b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate an integral by using Hit-or-miss Quasi-Monte Carlo integration, sampling points from the Weyl bi-dimensional sequence.  <a href="namespacetheoretica.html#a2655b89d203adc197979dafd29fe518b">More...</a><br /></td></tr>
<tr class="separator:a2655b89d203adc197979dafd29fe518b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f21b203e4325f357c2c84558239269"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a22f21b203e4325f357c2c84558239269">integral_quasi_hom</a> (<a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> f_max, unsigned int N=1000)</td></tr>
<tr class="memdesc:a22f21b203e4325f357c2c84558239269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate an integral by using Hit-or-miss Quasi-Monte Carlo integration, sampling points from the Weyl bi-dimensional sequence.  <a href="namespacetheoretica.html#a22f21b203e4325f357c2c84558239269">More...</a><br /></td></tr>
<tr class="separator:a22f21b203e4325f357c2c84558239269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1373c528867e33024d2975dfa7c41ca4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a1373c528867e33024d2975dfa7c41ca4">integral_hom_2d</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*f)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>), <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> c, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> d, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> f_max, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g, unsigned int N=1000)</td></tr>
<tr class="memdesc:a1373c528867e33024d2975dfa7c41ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the Hit-or-Miss Monte Carlo method to approximate a double integral.  <a href="namespacetheoretica.html#a1373c528867e33024d2975dfa7c41ca4">More...</a><br /></td></tr>
<tr class="separator:a1373c528867e33024d2975dfa7c41ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1d65e5dba67ccf5199e5d5544e2484"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a3d1d65e5dba67ccf5199e5d5544e2484">integral_impsamp</a> (<a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> f, <a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> g, <a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> Ginv, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;gen, unsigned int N=1000)</td></tr>
<tr class="memdesc:a3d1d65e5dba67ccf5199e5d5544e2484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate an integral by using Crude Monte Carlo integration with importance sampling.  <a href="namespacetheoretica.html#a3d1d65e5dba67ccf5199e5d5544e2484">More...</a><br /></td></tr>
<tr class="separator:a3d1d65e5dba67ccf5199e5d5544e2484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0edff8be282482211b0cbc6cd022222e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a0edff8be282482211b0cbc6cd022222e">integral_quasi_impsamp</a> (<a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> f, <a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> g, <a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> Ginv, unsigned int N=1000)</td></tr>
<tr class="memdesc:a0edff8be282482211b0cbc6cd022222e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate an integral by using Crude Quasi-Monte Carlo integration with importance sampling, using the Weyl sequence.  <a href="namespacetheoretica.html#a0edff8be282482211b0cbc6cd022222e">More...</a><br /></td></tr>
<tr class="separator:a0edff8be282482211b0cbc6cd022222e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f05663c1a2c0ae0e9fdf9784db4036d"><td class="memTemplParams" colspan="2">template&lt;typename Function , typename VectorType  = std::vector&lt;real&gt;&gt; </td></tr>
<tr class="memitem:a4f05663c1a2c0ae0e9fdf9784db4036d"><td class="memTemplItemLeft" align="right" valign="top">VectorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a4f05663c1a2c0ae0e9fdf9784db4036d">mc_sample</a> (Function f, std::vector&lt; <a class="el" href="structtheoretica_1_1pdf__sampler.html">pdf_sampler</a> &gt; rv, unsigned int N)</td></tr>
<tr class="memdesc:a4f05663c1a2c0ae0e9fdf9784db4036d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a Monte Carlo sample of values of a given function of arbitrary variables following the given distributions.  <a href="namespacetheoretica.html#a4f05663c1a2c0ae0e9fdf9784db4036d">More...</a><br /></td></tr>
<tr class="separator:a4f05663c1a2c0ae0e9fdf9784db4036d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8679d2642c8820e78e33f7aa3294f7eb"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a8679d2642c8820e78e33f7aa3294f7eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a8679d2642c8820e78e33f7aa3294f7eb">shuffle</a> (Vector &amp;v, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g, unsigned int rounds=0)</td></tr>
<tr class="memdesc:a8679d2642c8820e78e33f7aa3294f7eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuffle a set by exchanging random couples of elements.  <a href="namespacetheoretica.html#a8679d2642c8820e78e33f7aa3294f7eb">More...</a><br /></td></tr>
<tr class="separator:a8679d2642c8820e78e33f7aa3294f7eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1025a8b933cfe7077936c4be27971c1"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ab1025a8b933cfe7077936c4be27971c1">rand_congruential</a> (uint64_t x, uint64_t a=48271, uint64_t c=0, uint64_t m=((uint64_t) 1&lt;&lt; 31) - 1)</td></tr>
<tr class="memdesc:ab1025a8b933cfe7077936c4be27971c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Congruential pseudorandom number generation algorithm.  <a href="namespacetheoretica.html#ab1025a8b933cfe7077936c4be27971c1">More...</a><br /></td></tr>
<tr class="separator:ab1025a8b933cfe7077936c4be27971c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a41f7dda7d0ad8cc8a4559afcf2ad7"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a36a41f7dda7d0ad8cc8a4559afcf2ad7">rand_congruential</a> (uint64_t x, std::vector&lt; uint64_t &gt; &amp;state)</td></tr>
<tr class="memdesc:a36a41f7dda7d0ad8cc8a4559afcf2ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Congruential pseudorandom number generation algorithm (wrapper)  <a href="namespacetheoretica.html#a36a41f7dda7d0ad8cc8a4559afcf2ad7">More...</a><br /></td></tr>
<tr class="separator:a36a41f7dda7d0ad8cc8a4559afcf2ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6faedb3d913a589365b108f5ec304e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aed6faedb3d913a589365b108f5ec304e">rand_xoshiro</a> (uint64_t &amp;a, uint64_t &amp;b, uint64_t &amp;c, uint64_t &amp;d)</td></tr>
<tr class="memdesc:aed6faedb3d913a589365b108f5ec304e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Xoshiro256++ pseudorandom number generation algorithm.  <a href="namespacetheoretica.html#aed6faedb3d913a589365b108f5ec304e">More...</a><br /></td></tr>
<tr class="separator:aed6faedb3d913a589365b108f5ec304e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b30362a1d08c8522c5297efd6f4a47"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a13b30362a1d08c8522c5297efd6f4a47">rand_xoshiro</a> (uint64_t x, std::vector&lt; uint64_t &gt; &amp;state)</td></tr>
<tr class="memdesc:a13b30362a1d08c8522c5297efd6f4a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Xoshiro256++ pseudorandom number generation algorithm.  <a href="namespacetheoretica.html#a13b30362a1d08c8522c5297efd6f4a47">More...</a><br /></td></tr>
<tr class="separator:a13b30362a1d08c8522c5297efd6f4a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058181f973ba2744704e6c6211477a35"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a058181f973ba2744704e6c6211477a35">rand_splitmix64</a> (uint64_t x)</td></tr>
<tr class="memdesc:a058181f973ba2744704e6c6211477a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">SplitMix64 pseudorandom number generation.  <a href="namespacetheoretica.html#a058181f973ba2744704e6c6211477a35">More...</a><br /></td></tr>
<tr class="separator:a058181f973ba2744704e6c6211477a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad198dee1300488d1b3e51767d62beedf"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ad198dee1300488d1b3e51767d62beedf">rand_splitmix64</a> (uint64_t x, std::vector&lt; uint64_t &gt; &amp;p)</td></tr>
<tr class="memdesc:ad198dee1300488d1b3e51767d62beedf"><td class="mdescLeft">&#160;</td><td class="mdescRight">SplitMix64 pseudorandom number generation.  <a href="namespacetheoretica.html#ad198dee1300488d1b3e51767d62beedf">More...</a><br /></td></tr>
<tr class="separator:ad198dee1300488d1b3e51767d62beedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470e255aed45a7dba74af4af68b31d0d"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a470e255aed45a7dba74af4af68b31d0d">rand_wyrand</a> (uint64_t &amp;seed, uint64_t p1, uint64_t p2)</td></tr>
<tr class="memdesc:a470e255aed45a7dba74af4af68b31d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wyrand pseudorandom number generation.  <a href="namespacetheoretica.html#a470e255aed45a7dba74af4af68b31d0d">More...</a><br /></td></tr>
<tr class="separator:a470e255aed45a7dba74af4af68b31d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5deb3df62eb53ec187a4660d42d8d5f1"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a5deb3df62eb53ec187a4660d42d8d5f1">rand_wyrand</a> (uint64_t x, std::vector&lt; uint64_t &gt; &amp;p)</td></tr>
<tr class="memdesc:a5deb3df62eb53ec187a4660d42d8d5f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wyrand pseudorandom number generation.  <a href="namespacetheoretica.html#a5deb3df62eb53ec187a4660d42d8d5f1">More...</a><br /></td></tr>
<tr class="separator:a5deb3df62eb53ec187a4660d42d8d5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c6bc4e4c3bc2e859b5ff1e4b344df4"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ab7c6bc4e4c3bc2e859b5ff1e4b344df4">rand_middlesquare</a> (uint64_t seed, uint64_t offset=765872292751861)</td></tr>
<tr class="memdesc:ab7c6bc4e4c3bc2e859b5ff1e4b344df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Middle-square pseudorandom number generation.  <a href="namespacetheoretica.html#ab7c6bc4e4c3bc2e859b5ff1e4b344df4">More...</a><br /></td></tr>
<tr class="separator:ab7c6bc4e4c3bc2e859b5ff1e4b344df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc42228ba03a0f01c33d192ba87766a9"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#abc42228ba03a0f01c33d192ba87766a9">rand_middlesquare</a> (uint64_t x, std::vector&lt; uint64_t &gt; &amp;p)</td></tr>
<tr class="memdesc:abc42228ba03a0f01c33d192ba87766a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Middle-square pseudorandom number generation.  <a href="namespacetheoretica.html#abc42228ba03a0f01c33d192ba87766a9">More...</a><br /></td></tr>
<tr class="separator:abc42228ba03a0f01c33d192ba87766a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e523c1cc3621e7cbc1ac0df01913c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa7e523c1cc3621e7cbc1ac0df01913c3">qrand_weyl</a> (unsigned int n, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> alpha=<a class="el" href="namespacetheoretica.html#a6a6de16e5ee81d340ff91dbadb99edde">INVPHI</a>)</td></tr>
<tr class="memdesc:aa7e523c1cc3621e7cbc1ac0df01913c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weyl quasi-random sequence.  <a href="namespacetheoretica.html#aa7e523c1cc3621e7cbc1ac0df01913c3">More...</a><br /></td></tr>
<tr class="separator:aa7e523c1cc3621e7cbc1ac0df01913c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5001951408c716ce4e6414cc45f420"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a6c5001951408c716ce4e6414cc45f420">qrand_weyl_recurr</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> prev=0, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> alpha=<a class="el" href="namespacetheoretica.html#a6a6de16e5ee81d340ff91dbadb99edde">INVPHI</a>)</td></tr>
<tr class="memdesc:a6c5001951408c716ce4e6414cc45f420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weyl quasi-random sequence (computed with recurrence relation)  <a href="namespacetheoretica.html#a6c5001951408c716ce4e6414cc45f420">More...</a><br /></td></tr>
<tr class="separator:a6c5001951408c716ce4e6414cc45f420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216195a1bbd4fed54c50cce034e48bfa"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a216195a1bbd4fed54c50cce034e48bfa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a216195a1bbd4fed54c50cce034e48bfa">qrand_weyl_multi</a> (unsigned int n, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> alpha)</td></tr>
<tr class="memdesc:a216195a1bbd4fed54c50cce034e48bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weyl quasi-random sequence in N dimensions.  <a href="namespacetheoretica.html#a216195a1bbd4fed54c50cce034e48bfa">More...</a><br /></td></tr>
<tr class="separator:a216195a1bbd4fed54c50cce034e48bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d4be50bf77c6b368c94bb627305224"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a1f21bd68ba64b172c29d9fce15c8712d">vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ac1d4be50bf77c6b368c94bb627305224">qrand_weyl2</a> (unsigned int n, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> alpha=0.7548776662466927)</td></tr>
<tr class="memdesc:ac1d4be50bf77c6b368c94bb627305224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weyl quasi-random sequence in 2 dimensions.  <a href="namespacetheoretica.html#ac1d4be50bf77c6b368c94bb627305224">More...</a><br /></td></tr>
<tr class="separator:ac1d4be50bf77c6b368c94bb627305224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a35e29644875a5421b3ac4d7203c28a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a6a35e29644875a5421b3ac4d7203c28a">rand_uniform</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g, uint64_t prec=<a class="el" href="namespacetheoretica.html#a0e48eab9ce5928d0c754a40ddb2d068f">RAND_REAL_PREC</a>)</td></tr>
<tr class="memdesc:a6a35e29644875a5421b3ac4d7203c28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a pseudorandom real number in [a, b] using a preexisting generator.  <a href="namespacetheoretica.html#a6a35e29644875a5421b3ac4d7203c28a">More...</a><br /></td></tr>
<tr class="separator:a6a35e29644875a5421b3ac4d7203c28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e77a1836e1b966cdbb0934d5ebbbf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ad7e77a1836e1b966cdbb0934d5ebbbf2">rand_uniform</a> (const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;theta, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:ad7e77a1836e1b966cdbb0934d5ebbbf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for rand_uniform(real, real, PRNG)  <a href="namespacetheoretica.html#ad7e77a1836e1b966cdbb0934d5ebbbf2">More...</a><br /></td></tr>
<tr class="separator:ad7e77a1836e1b966cdbb0934d5ebbbf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ddd9fc13f4c8b28ea4025640cbadf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a99ddd9fc13f4c8b28ea4025640cbadf4">rand_cointoss</a> (<a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a99ddd9fc13f4c8b28ea4025640cbadf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coin toss random generator.  <a href="namespacetheoretica.html#a99ddd9fc13f4c8b28ea4025640cbadf4">More...</a><br /></td></tr>
<tr class="separator:a99ddd9fc13f4c8b28ea4025640cbadf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada12d3bc9842b85e97e14f0eb975e132"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ada12d3bc9842b85e97e14f0eb975e132">rand_cointoss</a> (const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;theta, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:ada12d3bc9842b85e97e14f0eb975e132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for rand_cointoss(PRNG)  <a href="namespacetheoretica.html#ada12d3bc9842b85e97e14f0eb975e132">More...</a><br /></td></tr>
<tr class="separator:ada12d3bc9842b85e97e14f0eb975e132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968bc8465bcb421983d457b96469e9ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a968bc8465bcb421983d457b96469e9ef">rand_diceroll</a> (unsigned int faces, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a968bc8465bcb421983d457b96469e9ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dice roll random generator.  <a href="namespacetheoretica.html#a968bc8465bcb421983d457b96469e9ef">More...</a><br /></td></tr>
<tr class="separator:a968bc8465bcb421983d457b96469e9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709a55686cbd545429284beb16eef7b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a709a55686cbd545429284beb16eef7b7">rand_diceroll</a> (const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;theta, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a709a55686cbd545429284beb16eef7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for rand_diceroll(PRNG)  <a href="namespacetheoretica.html#a709a55686cbd545429284beb16eef7b7">More...</a><br /></td></tr>
<tr class="separator:a709a55686cbd545429284beb16eef7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39df0b112f893ca611b133774bcc76b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a39df0b112f893ca611b133774bcc76b8">rand_trycatch</a> (<a class="el" href="namespacetheoretica.html#ac7a0bafb035970e4921b84f75661e2b1">stat_function</a> f, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;theta, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x1, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> y1, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> y2, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#a3299f783527ae72a24c832a7b1cd8ef8">MAX_TRYANDCATCH_ITER</a>)</td></tr>
<tr class="memdesc:a39df0b112f893ca611b133774bcc76b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a pseudorandom value following any probability distribution function using the Try-and-Catch (rejection) algorithm.  <a href="namespacetheoretica.html#a39df0b112f893ca611b133774bcc76b8">More...</a><br /></td></tr>
<tr class="separator:a39df0b112f893ca611b133774bcc76b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e708ed0859828011f0d262c93274ec3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a7e708ed0859828011f0d262c93274ec3">rand_rejectsamp</a> (<a class="el" href="namespacetheoretica.html#ac7a0bafb035970e4921b84f75661e2b1">stat_function</a> f, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;theta, <a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> p, <a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> Pinv, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g, unsigned int max_tries=100)</td></tr>
<tr class="memdesc:a7e708ed0859828011f0d262c93274ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number following any given distribution using rejection sampling.  <a href="namespacetheoretica.html#a7e708ed0859828011f0d262c93274ec3">More...</a><br /></td></tr>
<tr class="separator:a7e708ed0859828011f0d262c93274ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bdf0dc89459fedaf6950c0f9b96df5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ac8bdf0dc89459fedaf6950c0f9b96df5">rand_gaussian_polar</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> <a class="el" href="namespacetheoretica.html#ae3bb9ab9b5d37b364981e1082f93e587">mean</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> sigma, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:ac8bdf0dc89459fedaf6950c0f9b96df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number following a Gaussian distribution using Marsaglia's polar method.  <a href="namespacetheoretica.html#ac8bdf0dc89459fedaf6950c0f9b96df5">More...</a><br /></td></tr>
<tr class="separator:ac8bdf0dc89459fedaf6950c0f9b96df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d0c9531b268c00e759cb571422e01f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a91d0c9531b268c00e759cb571422e01f">rand_gaussian_boxmuller</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> <a class="el" href="namespacetheoretica.html#ae3bb9ab9b5d37b364981e1082f93e587">mean</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> sigma, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a91d0c9531b268c00e759cb571422e01f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number following a Gaussian distribution using the Box-Muller method.  <a href="namespacetheoretica.html#a91d0c9531b268c00e759cb571422e01f">More...</a><br /></td></tr>
<tr class="separator:a91d0c9531b268c00e759cb571422e01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c36b22d9b1f9f2beeab1c7be35fe8b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a8c36b22d9b1f9f2beeab1c7be35fe8b3">rand_gaussian_clt</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> <a class="el" href="namespacetheoretica.html#ae3bb9ab9b5d37b364981e1082f93e587">mean</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> sigma, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a8c36b22d9b1f9f2beeab1c7be35fe8b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number in a range following a Gaussian distribution by exploiting the Central Limit Theorem.  <a href="namespacetheoretica.html#a8c36b22d9b1f9f2beeab1c7be35fe8b3">More...</a><br /></td></tr>
<tr class="separator:a8c36b22d9b1f9f2beeab1c7be35fe8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b8d1fc98c8429d4b342e860cab6ed1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#af2b8d1fc98c8429d4b342e860cab6ed1">rand_gaussian_clt</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> <a class="el" href="namespacetheoretica.html#ae3bb9ab9b5d37b364981e1082f93e587">mean</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> sigma, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g, unsigned int N)</td></tr>
<tr class="memdesc:af2b8d1fc98c8429d4b342e860cab6ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number in a range following a Gaussian distribution by exploiting the Central Limit Theorem.  <a href="namespacetheoretica.html#af2b8d1fc98c8429d4b342e860cab6ed1">More...</a><br /></td></tr>
<tr class="separator:af2b8d1fc98c8429d4b342e860cab6ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856e584fd661d664a36cb185c8abd6ba"><td class="memItemLeft" align="right" valign="top"><a id="a856e584fd661d664a36cb185c8abd6ba" name="a856e584fd661d664a36cb185c8abd6ba"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rand_gaussian</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> <a class="el" href="namespacetheoretica.html#ae3bb9ab9b5d37b364981e1082f93e587">mean</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> sigma, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a856e584fd661d664a36cb185c8abd6ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number following a Gaussian distribution using the best available algorithm. <br /></td></tr>
<tr class="separator:a856e584fd661d664a36cb185c8abd6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2c1865b7a5639ed82643a069554e3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aad2c1865b7a5639ed82643a069554e3d">rand_gaussian</a> (const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;theta, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:aad2c1865b7a5639ed82643a069554e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for rand_gaussian(real, real, PRNG)  <a href="namespacetheoretica.html#aad2c1865b7a5639ed82643a069554e3d">More...</a><br /></td></tr>
<tr class="separator:aad2c1865b7a5639ed82643a069554e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fc6d88e78808dfe4a4bbb03798a754"><td class="memItemLeft" align="right" valign="top"><a id="a40fc6d88e78808dfe4a4bbb03798a754" name="a40fc6d88e78808dfe4a4bbb03798a754"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rand_exponential</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> lambda, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a40fc6d88e78808dfe4a4bbb03798a754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number following an exponential distribution using the quantile (inverse) function method. <br /></td></tr>
<tr class="separator:a40fc6d88e78808dfe4a4bbb03798a754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e6165f6c783179d1b3c2e321b3e7d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa2e6165f6c783179d1b3c2e321b3e7d4">rand_exponential</a> (const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;theta, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:aa2e6165f6c783179d1b3c2e321b3e7d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for rand_exponential(real, PRNG)  <a href="namespacetheoretica.html#aa2e6165f6c783179d1b3c2e321b3e7d4">More...</a><br /></td></tr>
<tr class="separator:aa2e6165f6c783179d1b3c2e321b3e7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c93a1f60698d75caa21a305e2ba107"><td class="memItemLeft" align="right" valign="top"><a id="a55c93a1f60698d75caa21a305e2ba107" name="a55c93a1f60698d75caa21a305e2ba107"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rand_rayleigh</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> sigma, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a55c93a1f60698d75caa21a305e2ba107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number following a Rayleigh distribution using the quantile (inverse) function method. <br /></td></tr>
<tr class="separator:a55c93a1f60698d75caa21a305e2ba107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012d14c9ef85d6f3028bf8ceb1008787"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a012d14c9ef85d6f3028bf8ceb1008787">rand_rayleigh</a> (const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;theta, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a012d14c9ef85d6f3028bf8ceb1008787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for rand_rayleigh(real, PRNG)  <a href="namespacetheoretica.html#a012d14c9ef85d6f3028bf8ceb1008787">More...</a><br /></td></tr>
<tr class="separator:a012d14c9ef85d6f3028bf8ceb1008787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34a4b6660c0287dc6dfa979a2f83002"><td class="memItemLeft" align="right" valign="top"><a id="ac34a4b6660c0287dc6dfa979a2f83002" name="ac34a4b6660c0287dc6dfa979a2f83002"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rand_cauchy</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> mu, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> alpha, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:ac34a4b6660c0287dc6dfa979a2f83002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number following a Cauchy distribution using the quantile (inverse) function method. <br /></td></tr>
<tr class="separator:ac34a4b6660c0287dc6dfa979a2f83002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473df88a9edd9ccc8dcf03665591575b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a473df88a9edd9ccc8dcf03665591575b">rand_cauchy</a> (const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;theta, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a473df88a9edd9ccc8dcf03665591575b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for rand_cauchy(real, real, PRNG)  <a href="namespacetheoretica.html#a473df88a9edd9ccc8dcf03665591575b">More...</a><br /></td></tr>
<tr class="separator:a473df88a9edd9ccc8dcf03665591575b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01522152b1ccfd9a7db77654b6d8c12a"><td class="memItemLeft" align="right" valign="top"><a id="a01522152b1ccfd9a7db77654b6d8c12a" name="a01522152b1ccfd9a7db77654b6d8c12a"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rand_laplace</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> mu, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a01522152b1ccfd9a7db77654b6d8c12a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number following a Laplace distribution using the quantile (inverse) function method. <br /></td></tr>
<tr class="separator:a01522152b1ccfd9a7db77654b6d8c12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441cea1ebea409b2deb0ba387febc626"><td class="memItemLeft" align="right" valign="top"><a id="a441cea1ebea409b2deb0ba387febc626" name="a441cea1ebea409b2deb0ba387febc626"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rand_laplace</b> (const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;theta, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a441cea1ebea409b2deb0ba387febc626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number following a Laplace distribution using the quantile (inverse) function method. <br /></td></tr>
<tr class="separator:a441cea1ebea409b2deb0ba387febc626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b34801047d52afccf3b4120c3d2d74e"><td class="memItemLeft" align="right" valign="top"><a id="a2b34801047d52afccf3b4120c3d2d74e" name="a2b34801047d52afccf3b4120c3d2d74e"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rand_pareto</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x_m, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> alpha, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a2b34801047d52afccf3b4120c3d2d74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number following a Pareto distribution using the quantile (inverse) function method. <br /></td></tr>
<tr class="separator:a2b34801047d52afccf3b4120c3d2d74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66a655f57ef0f6e436dfc03e800585b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ae66a655f57ef0f6e436dfc03e800585b">rand_pareto</a> (const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;theta, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:ae66a655f57ef0f6e436dfc03e800585b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for rand_pareto(real, real, PRNG)  <a href="namespacetheoretica.html#ae66a655f57ef0f6e436dfc03e800585b">More...</a><br /></td></tr>
<tr class="separator:ae66a655f57ef0f6e436dfc03e800585b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b235e6e95449fbb28f562c110f6aa3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa4b235e6e95449fbb28f562c110f6aa3">metropolis</a> (<a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> pdf, <a class="el" href="structtheoretica_1_1pdf__sampler.html">pdf_sampler</a> &amp;g, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x0, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;rnd, unsigned int depth=<a class="el" href="namespacetheoretica.html#a1ad823e40ceef73bd9114b0a05e6cd5f">METROPOLIS_DEPTH</a>)</td></tr>
<tr class="memdesc:aa4b235e6e95449fbb28f562c110f6aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metropolis algorithm for distribution sampling using a symmetric proposal distribution.  <a href="namespacetheoretica.html#aa4b235e6e95449fbb28f562c110f6aa3">More...</a><br /></td></tr>
<tr class="separator:aa4b235e6e95449fbb28f562c110f6aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171a1939d723ba99bf4e4905728df701"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a171a1939d723ba99bf4e4905728df701">metropolis</a> (<a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> pdf, <a class="el" href="structtheoretica_1_1pdf__sampler.html">pdf_sampler</a> &amp;g, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x0, unsigned int depth=<a class="el" href="namespacetheoretica.html#a1ad823e40ceef73bd9114b0a05e6cd5f">METROPOLIS_DEPTH</a>)</td></tr>
<tr class="memdesc:a171a1939d723ba99bf4e4905728df701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metropolis algorithm for distribution sampling using a symmetric proposal distribution.  <a href="namespacetheoretica.html#a171a1939d723ba99bf4e4905728df701">More...</a><br /></td></tr>
<tr class="separator:a171a1939d723ba99bf4e4905728df701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec5b6f456b010a5af7f3bce105cdea4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#afec5b6f456b010a5af7f3bce105cdea4">likelihood</a> (const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;X, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;theta, <a class="el" href="namespacetheoretica.html#ac7a0bafb035970e4921b84f75661e2b1">stat_function</a> f)</td></tr>
<tr class="memdesc:afec5b6f456b010a5af7f3bce105cdea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the likelihood of a distribution &lt;f&gt; with the given parameters &lt;theta&gt; and measures &lt;X&gt;  <a href="namespacetheoretica.html#afec5b6f456b010a5af7f3bce105cdea4">More...</a><br /></td></tr>
<tr class="separator:afec5b6f456b010a5af7f3bce105cdea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e07a8227cf85be04e9554ea103854e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a7e07a8227cf85be04e9554ea103854e7">log_likelihood</a> (const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;X, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;theta, <a class="el" href="namespacetheoretica.html#ac7a0bafb035970e4921b84f75661e2b1">stat_function</a> f)</td></tr>
<tr class="memdesc:a7e07a8227cf85be04e9554ea103854e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the log likelihood of a distribution &lt;f&gt; with the given parameters &lt;theta&gt; and measures &lt;X&gt;  <a href="namespacetheoretica.html#a7e07a8227cf85be04e9554ea103854e7">More...</a><br /></td></tr>
<tr class="separator:a7e07a8227cf85be04e9554ea103854e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97fe53c636243acf273bfb04ebc91ec"><td class="memTemplParams" colspan="2">template&lt;typename Matrix  = mat&lt;real&gt;, typename Dataset  = vec&lt;real&gt;&gt; </td></tr>
<tr class="memitem:ac97fe53c636243acf273bfb04ebc91ec"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ac97fe53c636243acf273bfb04ebc91ec">covar_mat</a> (const std::vector&lt; Dataset &gt; &amp;v)</td></tr>
<tr class="memdesc:ac97fe53c636243acf273bfb04ebc91ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the covariance matrix given a vector of datasets by computing the covariance between all couples of sets.  <a href="namespacetheoretica.html#ac97fe53c636243acf273bfb04ebc91ec">More...</a><br /></td></tr>
<tr class="separator:ac97fe53c636243acf273bfb04ebc91ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c65d8d1f18eeaed2e6cb96b8138ec7"><td class="memTemplParams" colspan="2">template&lt;unsigned int N = 0, typename MultiDualFunction  = d_real&lt;N&gt;(*)(d_vec&lt;N&gt;)&gt; </td></tr>
<tr class="memitem:a13c65d8d1f18eeaed2e6cb96b8138ec7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a13c65d8d1f18eeaed2e6cb96b8138ec7">error_propagation</a> (MultiDualFunction f, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;x_best, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;delta_x)</td></tr>
<tr class="memdesc:a13c65d8d1f18eeaed2e6cb96b8138ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically propagate uncertainties under quadrature on an arbitrary function given the uncertainties on the variables, the mean values of the variables and the function itself, by using automatic differentiation.  <a href="namespacetheoretica.html#a13c65d8d1f18eeaed2e6cb96b8138ec7">More...</a><br /></td></tr>
<tr class="separator:a13c65d8d1f18eeaed2e6cb96b8138ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78365ecc6d0b73192e64e501895a0f85"><td class="memTemplParams" colspan="2">template&lt;unsigned int N = 0, unsigned int M = 0, typename MultiDualFunction  = d_real&lt;N&gt;(*)(d_vec&lt;N&gt;)&gt; </td></tr>
<tr class="memitem:a78365ecc6d0b73192e64e501895a0f85"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a78365ecc6d0b73192e64e501895a0f85">error_propagation</a> (MultiDualFunction f, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;x_best, const <a class="el" href="classtheoretica_1_1mat.html">mat</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, M, M &gt; &amp;cm)</td></tr>
<tr class="memdesc:a78365ecc6d0b73192e64e501895a0f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically propagate uncertainties under quadrature on an arbitrary function given the uncertainties on the variables, the mean values of the variables and the function itself, by using automatic differentiation.  <a href="namespacetheoretica.html#a78365ecc6d0b73192e64e501895a0f85">More...</a><br /></td></tr>
<tr class="separator:a78365ecc6d0b73192e64e501895a0f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d84edd693f12451e609e365239533cc"><td class="memTemplParams" colspan="2">template&lt;unsigned int N = 0, typename MultiDualFunction  = multidual&lt;N&gt;(*)(vec&lt;multidual&lt;N&gt;, N&gt;), typename Dataset  = vec&lt;real, N&gt;&gt; </td></tr>
<tr class="memitem:a2d84edd693f12451e609e365239533cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a2d84edd693f12451e609e365239533cc">error_propagation</a> (MultiDualFunction f, const std::vector&lt; Dataset &gt; &amp;v)</td></tr>
<tr class="memdesc:a2d84edd693f12451e609e365239533cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically propagate uncertainties under quadrature on an arbitrary function given the function and the set of measured data.  <a href="namespacetheoretica.html#a2d84edd693f12451e609e365239533cc">More...</a><br /></td></tr>
<tr class="separator:a2d84edd693f12451e609e365239533cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6e93b355b93426144ceb0f7b435ac3"><td class="memTemplParams" colspan="2">template&lt;typename Function &gt; </td></tr>
<tr class="memitem:adf6e93b355b93426144ceb0f7b435ac3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#adf6e93b355b93426144ceb0f7b435ac3">mc_error_propagation</a> (Function f, std::vector&lt; <a class="el" href="structtheoretica_1_1pdf__sampler.html">pdf_sampler</a> &gt; rv, unsigned int N=1<a class="el" href="namespacetheoretica.html#aa3c0a5082e6b4428b15b7b02d16eafc7">E</a>+6)</td></tr>
<tr class="memdesc:adf6e93b355b93426144ceb0f7b435ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate the statistical error on a given function using the Monte Carlo method, by generating a sample following the probability distribution of the function and computing its standard deviation.  <a href="namespacetheoretica.html#adf6e93b355b93426144ceb0f7b435ac3">More...</a><br /></td></tr>
<tr class="separator:adf6e93b355b93426144ceb0f7b435ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1191a32286f176c367f648431b1444ac"><td class="memTemplParams" colspan="2"><a id="a1191a32286f176c367f648431b1444ac" name="a1191a32286f176c367f648431b1444ac"></a>
template&lt;typename Dataset &gt; </td></tr>
<tr class="memitem:a1191a32286f176c367f648431b1444ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>arithmetic_mean</b> (const Dataset &amp;data)</td></tr>
<tr class="memdesc:a1191a32286f176c367f648431b1444ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arithmetic mean of a set of values. <br /></td></tr>
<tr class="separator:a1191a32286f176c367f648431b1444ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3bb9ab9b5d37b364981e1082f93e587"><td class="memTemplParams" colspan="2"><a id="ae3bb9ab9b5d37b364981e1082f93e587" name="ae3bb9ab9b5d37b364981e1082f93e587"></a>
template&lt;typename Dataset &gt; </td></tr>
<tr class="memitem:ae3bb9ab9b5d37b364981e1082f93e587"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mean</b> (const Dataset &amp;data)</td></tr>
<tr class="memdesc:ae3bb9ab9b5d37b364981e1082f93e587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arithmetic mean of a set of values Alias for arithmetic_mean. <br /></td></tr>
<tr class="separator:ae3bb9ab9b5d37b364981e1082f93e587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1638fb86d8cb03965ff398d41f7b00fb"><td class="memTemplParams" colspan="2"><a id="a1638fb86d8cb03965ff398d41f7b00fb" name="a1638fb86d8cb03965ff398d41f7b00fb"></a>
template&lt;typename Dataset &gt; </td></tr>
<tr class="memitem:a1638fb86d8cb03965ff398d41f7b00fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>harmonic_mean</b> (const Dataset &amp;data)</td></tr>
<tr class="memdesc:a1638fb86d8cb03965ff398d41f7b00fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the harmonic mean of a set of values. <br /></td></tr>
<tr class="separator:a1638fb86d8cb03965ff398d41f7b00fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c73eaa2f2276a66b309426cc308d1b"><td class="memTemplParams" colspan="2"><a id="a73c73eaa2f2276a66b309426cc308d1b" name="a73c73eaa2f2276a66b309426cc308d1b"></a>
template&lt;typename Dataset &gt; </td></tr>
<tr class="memitem:a73c73eaa2f2276a66b309426cc308d1b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>geometric_mean</b> (const Dataset &amp;data)</td></tr>
<tr class="memdesc:a73c73eaa2f2276a66b309426cc308d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the geometric mean of a set of values as \(\sqrt[n]{\Pi_i x_i}\). <br /></td></tr>
<tr class="separator:a73c73eaa2f2276a66b309426cc308d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8a4b7178a8558fc4ba3ab3b9b3f926"><td class="memTemplParams" colspan="2"><a id="a0e8a4b7178a8558fc4ba3ab3b9b3f926" name="a0e8a4b7178a8558fc4ba3ab3b9b3f926"></a>
template&lt;typename Dataset1 , typename Dataset2 &gt; </td></tr>
<tr class="memitem:a0e8a4b7178a8558fc4ba3ab3b9b3f926"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>weighted_mean</b> (const Dataset1 &amp;data, const Dataset2 &amp;weights)</td></tr>
<tr class="memdesc:a0e8a4b7178a8558fc4ba3ab3b9b3f926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the weighted mean of a set of values &lt;data&gt; and &lt;weights&gt; must have the same size. <br /></td></tr>
<tr class="separator:a0e8a4b7178a8558fc4ba3ab3b9b3f926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9473c3dfdbe71e408fb3241d458254c0"><td class="memTemplParams" colspan="2"><a id="a9473c3dfdbe71e408fb3241d458254c0" name="a9473c3dfdbe71e408fb3241d458254c0"></a>
template&lt;typename Dataset &gt; </td></tr>
<tr class="memitem:a9473c3dfdbe71e408fb3241d458254c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>quadratic_mean</b> (const Dataset &amp;data)</td></tr>
<tr class="memdesc:a9473c3dfdbe71e408fb3241d458254c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the quadratic mean (Root Mean Square) of a set of values \(m_q = \sqrt{x1^2 + x2^2 + ...}\). <br /></td></tr>
<tr class="separator:a9473c3dfdbe71e408fb3241d458254c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d4ff06b43d112a71509f9798619dcd"><td class="memTemplParams" colspan="2">template&lt;typename Dataset &gt; </td></tr>
<tr class="memitem:a11d4ff06b43d112a71509f9798619dcd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a11d4ff06b43d112a71509f9798619dcd">rms</a> (const Dataset &amp;data)</td></tr>
<tr class="memdesc:a11d4ff06b43d112a71509f9798619dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the quadratic mean (Root Mean Square) of a set of values \(m_q = \sqrt{x_1^2 + x_2^2 + ...}\).  <a href="namespacetheoretica.html#a11d4ff06b43d112a71509f9798619dcd">More...</a><br /></td></tr>
<tr class="separator:a11d4ff06b43d112a71509f9798619dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f63944f2a89b87b85edfdb3f9dccae"><td class="memTemplParams" colspan="2"><a id="a61f63944f2a89b87b85edfdb3f9dccae" name="a61f63944f2a89b87b85edfdb3f9dccae"></a>
template&lt;typename Dataset &gt; </td></tr>
<tr class="memitem:a61f63944f2a89b87b85edfdb3f9dccae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>range</b> (const Dataset &amp;data)</td></tr>
<tr class="memdesc:a61f63944f2a89b87b85edfdb3f9dccae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the range of a data set defined as \(x_{max} - {x_min}\). <br /></td></tr>
<tr class="separator:a61f63944f2a89b87b85edfdb3f9dccae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d79ef7ca93743bde1109c00313db4a1"><td class="memTemplParams" colspan="2"><a id="a0d79ef7ca93743bde1109c00313db4a1" name="a0d79ef7ca93743bde1109c00313db4a1"></a>
template&lt;typename Dataset &gt; </td></tr>
<tr class="memitem:a0d79ef7ca93743bde1109c00313db4a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>semidispersion</b> (const Dataset &amp;data)</td></tr>
<tr class="memdesc:a0d79ef7ca93743bde1109c00313db4a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum semidispersion of a data set defined as \((x_{max} - {x_min}) / 2\). <br /></td></tr>
<tr class="separator:a0d79ef7ca93743bde1109c00313db4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43654deea871dfb60779ae5e8b7c44ca"><td class="memTemplParams" colspan="2"><a id="a43654deea871dfb60779ae5e8b7c44ca" name="a43654deea871dfb60779ae5e8b7c44ca"></a>
template&lt;typename Dataset &gt; </td></tr>
<tr class="memitem:a43654deea871dfb60779ae5e8b7c44ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>propagate_sum</b> (const Dataset &amp;sigma)</td></tr>
<tr class="memdesc:a43654deea871dfb60779ae5e8b7c44ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate error of a sum of values as sqrt(sigma_x^2 + sigma_y^2 + ...) <br /></td></tr>
<tr class="separator:a43654deea871dfb60779ae5e8b7c44ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621c79bbdd5545018e1e941a652c739e"><td class="memTemplParams" colspan="2"><a id="a621c79bbdd5545018e1e941a652c739e" name="a621c79bbdd5545018e1e941a652c739e"></a>
template&lt;typename Dataset1 , typename Dataset2 &gt; </td></tr>
<tr class="memitem:a621c79bbdd5545018e1e941a652c739e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>propagate_product</b> (const Dataset1 &amp;sigma, const Dataset2 &amp;<a class="el" href="namespacetheoretica.html#ae3bb9ab9b5d37b364981e1082f93e587">mean</a>)</td></tr>
<tr class="memdesc:a621c79bbdd5545018e1e941a652c739e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate error of a product (or quotient) of values as \(\sqrt{(sigma_x / x_{mean})^2 + (sigma_y / y_{mean})^2 + ...}\) The result is the propagated relative error. <br /></td></tr>
<tr class="separator:a621c79bbdd5545018e1e941a652c739e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaccd3a2b293f4d080b5fa2655ed89d7a"><td class="memTemplParams" colspan="2"><a id="aaccd3a2b293f4d080b5fa2655ed89d7a" name="aaccd3a2b293f4d080b5fa2655ed89d7a"></a>
template&lt;typename Dataset &gt; </td></tr>
<tr class="memitem:aaccd3a2b293f4d080b5fa2655ed89d7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>total_sum_squares</b> (const Dataset &amp;X)</td></tr>
<tr class="memdesc:aaccd3a2b293f4d080b5fa2655ed89d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total sum of squares (TSS) equal to \(sum(square(x_i - x_{mean}))\), computed using Welford's one-pass method to improve numerical stability. <br /></td></tr>
<tr class="separator:aaccd3a2b293f4d080b5fa2655ed89d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c492643bae592a0e15d4d54aca8a5c"><td class="memTemplParams" colspan="2">template&lt;typename Dataset &gt; </td></tr>
<tr class="memitem:ad8c492643bae592a0e15d4d54aca8a5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ad8c492643bae592a0e15d4d54aca8a5c">tss</a> (const Dataset &amp;X)</td></tr>
<tr class="memdesc:ad8c492643bae592a0e15d4d54aca8a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total sum of squares (TSS) Computed as \(\sum_i^n (x_i - x_{mean})^2 \).  <a href="namespacetheoretica.html#ad8c492643bae592a0e15d4d54aca8a5c">More...</a><br /></td></tr>
<tr class="separator:ad8c492643bae592a0e15d4d54aca8a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa049e1fe6c0203b5ad31c6c28b618c"><td class="memTemplParams" colspan="2"><a id="a8aa049e1fe6c0203b5ad31c6c28b618c" name="a8aa049e1fe6c0203b5ad31c6c28b618c"></a>
template&lt;typename Dataset &gt; </td></tr>
<tr class="memitem:a8aa049e1fe6c0203b5ad31c6c28b618c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>variance</b> (const Dataset &amp;data)</td></tr>
<tr class="memdesc:a8aa049e1fe6c0203b5ad31c6c28b618c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the variance of a population. <br /></td></tr>
<tr class="separator:a8aa049e1fe6c0203b5ad31c6c28b618c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297ae9e3203f03cecf832bc5aa8d0235"><td class="memTemplParams" colspan="2"><a id="a297ae9e3203f03cecf832bc5aa8d0235" name="a297ae9e3203f03cecf832bc5aa8d0235"></a>
template&lt;typename Dataset &gt; </td></tr>
<tr class="memitem:a297ae9e3203f03cecf832bc5aa8d0235"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sample_variance</b> (const Dataset &amp;data)</td></tr>
<tr class="memdesc:a297ae9e3203f03cecf832bc5aa8d0235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the variance of a sample This function uses Bessel correction. <br /></td></tr>
<tr class="separator:a297ae9e3203f03cecf832bc5aa8d0235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5027a1bac6fae59b3fdff60dfeb4790b"><td class="memTemplParams" colspan="2"><a id="a5027a1bac6fae59b3fdff60dfeb4790b" name="a5027a1bac6fae59b3fdff60dfeb4790b"></a>
template&lt;typename Dataset &gt; </td></tr>
<tr class="memitem:a5027a1bac6fae59b3fdff60dfeb4790b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>standard_deviation</b> (const Dataset &amp;data)</td></tr>
<tr class="memdesc:a5027a1bac6fae59b3fdff60dfeb4790b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the standard deviation of a population. <br /></td></tr>
<tr class="separator:a5027a1bac6fae59b3fdff60dfeb4790b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b6a6c7688b2c99f4cf73aaec774e82"><td class="memTemplParams" colspan="2"><a id="a88b6a6c7688b2c99f4cf73aaec774e82" name="a88b6a6c7688b2c99f4cf73aaec774e82"></a>
template&lt;typename Dataset &gt; </td></tr>
<tr class="memitem:a88b6a6c7688b2c99f4cf73aaec774e82"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>stdev</b> (const Dataset &amp;data)</td></tr>
<tr class="memdesc:a88b6a6c7688b2c99f4cf73aaec774e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the standard deviation of a population. <br /></td></tr>
<tr class="separator:a88b6a6c7688b2c99f4cf73aaec774e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269a687c255334dca83c41dc57e342ed"><td class="memTemplParams" colspan="2"><a id="a269a687c255334dca83c41dc57e342ed" name="a269a687c255334dca83c41dc57e342ed"></a>
template&lt;typename Dataset &gt; </td></tr>
<tr class="memitem:a269a687c255334dca83c41dc57e342ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sample_standard_deviation</b> (const Dataset &amp;data)</td></tr>
<tr class="memdesc:a269a687c255334dca83c41dc57e342ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the standard deviation of a sample. <br /></td></tr>
<tr class="separator:a269a687c255334dca83c41dc57e342ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72301cabd20838f16f2cd3673aea8bb"><td class="memTemplParams" colspan="2"><a id="ab72301cabd20838f16f2cd3673aea8bb" name="ab72301cabd20838f16f2cd3673aea8bb"></a>
template&lt;typename Dataset &gt; </td></tr>
<tr class="memitem:ab72301cabd20838f16f2cd3673aea8bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>smpl_stdev</b> (const Dataset &amp;data)</td></tr>
<tr class="memdesc:ab72301cabd20838f16f2cd3673aea8bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the standard deviation of a sample. <br /></td></tr>
<tr class="separator:ab72301cabd20838f16f2cd3673aea8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85f34eb806e24ad9b27198d8296f9c6"><td class="memTemplParams" colspan="2"><a id="ad85f34eb806e24ad9b27198d8296f9c6" name="ad85f34eb806e24ad9b27198d8296f9c6"></a>
template&lt;typename Dataset &gt; </td></tr>
<tr class="memitem:ad85f34eb806e24ad9b27198d8296f9c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>standard_relative_error</b> (const Dataset &amp;X)</td></tr>
<tr class="memdesc:ad85f34eb806e24ad9b27198d8296f9c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the relative error on a population measure using standard deviation. <br /></td></tr>
<tr class="separator:ad85f34eb806e24ad9b27198d8296f9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f97972afc109f647fb453740ac5588b"><td class="memTemplParams" colspan="2"><a id="a0f97972afc109f647fb453740ac5588b" name="a0f97972afc109f647fb453740ac5588b"></a>
template&lt;typename Dataset &gt; </td></tr>
<tr class="memitem:a0f97972afc109f647fb453740ac5588b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sample_standard_relative_error</b> (const Dataset &amp;X)</td></tr>
<tr class="memdesc:a0f97972afc109f647fb453740ac5588b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the relative error on a sample measure using standard deviation. <br /></td></tr>
<tr class="separator:a0f97972afc109f647fb453740ac5588b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5edf19e377a1eca716693d9ff7b3cb35"><td class="memTemplParams" colspan="2"><a id="a5edf19e377a1eca716693d9ff7b3cb35" name="a5edf19e377a1eca716693d9ff7b3cb35"></a>
template&lt;typename Dataset &gt; </td></tr>
<tr class="memitem:a5edf19e377a1eca716693d9ff7b3cb35"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mean_standard_deviation</b> (const Dataset &amp;data)</td></tr>
<tr class="memdesc:a5edf19e377a1eca716693d9ff7b3cb35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the standard deviation on the mean of a set of values. <br /></td></tr>
<tr class="separator:a5edf19e377a1eca716693d9ff7b3cb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7002b34046d5ca42715a875c6b089f"><td class="memTemplParams" colspan="2"><a id="acb7002b34046d5ca42715a875c6b089f" name="acb7002b34046d5ca42715a875c6b089f"></a>
template&lt;typename Dataset &gt; </td></tr>
<tr class="memitem:acb7002b34046d5ca42715a875c6b089f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>stdom</b> (const Dataset &amp;data)</td></tr>
<tr class="memdesc:acb7002b34046d5ca42715a875c6b089f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the standard deviation on the mean of a set of values. <br /></td></tr>
<tr class="separator:acb7002b34046d5ca42715a875c6b089f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86bc17addd765f5048a90a7e3f0b36db"><td class="memTemplParams" colspan="2"><a id="a86bc17addd765f5048a90a7e3f0b36db" name="a86bc17addd765f5048a90a7e3f0b36db"></a>
template&lt;typename Dataset &gt; </td></tr>
<tr class="memitem:a86bc17addd765f5048a90a7e3f0b36db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sample_mean_standard_deviation</b> (const Dataset &amp;data)</td></tr>
<tr class="memdesc:a86bc17addd765f5048a90a7e3f0b36db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the standard deviation on the mean of a set of measures Bessel correction is used in the calculation of the variance. <br /></td></tr>
<tr class="separator:a86bc17addd765f5048a90a7e3f0b36db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6cd60917a9ddcdfbefdcf803c3f28a"><td class="memTemplParams" colspan="2"><a id="a5c6cd60917a9ddcdfbefdcf803c3f28a" name="a5c6cd60917a9ddcdfbefdcf803c3f28a"></a>
template&lt;typename Dataset &gt; </td></tr>
<tr class="memitem:a5c6cd60917a9ddcdfbefdcf803c3f28a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>smpl_stdom</b> (const Dataset &amp;data)</td></tr>
<tr class="memdesc:a5c6cd60917a9ddcdfbefdcf803c3f28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the standard deviation on the mean of a set of measures Bessel correction is used in the calculation of the variance. <br /></td></tr>
<tr class="separator:a5c6cd60917a9ddcdfbefdcf803c3f28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc9d6df4a15d54fae74e6faf25f9e7d"><td class="memTemplParams" colspan="2"><a id="a0cc9d6df4a15d54fae74e6faf25f9e7d" name="a0cc9d6df4a15d54fae74e6faf25f9e7d"></a>
template&lt;typename Dataset1 , typename Dataset2 &gt; </td></tr>
<tr class="memitem:a0cc9d6df4a15d54fae74e6faf25f9e7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>covariance</b> (const Dataset1 &amp;X, const Dataset2 &amp;Y)</td></tr>
<tr class="memdesc:a0cc9d6df4a15d54fae74e6faf25f9e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the covariance of two sets of measures. <br /></td></tr>
<tr class="separator:a0cc9d6df4a15d54fae74e6faf25f9e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0f5ec66a73a046a06f7702a2db5ecf"><td class="memTemplParams" colspan="2"><a id="aac0f5ec66a73a046a06f7702a2db5ecf" name="aac0f5ec66a73a046a06f7702a2db5ecf"></a>
template&lt;typename Dataset1 , typename Dataset2 &gt; </td></tr>
<tr class="memitem:aac0f5ec66a73a046a06f7702a2db5ecf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sample_covariance</b> (const Dataset1 &amp;X, const Dataset2 &amp;Y)</td></tr>
<tr class="memdesc:aac0f5ec66a73a046a06f7702a2db5ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the covariance between two sets of sample measures This function uses Bessel correction. <br /></td></tr>
<tr class="separator:aac0f5ec66a73a046a06f7702a2db5ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeded2a87fa7be1207b3621413ccd2ad"><td class="memTemplParams" colspan="2"><a id="aeeded2a87fa7be1207b3621413ccd2ad" name="aeeded2a87fa7be1207b3621413ccd2ad"></a>
template&lt;typename Dataset1 , typename Dataset2 &gt; </td></tr>
<tr class="memitem:aeeded2a87fa7be1207b3621413ccd2ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>correlation_coefficient</b> (const Dataset1 &amp;X, const Dataset2 &amp;Y)</td></tr>
<tr class="memdesc:aeeded2a87fa7be1207b3621413ccd2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pearson's correlation coefficient R for a population. <br /></td></tr>
<tr class="separator:aeeded2a87fa7be1207b3621413ccd2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79422fdbe42219e4780c002ace4e794a"><td class="memTemplParams" colspan="2"><a id="a79422fdbe42219e4780c002ace4e794a" name="a79422fdbe42219e4780c002ace4e794a"></a>
template&lt;typename Dataset1 , typename Dataset2 &gt; </td></tr>
<tr class="memitem:a79422fdbe42219e4780c002ace4e794a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sample_correlation_coefficient</b> (const Dataset1 &amp;X, const Dataset2 &amp;Y)</td></tr>
<tr class="memdesc:a79422fdbe42219e4780c002ace4e794a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pearson's correlation coefficient r for a sample. <br /></td></tr>
<tr class="separator:a79422fdbe42219e4780c002ace4e794a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e81b8c2e385958ad33f7ba9fb6c05fd"><td class="memTemplParams" colspan="2">template&lt;typename Dataset &gt; </td></tr>
<tr class="memitem:a8e81b8c2e385958ad33f7ba9fb6c05fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a8e81b8c2e385958ad33f7ba9fb6c05fd">autocorrelation</a> (const Dataset &amp;X, unsigned int n=1)</td></tr>
<tr class="memdesc:a8e81b8c2e385958ad33f7ba9fb6c05fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lag-n autocorrelation of a dataset.  <a href="namespacetheoretica.html#a8e81b8c2e385958ad33f7ba9fb6c05fd">More...</a><br /></td></tr>
<tr class="separator:a8e81b8c2e385958ad33f7ba9fb6c05fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3405b4350b80531601740d63af7def59"><td class="memTemplParams" colspan="2"><a id="a3405b4350b80531601740d63af7def59" name="a3405b4350b80531601740d63af7def59"></a>
template&lt;typename Dataset &gt; </td></tr>
<tr class="memitem:a3405b4350b80531601740d63af7def59"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>absolute_deviation</b> (const Dataset &amp;X)</td></tr>
<tr class="memdesc:a3405b4350b80531601740d63af7def59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute deviation from the mean. <br /></td></tr>
<tr class="separator:a3405b4350b80531601740d63af7def59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8499e00f131a02b27c3c24335b3be697"><td class="memTemplParams" colspan="2"><a id="a8499e00f131a02b27c3c24335b3be697" name="a8499e00f131a02b27c3c24335b3be697"></a>
template&lt;typename Dataset &gt; </td></tr>
<tr class="memitem:a8499e00f131a02b27c3c24335b3be697"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>absdev</b> (const Dataset &amp;X)</td></tr>
<tr class="memdesc:a8499e00f131a02b27c3c24335b3be697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute deviation from the mean. <br /></td></tr>
<tr class="separator:a8499e00f131a02b27c3c24335b3be697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc96f375971a0c8ef77802f8fccad56c"><td class="memTemplParams" colspan="2"><a id="acc96f375971a0c8ef77802f8fccad56c" name="acc96f375971a0c8ef77802f8fccad56c"></a>
template&lt;typename Dataset &gt; </td></tr>
<tr class="memitem:acc96f375971a0c8ef77802f8fccad56c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>skewness</b> (const Dataset &amp;X)</td></tr>
<tr class="memdesc:acc96f375971a0c8ef77802f8fccad56c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skewness of a dataset. <br /></td></tr>
<tr class="separator:acc96f375971a0c8ef77802f8fccad56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41346f193f61b7e83364457e152237b0"><td class="memTemplParams" colspan="2"><a id="a41346f193f61b7e83364457e152237b0" name="a41346f193f61b7e83364457e152237b0"></a>
template&lt;typename Dataset &gt; </td></tr>
<tr class="memitem:a41346f193f61b7e83364457e152237b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>kurtosis</b> (const Dataset &amp;X)</td></tr>
<tr class="memdesc:a41346f193f61b7e83364457e152237b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalized Kurtosis of a dataset. <br /></td></tr>
<tr class="separator:a41346f193f61b7e83364457e152237b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d700698899f2a3c313a13a65025a61"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a26d700698899f2a3c313a13a65025a61"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a26d700698899f2a3c313a13a65025a61">gaussian_expectation</a> (RealFunction g, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> <a class="el" href="namespacetheoretica.html#ae3bb9ab9b5d37b364981e1082f93e587">mean</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> sigma)</td></tr>
<tr class="memdesc:a26d700698899f2a3c313a13a65025a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the expectation of a given function with respect to a Gaussian distribution with the given parameters.  <a href="namespacetheoretica.html#a26d700698899f2a3c313a13a65025a61">More...</a><br /></td></tr>
<tr class="separator:a26d700698899f2a3c313a13a65025a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c17656f2680b638683e38d85c503dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a04c17656f2680b638683e38d85c503dd">z_score</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> <a class="el" href="namespacetheoretica.html#ae3bb9ab9b5d37b364981e1082f93e587">mean</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> sigma)</td></tr>
<tr class="memdesc:a04c17656f2680b638683e38d85c503dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Z-score of an observed value with respect to a Gaussian distribution with the given parameters.  <a href="namespacetheoretica.html#a04c17656f2680b638683e38d85c503dd">More...</a><br /></td></tr>
<tr class="separator:a04c17656f2680b638683e38d85c503dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6db3f30bb8eec3b5b9ae3bf70aeaca"><td class="memTemplParams" colspan="2">template&lt;typename Dataset &gt; </td></tr>
<tr class="memitem:afc6db3f30bb8eec3b5b9ae3bf70aeaca"><td class="memTemplItemLeft" align="right" valign="top">Dataset&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#afc6db3f30bb8eec3b5b9ae3bf70aeaca">normalize_z_score</a> (const Dataset &amp;X)</td></tr>
<tr class="memdesc:afc6db3f30bb8eec3b5b9ae3bf70aeaca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize a data set using Z-score normalization.  <a href="namespacetheoretica.html#afc6db3f30bb8eec3b5b9ae3bf70aeaca">More...</a><br /></td></tr>
<tr class="separator:afc6db3f30bb8eec3b5b9ae3bf70aeaca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f574c0d09d108278202db201226e727"><td class="memTemplParams" colspan="2">template&lt;typename Dataset1 , typename Dataset2 , typename Dataset3 &gt; </td></tr>
<tr class="memitem:a6f574c0d09d108278202db201226e727"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a6f574c0d09d108278202db201226e727">chi_square</a> (const Dataset1 &amp;O, const Dataset2 &amp;<a class="el" href="namespacetheoretica.html#aa3c0a5082e6b4428b15b7b02d16eafc7">E</a>, const Dataset3 &amp;sigma)</td></tr>
<tr class="memdesc:a6f574c0d09d108278202db201226e727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the chi-square from the set of observed quantities, expected quantities and errors.  <a href="namespacetheoretica.html#a6f574c0d09d108278202db201226e727">More...</a><br /></td></tr>
<tr class="separator:a6f574c0d09d108278202db201226e727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e2f9b3a40981abbab7c998c4fb1554"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ad9e2f9b3a40981abbab7c998c4fb1554">pvalue_chi_squared</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> chi_sqr, unsigned int ndf)</td></tr>
<tr class="memdesc:ad9e2f9b3a40981abbab7c998c4fb1554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the (right-tailed) p-value associated to a computed Chi-square value as the integral of the Chi-squared distribution from the given value to infinity (right-tailed).  <a href="namespacetheoretica.html#ad9e2f9b3a40981abbab7c998c4fb1554">More...</a><br /></td></tr>
<tr class="separator:ad9e2f9b3a40981abbab7c998c4fb1554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c670987384cd789b6b7fcf390db88d"><td class="memTemplParams" colspan="2"><a id="a16c670987384cd789b6b7fcf390db88d" name="a16c670987384cd789b6b7fcf390db88d"></a>
template&lt;typename Dataset1 , typename Dataset2 , typename Dataset3 &gt; </td></tr>
<tr class="memitem:a16c670987384cd789b6b7fcf390db88d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chi_square_linearization</b> (const Dataset1 &amp;X, const Dataset2 &amp;Y, const Dataset3 &amp;sigma, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> intercept, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> slope)</td></tr>
<tr class="memdesc:a16c670987384cd789b6b7fcf390db88d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the chi-square on a linearization. <br /></td></tr>
<tr class="separator:a16c670987384cd789b6b7fcf390db88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b287ed859418ce0fbf21b13e722cd67"><td class="memTemplParams" colspan="2"><a id="a1b287ed859418ce0fbf21b13e722cd67" name="a1b287ed859418ce0fbf21b13e722cd67"></a>
template&lt;typename Dataset1 , typename Dataset2 , typename Dataset3 &gt; </td></tr>
<tr class="memitem:a1b287ed859418ce0fbf21b13e722cd67"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reduced_chi_square_linearization</b> (const Dataset1 &amp;X, const Dataset2 &amp;Y, const Dataset3 &amp;sigma, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> intercept, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> slope)</td></tr>
<tr class="memdesc:a1b287ed859418ce0fbf21b13e722cd67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the reduced chi-squared on a linearization. <br /></td></tr>
<tr class="separator:a1b287ed859418ce0fbf21b13e722cd67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9400f3bb37113d2328017f437c7b961"><td class="memItemLeft" align="right" valign="top"><a id="ae9400f3bb37113d2328017f437c7b961" name="ae9400f3bb37113d2328017f437c7b961"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>insert_data</b> (std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;data, std::string terminator=&quot;&quot;)</td></tr>
<tr class="memdesc:ae9400f3bb37113d2328017f437c7b961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a data set from standard input. <br /></td></tr>
<tr class="separator:ae9400f3bb37113d2328017f437c7b961"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa34d8798921a9b3b78e885a455ff4211"><td class="memItemLeft" align="right" valign="top"><a id="aa34d8798921a9b3b78e885a455ff4211" name="aa34d8798921a9b3b78e885a455ff4211"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MACH_EPSILON</b> = std::numeric_limits&lt;<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&gt;::epsilon()</td></tr>
<tr class="memdesc:aa34d8798921a9b3b78e885a455ff4211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Machine epsilon for the real type. <br /></td></tr>
<tr class="separator:aa34d8798921a9b3b78e885a455ff4211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8245ba56baa7620ff9d0d9ccfbc53f"><td class="memItemLeft" align="right" valign="top"><a id="ace8245ba56baa7620ff9d0d9ccfbc53f" name="ace8245ba56baa7620ff9d0d9ccfbc53f"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PHI</b> = 1.6180339887498948482045868</td></tr>
<tr class="memdesc:ace8245ba56baa7620ff9d0d9ccfbc53f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Phi (Golden Section) mathematical constant. <br /></td></tr>
<tr class="separator:ace8245ba56baa7620ff9d0d9ccfbc53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6de16e5ee81d340ff91dbadb99edde"><td class="memItemLeft" align="right" valign="top"><a id="a6a6de16e5ee81d340ff91dbadb99edde" name="a6a6de16e5ee81d340ff91dbadb99edde"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>INVPHI</b> = 0.6180339887498948482045868</td></tr>
<tr class="memdesc:a6a6de16e5ee81d340ff91dbadb99edde"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse of the Golden Section mathematical constant. <br /></td></tr>
<tr class="separator:a6a6de16e5ee81d340ff91dbadb99edde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93349020a59cf77efcca5bb77c0e7f9"><td class="memItemLeft" align="right" valign="top"><a id="ae93349020a59cf77efcca5bb77c0e7f9" name="ae93349020a59cf77efcca5bb77c0e7f9"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PI</b> = 3.141592653589793238462643</td></tr>
<tr class="memdesc:ae93349020a59cf77efcca5bb77c0e7f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Pi mathematical constant. <br /></td></tr>
<tr class="separator:ae93349020a59cf77efcca5bb77c0e7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b5dac597409564afdc448fbef23eae"><td class="memItemLeft" align="right" valign="top"><a id="a27b5dac597409564afdc448fbef23eae" name="a27b5dac597409564afdc448fbef23eae"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PI2</b> = 1.57079632679489655799898</td></tr>
<tr class="memdesc:a27b5dac597409564afdc448fbef23eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Half of Pi. <br /></td></tr>
<tr class="separator:a27b5dac597409564afdc448fbef23eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f9025deb90bc4fd64fb9260340e3f2"><td class="memItemLeft" align="right" valign="top"><a id="ac7f9025deb90bc4fd64fb9260340e3f2" name="ac7f9025deb90bc4fd64fb9260340e3f2"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PI4</b> = <a class="el" href="namespacetheoretica.html#ae93349020a59cf77efcca5bb77c0e7f9">PI</a> / 4.0</td></tr>
<tr class="memdesc:ac7f9025deb90bc4fd64fb9260340e3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A quarter of Pi. <br /></td></tr>
<tr class="separator:ac7f9025deb90bc4fd64fb9260340e3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974f2fd34520034645cb5c96487c6ed4"><td class="memItemLeft" align="right" valign="top"><a id="a974f2fd34520034645cb5c96487c6ed4" name="a974f2fd34520034645cb5c96487c6ed4"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PIDOUBLE</b> = <a class="el" href="namespacetheoretica.html#ae93349020a59cf77efcca5bb77c0e7f9">PI</a> * 2</td></tr>
<tr class="memdesc:a974f2fd34520034645cb5c96487c6ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pi multiplied by 2. <br /></td></tr>
<tr class="separator:a974f2fd34520034645cb5c96487c6ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6a742ab030fe585063215a644f60df"><td class="memItemLeft" align="right" valign="top"><a id="aeb6a742ab030fe585063215a644f60df" name="aeb6a742ab030fe585063215a644f60df"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>TAU</b> = <a class="el" href="namespacetheoretica.html#ae93349020a59cf77efcca5bb77c0e7f9">PI</a> * 2</td></tr>
<tr class="memdesc:aeb6a742ab030fe585063215a644f60df"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Tau mathematical constant (Pi times 2) <br /></td></tr>
<tr class="separator:aeb6a742ab030fe585063215a644f60df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6916417c8d2b817cfc48b8e2a1abb5"><td class="memItemLeft" align="right" valign="top"><a id="a4d6916417c8d2b817cfc48b8e2a1abb5" name="a4d6916417c8d2b817cfc48b8e2a1abb5"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>INVPI</b> = 1.0 / <a class="el" href="namespacetheoretica.html#ae93349020a59cf77efcca5bb77c0e7f9">PI</a></td></tr>
<tr class="memdesc:a4d6916417c8d2b817cfc48b8e2a1abb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse of Pi. <br /></td></tr>
<tr class="separator:a4d6916417c8d2b817cfc48b8e2a1abb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37fb7f2271fa0e9cd55b47cf4641ca45"><td class="memItemLeft" align="right" valign="top"><a id="a37fb7f2271fa0e9cd55b47cf4641ca45" name="a37fb7f2271fa0e9cd55b47cf4641ca45"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SQRTPI</b> = 1.7724538509055159927</td></tr>
<tr class="memdesc:a37fb7f2271fa0e9cd55b47cf4641ca45"><td class="mdescLeft">&#160;</td><td class="mdescRight">The square root of Pi. <br /></td></tr>
<tr class="separator:a37fb7f2271fa0e9cd55b47cf4641ca45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c0a5082e6b4428b15b7b02d16eafc7"><td class="memItemLeft" align="right" valign="top"><a id="aa3c0a5082e6b4428b15b7b02d16eafc7" name="aa3c0a5082e6b4428b15b7b02d16eafc7"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>E</b> = 2.718281828459045235360287</td></tr>
<tr class="memdesc:aa3c0a5082e6b4428b15b7b02d16eafc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Euler mathematical constant (e) <br /></td></tr>
<tr class="separator:aa3c0a5082e6b4428b15b7b02d16eafc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771e19568e0562e2fcccd740ec90dae4"><td class="memItemLeft" align="right" valign="top"><a id="a771e19568e0562e2fcccd740ec90dae4" name="a771e19568e0562e2fcccd740ec90dae4"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LOG2E</b> = 1.44269504088896338700465094</td></tr>
<tr class="memdesc:a771e19568e0562e2fcccd740ec90dae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The binary logarithm of e. <br /></td></tr>
<tr class="separator:a771e19568e0562e2fcccd740ec90dae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4145093692043269fa4c1ebef8b4890f"><td class="memItemLeft" align="right" valign="top"><a id="a4145093692043269fa4c1ebef8b4890f" name="a4145093692043269fa4c1ebef8b4890f"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LOG210</b> = 3.32192809488736218170856773213</td></tr>
<tr class="memdesc:a4145093692043269fa4c1ebef8b4890f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The binary logarithm of 10. <br /></td></tr>
<tr class="separator:a4145093692043269fa4c1ebef8b4890f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612238583a4ec50cebd32b4694d5cb9a"><td class="memItemLeft" align="right" valign="top"><a id="a612238583a4ec50cebd32b4694d5cb9a" name="a612238583a4ec50cebd32b4694d5cb9a"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LOG10E</b> = 0.434294481903</td></tr>
<tr class="memdesc:a612238583a4ec50cebd32b4694d5cb9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base-10 logarithm of e. <br /></td></tr>
<tr class="separator:a612238583a4ec50cebd32b4694d5cb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7021b7b588c9ea63d46679aaa1f7c6c4"><td class="memItemLeft" align="right" valign="top"><a id="a7021b7b588c9ea63d46679aaa1f7c6c4" name="a7021b7b588c9ea63d46679aaa1f7c6c4"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LN2</b> = 0.69314718056</td></tr>
<tr class="memdesc:a7021b7b588c9ea63d46679aaa1f7c6c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of 2. <br /></td></tr>
<tr class="separator:a7021b7b588c9ea63d46679aaa1f7c6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc384f25a1d4c7c19169a5ce6c51710"><td class="memItemLeft" align="right" valign="top"><a id="a3bc384f25a1d4c7c19169a5ce6c51710" name="a3bc384f25a1d4c7c19169a5ce6c51710"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LN10</b> = 2.30258509299</td></tr>
<tr class="memdesc:a3bc384f25a1d4c7c19169a5ce6c51710"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of 10. <br /></td></tr>
<tr class="separator:a3bc384f25a1d4c7c19169a5ce6c51710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0afb9f871b425c7454c388eb41a3c19"><td class="memItemLeft" align="right" valign="top"><a id="ae0afb9f871b425c7454c388eb41a3c19" name="ae0afb9f871b425c7454c388eb41a3c19"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DEG2RAD</b> = 0.017453292519943295474371680598</td></tr>
<tr class="memdesc:ae0afb9f871b425c7454c388eb41a3c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">The scalar conversion factor from degrees to radians. <br /></td></tr>
<tr class="separator:ae0afb9f871b425c7454c388eb41a3c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75cd5d78670f968bac3fbcfee6660b0"><td class="memItemLeft" align="right" valign="top"><a id="ae75cd5d78670f968bac3fbcfee6660b0" name="ae75cd5d78670f968bac3fbcfee6660b0"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RAD2DEG</b> = 57.2957795130823228646477218717</td></tr>
<tr class="memdesc:ae75cd5d78670f968bac3fbcfee6660b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The scalar conversion factor from radians to degrees. <br /></td></tr>
<tr class="separator:ae75cd5d78670f968bac3fbcfee6660b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3be7f003670e91509c8f2fac523fab8"><td class="memItemLeft" align="right" valign="top"><a id="ae3be7f003670e91509c8f2fac523fab8" name="ae3be7f003670e91509c8f2fac523fab8"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SQRT2</b> = 1.4142135623730950488</td></tr>
<tr class="memdesc:ae3be7f003670e91509c8f2fac523fab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The square root of 2. <br /></td></tr>
<tr class="separator:ae3be7f003670e91509c8f2fac523fab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c1ffb22a0191558cafdaec71c3b81d"><td class="memItemLeft" align="right" valign="top"><a id="a42c1ffb22a0191558cafdaec71c3b81d" name="a42c1ffb22a0191558cafdaec71c3b81d"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>INVSQR2</b> = 0.7071067811865475</td></tr>
<tr class="memdesc:a42c1ffb22a0191558cafdaec71c3b81d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse of the square root of 2. <br /></td></tr>
<tr class="separator:a42c1ffb22a0191558cafdaec71c3b81d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3b1fe5337a2dcbdbbeb278cfd7c71d"><td class="memItemLeft" align="right" valign="top"><a id="adb3b1fe5337a2dcbdbbeb278cfd7c71d" name="adb3b1fe5337a2dcbdbbeb278cfd7c71d"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SQRT3</b> = 1.732050807568877</td></tr>
<tr class="memdesc:adb3b1fe5337a2dcbdbbeb278cfd7c71d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The square root of 3. <br /></td></tr>
<tr class="separator:adb3b1fe5337a2dcbdbbeb278cfd7c71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b4341ceb440f57a5cae39fa7b5495c"><td class="memItemLeft" align="right" valign="top"><a id="ad6b4341ceb440f57a5cae39fa7b5495c" name="ad6b4341ceb440f57a5cae39fa7b5495c"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>TAYLOR_ORDER</b> = <a class="el" href="constants_8h.html#ad693d152d21cfd12f2d4c8bc8b1122e6">THEORETICA_TAYLOR_ORDER</a></td></tr>
<tr class="memdesc:ad6b4341ceb440f57a5cae39fa7b5495c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Order of Taylor series approximations. <br /></td></tr>
<tr class="separator:ad6b4341ceb440f57a5cae39fa7b5495c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f0e3448f94ada54d171499c0c95ae4"><td class="memItemLeft" align="right" valign="top"><a id="aa1f0e3448f94ada54d171499c0c95ae4" name="aa1f0e3448f94ada54d171499c0c95ae4"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>INTEGRATION_STEPS</b> = <a class="el" href="constants_8h.html#a95c498965a897914547a05283f79c804">THEORETICA_INTEGRATION_STEPS</a></td></tr>
<tr class="memdesc:aa1f0e3448f94ada54d171499c0c95ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default number of steps for integral approximation. <br /></td></tr>
<tr class="separator:aa1f0e3448f94ada54d171499c0c95ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7199b260c88197ead0bc4bcf7fc9ada"><td class="memItemLeft" align="right" valign="top"><a id="ab7199b260c88197ead0bc4bcf7fc9ada" name="ab7199b260c88197ead0bc4bcf7fc9ada"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>INTEGRATION_TOL</b> = THEORETICA_INTEGRATION_TOL</td></tr>
<tr class="separator:ab7199b260c88197ead0bc4bcf7fc9ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbb4c38fc6708107926a7f3486036bc"><td class="memItemLeft" align="right" valign="top"><a id="a9dbb4c38fc6708107926a7f3486036bc" name="a9dbb4c38fc6708107926a7f3486036bc"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DERIV_PREC</b> = <a class="el" href="constants_8h.html#a6ff116b859afb29842f6366839e88cfd">THEORETICA_DERIV_PREC</a></td></tr>
<tr class="memdesc:a9dbb4c38fc6708107926a7f3486036bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relative precision for derivative approximation. <br /></td></tr>
<tr class="separator:a9dbb4c38fc6708107926a7f3486036bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c4976fd2f3c3dfdf02bffe927c4dd2"><td class="memItemLeft" align="right" valign="top"><a id="af0c4976fd2f3c3dfdf02bffe927c4dd2" name="af0c4976fd2f3c3dfdf02bffe927c4dd2"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>POWF_POWER_TOLERANCE</b> = <a class="el" href="constants_8h.html#a694c73eb196485f1bec84c5075600f89">THEORETICA_POWF_APPROX_TOL</a></td></tr>
<tr class="memdesc:af0c4976fd2f3c3dfdf02bffe927c4dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Biggest fractional part to ignore in powf computation. <br /></td></tr>
<tr class="separator:af0c4976fd2f3c3dfdf02bffe927c4dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4aa38ca4a41e22c4eeac0970da9b195"><td class="memItemLeft" align="right" valign="top"><a id="aa4aa38ca4a41e22c4eeac0970da9b195" name="aa4aa38ca4a41e22c4eeac0970da9b195"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ROOT_APPROX_TOL</b> = <a class="el" href="constants_8h.html#a021c58c225740fa33459a6378975e759">THEORETICA_ROOT_APPROX_TOL</a></td></tr>
<tr class="memdesc:aa4aa38ca4a41e22c4eeac0970da9b195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximation tolerance for root finding. <br /></td></tr>
<tr class="separator:aa4aa38ca4a41e22c4eeac0970da9b195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28fc38a93f999c3c98056f3dac665f42"><td class="memItemLeft" align="right" valign="top"><a id="a28fc38a93f999c3c98056f3dac665f42" name="a28fc38a93f999c3c98056f3dac665f42"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BISECTION_APPROX_TOL</b> = <a class="el" href="constants_8h.html#ae07bf3e063a76a489cc291c1684d2dda">THEORETICA_BISECTION_APPROX_TOL</a></td></tr>
<tr class="memdesc:a28fc38a93f999c3c98056f3dac665f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximation tolerance for the bisection algorithm. <br /></td></tr>
<tr class="separator:a28fc38a93f999c3c98056f3dac665f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a871a5ce0e15ea45205f3e15eec423"><td class="memItemLeft" align="right" valign="top"><a id="ae3a871a5ce0e15ea45205f3e15eec423" name="ae3a871a5ce0e15ea45205f3e15eec423"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NEWTON_RAPHSON_TOL</b> = <a class="el" href="constants_8h.html#a961e7eb071044645d790bcf11974fa67">THEORETICA_NEWTON_RAPHSON_TOL</a></td></tr>
<tr class="memdesc:ae3a871a5ce0e15ea45205f3e15eec423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximation tolerance for the Newton-Raphson algorithm. <br /></td></tr>
<tr class="separator:ae3a871a5ce0e15ea45205f3e15eec423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0df4d0b21cc7dbcfaf869e88da40af"><td class="memItemLeft" align="right" valign="top"><a id="acf0df4d0b21cc7dbcfaf869e88da40af" name="acf0df4d0b21cc7dbcfaf869e88da40af"></a>
constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_BISECTION_ITER</b> = <a class="el" href="constants_8h.html#a81ceb9b6876df9fab0812a43d92a3c22">THEORETICA_MAX_BISECTION_ITER</a></td></tr>
<tr class="memdesc:acf0df4d0b21cc7dbcfaf869e88da40af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations for the bisection algorithm. <br /></td></tr>
<tr class="separator:acf0df4d0b21cc7dbcfaf869e88da40af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71451b0e74e1fe8a28d1c41bc954804"><td class="memItemLeft" align="right" valign="top"><a id="ac71451b0e74e1fe8a28d1c41bc954804" name="ac71451b0e74e1fe8a28d1c41bc954804"></a>
constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_GOLDENSECTION_ITER</b> = <a class="el" href="constants_8h.html#afeac310b6adedfb265330e760a147a80">THEORETICA_MAX_GOLDENSECTION_ITER</a></td></tr>
<tr class="memdesc:ac71451b0e74e1fe8a28d1c41bc954804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations for the golden section search algorithm. <br /></td></tr>
<tr class="separator:ac71451b0e74e1fe8a28d1c41bc954804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b14b1cb08bd3c634410570abf8258e"><td class="memItemLeft" align="right" valign="top"><a id="a10b14b1cb08bd3c634410570abf8258e" name="a10b14b1cb08bd3c634410570abf8258e"></a>
constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_HALLEY_ITER</b> = <a class="el" href="constants_8h.html#ab139026298fae1aafae59ac99dbcc2d6">THEORETICA_MAX_HALLEY_ITER</a></td></tr>
<tr class="memdesc:a10b14b1cb08bd3c634410570abf8258e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations for Halley's method. <br /></td></tr>
<tr class="separator:a10b14b1cb08bd3c634410570abf8258e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09bde3716d7598748a55fa65c9abb6e3"><td class="memItemLeft" align="right" valign="top"><a id="a09bde3716d7598748a55fa65c9abb6e3" name="a09bde3716d7598748a55fa65c9abb6e3"></a>
constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_NEWTON_ITER</b> = <a class="el" href="constants_8h.html#a7f8e8f98bdd6e74a743d5487d4b976aa">THEORETICA_MAX_NEWTON_ITER</a></td></tr>
<tr class="memdesc:a09bde3716d7598748a55fa65c9abb6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations for the Newton-Raphson algorithm. <br /></td></tr>
<tr class="separator:a09bde3716d7598748a55fa65c9abb6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3016878f7fd372f0c459c4776e8059"><td class="memItemLeft" align="right" valign="top"><a id="abe3016878f7fd372f0c459c4776e8059" name="abe3016878f7fd372f0c459c4776e8059"></a>
constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_STEFFENSEN_ITER</b> = <a class="el" href="constants_8h.html#a079d3def41600f49deb005b75b524adc">THEORETICA_MAX_STEFFENSEN_ITER</a></td></tr>
<tr class="memdesc:abe3016878f7fd372f0c459c4776e8059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations for the Steffensen algorithm. <br /></td></tr>
<tr class="separator:abe3016878f7fd372f0c459c4776e8059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f2aa11982032c3035e8458f17d9a43"><td class="memItemLeft" align="right" valign="top"><a id="a91f2aa11982032c3035e8458f17d9a43" name="a91f2aa11982032c3035e8458f17d9a43"></a>
constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_CHEBYSHEV_ITER</b> = <a class="el" href="constants_8h.html#a70db1d134cdacb5b4c1bc8ffac852a7b">THEORETICA_MAX_CHEBYSHEV_ITER</a></td></tr>
<tr class="memdesc:a91f2aa11982032c3035e8458f17d9a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations for the Chebyshev algorithm. <br /></td></tr>
<tr class="separator:a91f2aa11982032c3035e8458f17d9a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3299f783527ae72a24c832a7b1cd8ef8"><td class="memItemLeft" align="right" valign="top"><a id="a3299f783527ae72a24c832a7b1cd8ef8" name="a3299f783527ae72a24c832a7b1cd8ef8"></a>
constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_TRYANDCATCH_ITER</b> = <a class="el" href="constants_8h.html#a9185ccd5fcdd822ae6b8b06eb1437674">THEORETICA_MAX_TRYANDCATCH_ITER</a></td></tr>
<tr class="memdesc:a3299f783527ae72a24c832a7b1cd8ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of failed iterations for the Try-and-Catch algorithm. <br /></td></tr>
<tr class="separator:a3299f783527ae72a24c832a7b1cd8ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72dfe63d1cce5e9c204cba3493a4e598"><td class="memItemLeft" align="right" valign="top"><a id="a72dfe63d1cce5e9c204cba3493a4e598" name="a72dfe63d1cce5e9c204cba3493a4e598"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DERIV_STEPSIZE</b> = <a class="el" href="constants_8h.html#ace3fe91b8a7122e757c127367663dc0f">THEORETICA_DERIV_STEPSIZE</a></td></tr>
<tr class="memdesc:a72dfe63d1cce5e9c204cba3493a4e598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default variation for derivative approximation. <br /></td></tr>
<tr class="separator:a72dfe63d1cce5e9c204cba3493a4e598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33f363492da480d62e2e0b5ad2c4ee9"><td class="memItemLeft" align="right" valign="top"><a id="ab33f363492da480d62e2e0b5ad2c4ee9" name="ab33f363492da480d62e2e0b5ad2c4ee9"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MINGRAD_GAMMA</b> = <a class="el" href="constants_8h.html#aac8e3eb0953959ada47984923ba5ca8e">THEORETICA_MINGRAD_GAMMA</a></td></tr>
<tr class="memdesc:ab33f363492da480d62e2e0b5ad2c4ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default step size for gradient descent minimization. <br /></td></tr>
<tr class="separator:ab33f363492da480d62e2e0b5ad2c4ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ebee50e5a5a80baaa6532a736ce7d55"><td class="memItemLeft" align="right" valign="top"><a id="a5ebee50e5a5a80baaa6532a736ce7d55" name="a5ebee50e5a5a80baaa6532a736ce7d55"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MINGRAD_TOLERANCE</b> = <a class="el" href="constants_8h.html#ab1f00908cc1227294e6c5be8de0e1423">THEORETICA_MINGRAD_TOLERANCE</a></td></tr>
<tr class="memdesc:a5ebee50e5a5a80baaa6532a736ce7d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default tolerance for gradient descent minimization. <br /></td></tr>
<tr class="separator:a5ebee50e5a5a80baaa6532a736ce7d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4ef8ed777e402e2ae0c7f736ba20cb"><td class="memItemLeft" align="right" valign="top"><a id="acd4ef8ed777e402e2ae0c7f736ba20cb" name="acd4ef8ed777e402e2ae0c7f736ba20cb"></a>
constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>MINGRAD_MAX_ITER</b> = <a class="el" href="constants_8h.html#ac7c192f4ff34c26e248e6d218a944027">THEORETICA_MINGRAD_MAX_ITER</a></td></tr>
<tr class="memdesc:acd4ef8ed777e402e2ae0c7f736ba20cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations for gradient descent minimization. <br /></td></tr>
<tr class="separator:acd4ef8ed777e402e2ae0c7f736ba20cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e48eab9ce5928d0c754a40ddb2d068f"><td class="memItemLeft" align="right" valign="top"><a id="a0e48eab9ce5928d0c754a40ddb2d068f" name="a0e48eab9ce5928d0c754a40ddb2d068f"></a>
constexpr uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>RAND_REAL_PREC</b> = <a class="el" href="constants_8h.html#ac13dd04d659ae36e514a06cd075f0e0e">THEORETICA_RAND_REAL_PREC</a></td></tr>
<tr class="memdesc:a0e48eab9ce5928d0c754a40ddb2d068f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default precision for random number generation using <a class="el" href="namespacetheoretica.html#a6a35e29644875a5421b3ac4d7203c28a" title="Generate a pseudorandom real number in [a, b] using a preexisting generator.">rand_uniform()</a> <br /></td></tr>
<tr class="separator:a0e48eab9ce5928d0c754a40ddb2d068f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad823e40ceef73bd9114b0a05e6cd5f"><td class="memItemLeft" align="right" valign="top"><a id="a1ad823e40ceef73bd9114b0a05e6cd5f" name="a1ad823e40ceef73bd9114b0a05e6cd5f"></a>
constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>METROPOLIS_DEPTH</b> = <a class="el" href="constants_8h.html#af21e0dc38514fc6ac32da33a7f3b6ee7">THEORETICA_METROPOLIS_DEPTH</a></td></tr>
<tr class="memdesc:a1ad823e40ceef73bd9114b0a05e6cd5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default depth of the Metropolis algorithm. <br /></td></tr>
<tr class="separator:a1ad823e40ceef73bd9114b0a05e6cd5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Main namespace of the library which contains all functions and objects. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a049966946220f1f7e5eae57293703066" name="a049966946220f1f7e5eae57293703066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a049966946220f1f7e5eae57293703066">&#9670;&nbsp;</a></span>real</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">theoretica::real</a> = typedef double</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A real number, defined as a floating point type. </p>
<p >The underlying type is determined by the defined macros: By default, <code>real</code> will be defined as the <code>double</code> type. If <code>THEORETICA_FLOAT_PREC</code> is defined, <code>real</code> will be defined as a <code>float</code>, if <code>THEORETICA_LONG_DOUBLE_PREC</code> is defined, <code>real</code> will be defined as a <code>long double</code> </p><dl class="section note"><dt>Note</dt><dd>The <code>THEORETICA_ARBITRARY_PREC</code> option is currently unsupported </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="adefc7e5553fca6b62313bb2a3037e49b" name="adefc7e5553fca6b62313bb2a3037e49b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adefc7e5553fca6b62313bb2a3037e49b">&#9670;&nbsp;</a></span>abs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the modulus of a complex number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5177ff64d981840e149d1e282f1b27e" name="aa5177ff64d981840e149d1e282f1b27e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5177ff64d981840e149d1e282f1b27e">&#9670;&nbsp;</a></span>abs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the absolute value of a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The absolute value of x</dd></dl>
<p>On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fabs</code> instruction will be used. </p>

</div>
</div>
<a id="ab0086a4838097cdade9da3abb896ac14" name="ab0086a4838097cdade9da3abb896ac14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0086a4838097cdade9da3abb896ac14">&#9670;&nbsp;</a></span>acos() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; theoretica::acos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the complex arccosine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f2d69e3a3387958a27d4a03ed478a99" name="a7f2d69e3a3387958a27d4a03ed478a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f2d69e3a3387958a27d4a03ed478a99">&#9670;&nbsp;</a></span>acos() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::acos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the arccosine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The arccosine of x</dd></dl>
<p>Domain: [-1, 1]. The identities \(acos(x) = atan(\frac{sqrt{1 - x^2}}{x})\) and \(acos(x) = atan(\frac{\sqrt{1 - x^2}}{x}) + \pi\) are used. </p>

</div>
</div>
<a id="af336feea10e3a8928f2d2723578d3704" name="af336feea10e3a8928f2d2723578d3704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af336feea10e3a8928f2d2723578d3704">&#9670;&nbsp;</a></span>asin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; theoretica::asin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the complex arcsine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79b06e5bf997c4447c10f2fa96649347" name="a79b06e5bf997c4447c10f2fa96649347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b06e5bf997c4447c10f2fa96649347">&#9670;&nbsp;</a></span>asin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::asin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the arcsine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The arcsine of x</dd></dl>
<p>Domain: [-1, 1]. The identity \(asin(x) = atan(\frac{x}{\sqrt{1 - x^2}})\) is used. </p>

</div>
</div>
<a id="abb7f72fc6086b22ac864727ac0ee064b" name="abb7f72fc6086b22ac864727ac0ee064b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb7f72fc6086b22ac864727ac0ee064b">&#9670;&nbsp;</a></span>atan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; theoretica::atan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the complex arctangent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a426b70abe4783e75806e1ae8c9e9e2bd" name="a426b70abe4783e75806e1ae8c9e9e2bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a426b70abe4783e75806e1ae8c9e9e2bd">&#9670;&nbsp;</a></span>atan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::atan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the arctangent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>An angle in <b>radians</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The arctangent of x</dd></dl>
<p>A degree 9 interpolating polynomial through Chebyshev nodes is used to approximate \(atan(x)\). Domain reduction to [-1, 1] is performed. </p>

</div>
</div>
<a id="a6ae6ab14a39d6132b6858934dadaaf3e" name="a6ae6ab14a39d6132b6858934dadaaf3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae6ab14a39d6132b6858934dadaaf3e">&#9670;&nbsp;</a></span>atan2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::atan2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the 2 argument arctangent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>The y coordinate in cartesian space </td></tr>
    <tr><td class="paramname">x</td><td>The x coordinate in cartesian space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The counterclockwise angle between the vector described by x and y and the x axis.</dd></dl>
<p>Computed using identities on atan(x). </p>

</div>
</div>
<a id="a8e81b8c2e385958ad33f7ba9fb6c05fd" name="a8e81b8c2e385958ad33f7ba9fb6c05fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e81b8c2e385958ad33f7ba9fb6c05fd">&#9670;&nbsp;</a></span>autocorrelation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dataset &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::autocorrelation </td>
          <td>(</td>
          <td class="paramtype">const Dataset &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lag-n autocorrelation of a dataset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The dataset </td></tr>
    <tr><td class="paramname">n</td><td>The lag (defaults to lag-1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lag-n autocorrelation of the given dataset </dd></dl>

</div>
</div>
<a id="ac9bfc7cddd25fd7dd7eb774e9ea1bef4" name="ac9bfc7cddd25fd7dd7eb774e9ea1bef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9bfc7cddd25fd7dd7eb774e9ea1bef4">&#9670;&nbsp;</a></span>bezier()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; theoretica::bezier </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic Bezier curve in N dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>The control points </td></tr>
    <tr><td class="paramname">t</td><td>The curve parameter between 0 and 1</td></tr>
  </table>
  </dd>
</dl>
<p>The generic Bezier curve is computed by successive linear interpolations. For cubic and quadratic Bezier curves the related functions should be preferred. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetheoretica.html#afb40a700a725235c37a4ceeb1e09c7f6" title="Quadratic Bezier curve.">quadratic_bezier</a> </dd>
<dd>
<a class="el" href="namespacetheoretica.html#acc018b01eb3df4f133863741a5ed343b" title="Cubic Bezier curve.">cubic_bezier</a> </dd></dl>

</div>
</div>
<a id="a129bf1f1085a76b92999e0faeb30e831" name="a129bf1f1085a76b92999e0faeb30e831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129bf1f1085a76b92999e0faeb30e831">&#9670;&nbsp;</a></span>binomial_coeff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType  = unsigned long long int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> IntType theoretica::binomial_coeff </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the binomial coefficient. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A natural number </td></tr>
    <tr><td class="paramname">m</td><td>A natural number smaller than n </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binomial coefficient computed on (n, m) as \(\frac{n!}{m!(n - m)!}\) </dd></dl>

</div>
</div>
<a id="a799e7fb0699a00697e98f1c952493fc9" name="a799e7fb0699a00697e98f1c952493fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a799e7fb0699a00697e98f1c952493fc9">&#9670;&nbsp;</a></span>bit_rotate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnsignedIntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UnsignedIntType theoretica::bit_rotate </td>
          <td>(</td>
          <td class="paramtype">UnsignedIntType&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bit rotation of unsigned integer types using shifts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The variable to rotate the bits of </td></tr>
    <tr><td class="paramname">i</td><td>The index of the rotated bits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61c3b797f94ec5bc22b4c22f85417c93" name="a61c3b797f94ec5bc22b4c22f85417c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c3b797f94ec5bc22b4c22f85417c93">&#9670;&nbsp;</a></span>cbrt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::cbrt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cubic root of x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cubic root of x</dd></dl>
<p>Domain: [-inf, +inf] <br  />
The Newton-Raphson algorithm, optimized for the cubic root and limited by the <code>THEORETICA_MAX_NEWTON_ITER</code> macro constant, is used. Domain reduction to [0, 1] is applied to ensure convergence of the algorithm. </p>

</div>
</div>
<a id="a085e34f437a529b59778090e0cb122e5" name="a085e34f437a529b59778090e0cb122e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a085e34f437a529b59778090e0cb122e5">&#9670;&nbsp;</a></span>chebyshev1_polynomial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; theoretica::chebyshev1_polynomial </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the nth Chebyshev polynomial of the first kind. </p>
<dl class="section note"><dt>Note</dt><dd>The result is not normalized </dd></dl>

</div>
</div>
<a id="a3450aa75a960635e9f33a6dabb22752b" name="a3450aa75a960635e9f33a6dabb22752b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3450aa75a960635e9f33a6dabb22752b">&#9670;&nbsp;</a></span>chebyshev2_polynomial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; theoretica::chebyshev2_polynomial </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the nth Chebyshev polynomial of the second kind. </p>
<dl class="section note"><dt>Note</dt><dd>The result is not normalized </dd></dl>

</div>
</div>
<a id="a25e8ede5b63e3e928ba06999468f33ef" name="a25e8ede5b63e3e928ba06999468f33ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e8ede5b63e3e928ba06999468f33ef">&#9670;&nbsp;</a></span>chebyshev_nodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = std::vector&lt;real&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorType theoretica::chebyshev_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the n Chebyshev nodes on a given interval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The lower bound of the interval </td></tr>
    <tr><td class="paramname">b</td><td>The upper bound of the interval </td></tr>
    <tr><td class="paramname">n</td><td>The number of points to evaluate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f574c0d09d108278202db201226e727" name="a6f574c0d09d108278202db201226e727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f574c0d09d108278202db201226e727">&#9670;&nbsp;</a></span>chi_square()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dataset1 , typename Dataset2 , typename Dataset3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::chi_square </td>
          <td>(</td>
          <td class="paramtype">const Dataset1 &amp;&#160;</td>
          <td class="paramname"><em>O</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Dataset2 &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Dataset3 &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the chi-square from the set of observed quantities, expected quantities and errors. </p>
<p >The provided sets should all have the same size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">O</td><td>The set of observed values </td></tr>
    <tr><td class="paramname">E</td><td>The set of expected values </td></tr>
    <tr><td class="paramname">sigma</td><td>The set of standard deviations on the observations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The computed Chi-squared </dd></dl>

</div>
</div>
<a id="af1a4ad4c5446986fe2d255a03be337a1" name="af1a4ad4c5446986fe2d255a03be337a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1a4ad4c5446986fe2d255a03be337a1">&#9670;&nbsp;</a></span>clamp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::clamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clamp x between a and b. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The real number to clamp </td></tr>
    <tr><td class="paramname">a</td><td>The lower bound </td></tr>
    <tr><td class="paramname">b</td><td>The upper bound </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns x if x is between a and b, a if x is less than a, b if x is bigger than b </dd></dl>

</div>
</div>
<a id="acdf4d125306e3fffc7287aa42f9005a1" name="acdf4d125306e3fffc7287aa42f9005a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf4d125306e3fffc7287aa42f9005a1">&#9670;&nbsp;</a></span>clamp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T theoretica::clamp </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clamp a value between two other values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to clamp </td></tr>
    <tr><td class="paramname">a</td><td>The lower bound </td></tr>
    <tr><td class="paramname">b</td><td>The upper bound </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns x if x is between a and b, a if x is less than a, b if x is bigger than b</dd></dl>
<p>The templated T type must have comparison operators. </p>

</div>
</div>
<a id="a7d4160ef942a7f710c85250f69e65def" name="a7d4160ef942a7f710c85250f69e65def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4160ef942a7f710c85250f69e65def">&#9670;&nbsp;</a></span>conjugate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; theoretica::conjugate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the conjugate of a complex number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a133da02105ffbd23a2f6f07c03b219f6" name="a133da02105ffbd23a2f6f07c03b219f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133da02105ffbd23a2f6f07c03b219f6">&#9670;&nbsp;</a></span>cos() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; theoretica::cos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the complex cosine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af684d7159e22012dc5229c31eb66fceb" name="af684d7159e22012dc5229c31eb66fceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af684d7159e22012dc5229c31eb66fceb">&#9670;&nbsp;</a></span>cos() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::cos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cosine of a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>An angle in <b>radians</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cosine of x</dd></dl>
<p>On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fcos</code> instruction will be used. </p>

</div>
</div>
<a id="a12fc03cbb1de8180e51183bb82c0bb28" name="a12fc03cbb1de8180e51183bb82c0bb28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12fc03cbb1de8180e51183bb82c0bb28">&#9670;&nbsp;</a></span>cosh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::cosh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the hyperbolic cosine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic cosine of x</dd></dl>
<p>\(cosh = \frac{e^x + e^{-x}}{2}\) </p>

</div>
</div>
<a id="aec6f43e74456bea35fb757f17db47da8" name="aec6f43e74456bea35fb757f17db47da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6f43e74456bea35fb757f17db47da8">&#9670;&nbsp;</a></span>cot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::cot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cotangent of x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>An angle in <b>radians</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cotangent of x</dd></dl>
<p>On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fsincos</code> instruction will be used. </p>

</div>
</div>
<a id="a96f957ad9b2354268f56ab1ca3843080" name="a96f957ad9b2354268f56ab1ca3843080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f957ad9b2354268f56ab1ca3843080">&#9670;&nbsp;</a></span>coth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::coth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the hyperbolic cotangent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic cotangent of x </dd></dl>

</div>
</div>
<a id="ac97fe53c636243acf273bfb04ebc91ec" name="ac97fe53c636243acf273bfb04ebc91ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac97fe53c636243acf273bfb04ebc91ec">&#9670;&nbsp;</a></span>covar_mat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix  = mat&lt;real&gt;, typename Dataset  = vec&lt;real&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix theoretica::covar_mat </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Dataset &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build the covariance matrix given a vector of datasets by computing the covariance between all couples of sets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A vector of datasets of measures </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The covariance matrix of the datasets </dd></dl>

</div>
</div>
<a id="a9cc94802c6760bba16d0eaf5795dced7" name="a9cc94802c6760bba16d0eaf5795dced7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cc94802c6760bba16d0eaf5795dced7">&#9670;&nbsp;</a></span>cube() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; theoretica::cube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cube of a complex number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6bfa8d12242c241b6f56cebc9cdc60ed" name="a6bfa8d12242c241b6f56cebc9cdc60ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bfa8d12242c241b6f56cebc9cdc60ed">&#9670;&nbsp;</a></span>cube() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::cube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cube of a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cube of x</dd></dl>
<p>Domain: [-inf, +inf] </p>

</div>
</div>
<a id="ae7bf96b1e850f0901d249adbfea8f382" name="ae7bf96b1e850f0901d249adbfea8f382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7bf96b1e850f0901d249adbfea8f382">&#9670;&nbsp;</a></span>cubic_splines() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dataset1 , typename Dataset2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structtheoretica_1_1spline__node.html">spline_node</a> &gt; theoretica::cubic_splines </td>
          <td>(</td>
          <td class="paramtype">const Dataset1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Dataset2 &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cubic splines interpolation of the sets of X and Y data points. </p>
<p >The X values should be strictly increasing. </p>

</div>
</div>
<a id="a99316012fec5500c779ddf8d4114b643" name="a99316012fec5500c779ddf8d4114b643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99316012fec5500c779ddf8d4114b643">&#9670;&nbsp;</a></span>cubic_splines() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataPoints  = std::vector&lt;vec2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structtheoretica_1_1spline__node.html">spline_node</a> &gt; theoretica::cubic_splines </td>
          <td>(</td>
          <td class="paramtype">DataPoints&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cubic splines interpolation of a set of data points. </p>
<p >The X values should be strictly increasing. </p>

</div>
</div>
<a id="a840b8c27d0a8398f33858b1f8d55732d" name="a840b8c27d0a8398f33858b1f8d55732d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a840b8c27d0a8398f33858b1f8d55732d">&#9670;&nbsp;</a></span>degrees()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::degrees </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>radians</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert radians to degrees. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radians</td><td>An angle in radians </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted angle in degrees</dd></dl>
<p>The <code>RAD2DEG</code> scalar factor is used. </p>

</div>
</div>
<a id="af13c23d95e0130b1e29ac617f313f27d" name="af13c23d95e0130b1e29ac617f313f27d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af13c23d95e0130b1e29ac617f313f27d">&#9670;&nbsp;</a></span>deriv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::deriv </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="namespacetheoretica.html#a72dfe63d1cce5e9c204cba3493a4e598">DERIV_STEPSIZE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use the best available algorithm to approximate the derivative of a real function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to approximate the derivative of </td></tr>
    <tr><td class="paramname">x</td><td>The real value to approximate at </td></tr>
    <tr><td class="paramname">h</td><td>The stepsize to use in the finite differences method </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The approximated value of the derivative </dd></dl>

</div>
</div>
<a id="ad376dcd3be0e15133bbedf6ad1160587" name="ad376dcd3be0e15133bbedf6ad1160587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad376dcd3be0e15133bbedf6ad1160587">&#9670;&nbsp;</a></span>deriv2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::deriv2 </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="namespacetheoretica.html#a72dfe63d1cce5e9c204cba3493a4e598">DERIV_STEPSIZE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use the best available algorithm to approximate the second derivative of a real function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to approximate the second derivative of </td></tr>
    <tr><td class="paramname">x</td><td>The real value to approximate at </td></tr>
    <tr><td class="paramname">h</td><td>The stepsize to use in the finite differences method </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The approximated value of the second derivative </dd></dl>

</div>
</div>
<a id="a0fda7d7c90a088c8bdbf28b0908c71e8" name="a0fda7d7c90a088c8bdbf28b0908c71e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fda7d7c90a088c8bdbf28b0908c71e8">&#9670;&nbsp;</a></span>deriv_backward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::deriv_backward </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="namespacetheoretica.html#a72dfe63d1cce5e9c204cba3493a4e598">DERIV_STEPSIZE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derivative approximation using the backward method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to approximate the derivative of </td></tr>
    <tr><td class="paramname">x</td><td>The real value to approximate at </td></tr>
    <tr><td class="paramname">h</td><td>The stepsize to use in the finite differences method </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The approximated value of the derivative </dd></dl>

</div>
</div>
<a id="a5bbf1baa785f514b3e3a74f80fbd9546" name="a5bbf1baa785f514b3e3a74f80fbd9546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bbf1baa785f514b3e3a74f80fbd9546">&#9670;&nbsp;</a></span>deriv_central()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::deriv_central </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="namespacetheoretica.html#a72dfe63d1cce5e9c204cba3493a4e598">DERIV_STEPSIZE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derivative approximation using the central method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to approximate the derivative of </td></tr>
    <tr><td class="paramname">x</td><td>The real value to approximate at </td></tr>
    <tr><td class="paramname">h</td><td>The stepsize to use in the finite differences method </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The approximated value of the derivative </dd></dl>

</div>
</div>
<a id="a936dad7b99b64c874223aa537c3ad84f" name="a936dad7b99b64c874223aa537c3ad84f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a936dad7b99b64c874223aa537c3ad84f">&#9670;&nbsp;</a></span>deriv_forward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::deriv_forward </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="namespacetheoretica.html#a72dfe63d1cce5e9c204cba3493a4e598">DERIV_STEPSIZE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derivative approximation using the forward method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to approximate the derivative of </td></tr>
    <tr><td class="paramname">x</td><td>The real value to approximate at </td></tr>
    <tr><td class="paramname">h</td><td>The stepsize to use in the finite differences method </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The approximated value of the derivative </dd></dl>

</div>
</div>
<a id="a3db068fdfc750be0e45e3fcaa77fc458" name="a3db068fdfc750be0e45e3fcaa77fc458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db068fdfc750be0e45e3fcaa77fc458">&#9670;&nbsp;</a></span>deriv_polynomial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = real&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; T &gt; theoretica::deriv_polynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the derivative of a polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The polynomial to differentiate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The derivative polynomial </dd></dl>

</div>
</div>
<a id="a08c5277448360f087fa63323020675c6" name="a08c5277448360f087fa63323020675c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08c5277448360f087fa63323020675c6">&#9670;&nbsp;</a></span>deriv_ridders()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::deriv_ridders </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code>0.01</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>degree</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ridder's derivative approximation of arbitrary degree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to approximate the derivative of </td></tr>
    <tr><td class="paramname">x</td><td>The real value to approximate at </td></tr>
    <tr><td class="paramname">degree</td><td>The degree of the algorithm </td></tr>
    <tr><td class="paramname">h</td><td>The stepsize to use in the finite differences method </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The approximated value of the derivative </dd></dl>

</div>
</div>
<a id="a93f963a737accf2110a8ed71a5064320" name="a93f963a737accf2110a8ed71a5064320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f963a737accf2110a8ed71a5064320">&#9670;&nbsp;</a></span>deriv_ridders2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::deriv_ridders2 </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="namespacetheoretica.html#a72dfe63d1cce5e9c204cba3493a4e598">DERIV_STEPSIZE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ridder's derivative approximation of second degree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to approximate the derivative of </td></tr>
    <tr><td class="paramname">x</td><td>The real value to approximate at </td></tr>
    <tr><td class="paramname">h</td><td>The stepsize to use in the finite differences method </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The approximated value of the derivative </dd></dl>

</div>
</div>
<a id="ac03d79f4e33fe2c37460a8d3b6c2d6c4" name="ac03d79f4e33fe2c37460a8d3b6c2d6c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac03d79f4e33fe2c37460a8d3b6c2d6c4">&#9670;&nbsp;</a></span>directional_derivative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;)&gt; theoretica::directional_derivative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a9ac9a6f3d85bd0f6ae607178431e51a6">d_real</a>&lt; N &gt;(*)(<a class="el" href="classtheoretica_1_1vec.html">d_vec</a>&lt; N &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a function which computes the directional derivative of a generic function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to partially differentiate </td></tr>
    <tr><td class="paramname">x</td><td>The point to compute the derivative at </td></tr>
    <tr><td class="paramname">v</td><td>The direction to compute the derivative on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In most applications, the vector v should be a unit vector, but the function does not control whether the vector has unit length or not. </dd></dl>

</div>
</div>
<a id="aab34cedf5d18aaa1ee1ca9f148122310" name="aab34cedf5d18aaa1ee1ca9f148122310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab34cedf5d18aaa1ee1ca9f148122310">&#9670;&nbsp;</a></span>directional_derivative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; theoretica::directional_derivative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a9ac9a6f3d85bd0f6ae607178431e51a6">d_real</a>&lt; N &gt;(*)(<a class="el" href="classtheoretica_1_1vec.html">d_vec</a>&lt; N &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the directional derivative of a generic function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to partially differentiate </td></tr>
    <tr><td class="paramname">x</td><td>The point to compute the derivative at </td></tr>
    <tr><td class="paramname">v</td><td>The direction to compute the derivative on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In most applications, the vector v should be a unit vector, but the function does not control whether the vector has unit length or not. </dd></dl>

</div>
</div>
<a id="a2f76a86b2f7a23e3b85bc9f464c31d5f" name="a2f76a86b2f7a23e3b85bc9f464c31d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f76a86b2f7a23e3b85bc9f464c31d5f">&#9670;&nbsp;</a></span>divergence_mono()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::divergence_mono </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1dual.html">dual</a>(*)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1dual.html">dual</a>, N &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the divergence for a given \(\vec x\) of a function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\) using automatic differentiation. </p>
<dl class="section note"><dt>Note</dt><dd>The multidual implementation is more efficient as it does not need to compute the function value N times and should be preferred.</dd></dl>
<p>The <code>mono</code> suffix is used to emphasize the difference between simple dual numbers and multidual numbers and to avoid differentiation between overloads on the user's side. </p>

</div>
</div>
<a id="a2d84edd693f12451e609e365239533cc" name="a2d84edd693f12451e609e365239533cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d84edd693f12451e609e365239533cc">&#9670;&nbsp;</a></span>error_propagation() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N = 0, typename MultiDualFunction  = multidual&lt;N&gt;(*)(vec&lt;multidual&lt;N&gt;, N&gt;), typename Dataset  = vec&lt;real, N&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::error_propagation </td>
          <td>(</td>
          <td class="paramtype">MultiDualFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Dataset &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Automatically propagate uncertainties under quadrature on an arbitrary function given the function and the set of measured data. </p>
<p >The covar_mat function is used to estimate the covariance matrix from the data sets. For this to work, the data sets should have the same size, so as to estimate their covariance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to propagate error on </td></tr>
    <tr><td class="paramname">v</td><td>A vector of different datasets of the measures of the variables </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The propagated error on the function </dd></dl>

</div>
</div>
<a id="a78365ecc6d0b73192e64e501895a0f85" name="a78365ecc6d0b73192e64e501895a0f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78365ecc6d0b73192e64e501895a0f85">&#9670;&nbsp;</a></span>error_propagation() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N = 0, unsigned int M = 0, typename MultiDualFunction  = d_real&lt;N&gt;(*)(d_vec&lt;N&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::error_propagation </td>
          <td>(</td>
          <td class="paramtype">MultiDualFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_best</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1mat.html">mat</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, M, M &gt; &amp;&#160;</td>
          <td class="paramname"><em>cm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Automatically propagate uncertainties under quadrature on an arbitrary function given the uncertainties on the variables, the mean values of the variables and the function itself, by using automatic differentiation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to propagate error on </td></tr>
    <tr><td class="paramname">x</td><td>Best values for the variables </td></tr>
    <tr><td class="paramname">cm</td><td>Covariance matrix of the variables, where diagonal entries are the variance of the variables and off-diagonal entries are the covariance between different variables. May be constructed from datasets using the function covar_mat. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The propagated error on the function </dd></dl>

</div>
</div>
<a id="a13c65d8d1f18eeaed2e6cb96b8138ec7" name="a13c65d8d1f18eeaed2e6cb96b8138ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c65d8d1f18eeaed2e6cb96b8138ec7">&#9670;&nbsp;</a></span>error_propagation() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N = 0, typename MultiDualFunction  = d_real&lt;N&gt;(*)(d_vec&lt;N&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::error_propagation </td>
          <td>(</td>
          <td class="paramtype">MultiDualFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_best</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>delta_x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Automatically propagate uncertainties under quadrature on an arbitrary function given the uncertainties on the variables, the mean values of the variables and the function itself, by using automatic differentiation. </p>
<p >This function presupposes that the correlation between different variables is zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to propagate error on </td></tr>
    <tr><td class="paramname">x</td><td>Best values for the variables </td></tr>
    <tr><td class="paramname">delta_x</td><td>Vector of uncertainties on the variables </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The propagated error on the function </dd></dl>

</div>
</div>
<a id="acd69de2551fd07855f64a36e1b3132fe" name="acd69de2551fd07855f64a36e1b3132fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd69de2551fd07855f64a36e1b3132fe">&#9670;&nbsp;</a></span>euclidean_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::euclidean_distance </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Distances. </p>
<p >Compute the Euclidean distance between two vectors </p>

</div>
</div>
<a id="a6500750eaa5ea09bf1a2fa8ca1c1d430" name="a6500750eaa5ea09bf1a2fa8ca1c1d430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6500750eaa5ea09bf1a2fa8ca1c1d430">&#9670;&nbsp;</a></span>exp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; theoretica::exp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the complex exponential. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac61f8810fcedeaa35f54c834e934828e" name="ac61f8810fcedeaa35f54c834e934828e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac61f8810fcedeaa35f54c834e934828e">&#9670;&nbsp;</a></span>exp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::exp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the real exponential. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exponential of x</dd></dl>
<p>The exponential is computed as \(e^{floor(x)} \cdot e^{fract(x)}\), where \(e^{floor(x)} = pow(e, floor(x))\) and \(e^{fract(x)}\) is approximated using Taylor series on [0, 0.25] </p>

</div>
</div>
<a id="ae57235e0b29cc687c5084e5f0aa2515c" name="ae57235e0b29cc687c5084e5f0aa2515c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae57235e0b29cc687c5084e5f0aa2515c">&#9670;&nbsp;</a></span>expm1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::expm1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the exponential of x minus 1 more accurately for really small x. </p>
<p >For |x| &gt; 0.001, th::exp is used. </p>

</div>
</div>
<a id="a64c11855cee4c627ff303e9b50845a75" name="a64c11855cee4c627ff303e9b50845a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64c11855cee4c627ff303e9b50845a75">&#9670;&nbsp;</a></span>find_root_intervals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacetheoretica.html#a1f21bd68ba64b172c29d9fce15c8712d">vec2</a> &gt; theoretica::find_root_intervals </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>steps</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find candidate intervals for root finding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function of real variable </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of the region of interest </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of the region of interest </td></tr>
    <tr><td class="paramname">steps</td><td>The number of subintervals to check (optional) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afad5c92586d6a0f841bfcd3759eff317" name="afad5c92586d6a0f841bfcd3759eff317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad5c92586d6a0f841bfcd3759eff317">&#9670;&nbsp;</a></span>floor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> int theoretica::floor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the floor of x Computes the maximum integer number that is smaller than x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The floor of x</dd></dl>
<p>e.g. floor(1.6) = 1 e.g. floor(-0.3) = -1 </p>

</div>
</div>
<a id="a85d079c3d95f2bc80c4619d13ff7263a" name="a85d079c3d95f2bc80c4619d13ff7263a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d079c3d95f2bc80c4619d13ff7263a">&#9670;&nbsp;</a></span>fract()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::fract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the fractional part of a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The fractional part of x</dd></dl>
<p>e.g. fract(2.5) = 0.5 e.g. fract(-0.2) = 0.2 </p>

</div>
</div>
<a id="a26d700698899f2a3c313a13a65025a61" name="a26d700698899f2a3c313a13a65025a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26d700698899f2a3c313a13a65025a61">&#9670;&nbsp;</a></span>gaussian_expectation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::gaussian_expectation </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the expectation of a given function with respect to a Gaussian distribution with the given parameters. </p>
<p >This function uses Gauss-Hermite quadrature to compute the integral \(\int_{-\infty}^{+\infty} g(x) e^{-x^2} dx\)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mean</td><td>The mean of the Gaussian distribution </td></tr>
    <tr><td class="paramname">sigma</td><td>The standard deviation of the Gaussian distribution </td></tr>
    <tr><td class="paramname">g</td><td>The function to compute the expectation of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Gaussian expectation of the given function </dd></dl>

</div>
</div>
<a id="a5adf7d2f3094d32dd9d4059ec86247db" name="a5adf7d2f3094d32dd9d4059ec86247db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5adf7d2f3094d32dd9d4059ec86247db">&#9670;&nbsp;</a></span>gen_polyn_recurr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; theoretica::gen_polyn_recurr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td>
          <td class="paramname"><em>P0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#adcb53498374f76292a3da8bb8c785341">polyn_recurr_formula</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a polynomial basis using a recursion formula. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P0</td><td>First polynomial of the sequence </td></tr>
    <tr><td class="paramname">P1</td><td>Second polynomial of the sequence </td></tr>
    <tr><td class="paramname">f</td><td>Recursion formula </td></tr>
    <tr><td class="paramname">n</td><td>Degree of the final polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting polynomial </dd></dl>

</div>
</div>
<a id="ab1d99fa1f99736540520c2b251574362" name="ab1d99fa1f99736540520c2b251574362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d99fa1f99736540520c2b251574362">&#9670;&nbsp;</a></span>gradient_mono()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; theoretica::gradient_mono </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1dual.html">dual</a>(*)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1dual.html">dual</a>, N &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the gradient for a given \(\vec x\) of a function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\) using automatic differentiation. </p>
<dl class="section note"><dt>Note</dt><dd>The multidual implementation is more efficient as it does not need to compute the function value N times and should be preferred.</dd></dl>
<p>The <code>mono</code> suffix is used to emphasize the difference between simple dual numbers and multidual numbers and to avoid differentiation between overloads on the user's side. </p>

</div>
</div>
<a id="a024554cae44fb42700e8f68d235f0f15" name="a024554cae44fb42700e8f68d235f0f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a024554cae44fb42700e8f68d235f0f15">&#9670;&nbsp;</a></span>heaviside()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::heaviside </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the heaviside function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The heaviside function for x, equal to 1 if x &gt; 0, 0 if x &lt; 0 and 1/2 if x = 0 </dd></dl>

</div>
</div>
<a id="afd97a0d6d99915f065567958760164f4" name="afd97a0d6d99915f065567958760164f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd97a0d6d99915f065567958760164f4">&#9670;&nbsp;</a></span>hermite_polynomial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; theoretica::hermite_polynomial </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the nth Hermite polynomial. </p>
<dl class="section note"><dt>Note</dt><dd>The result is not normalized </dd></dl>

</div>
</div>
<a id="a04806d2927b08fe51b37c5a1c517de35" name="a04806d2927b08fe51b37c5a1c517de35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04806d2927b08fe51b37c5a1c517de35">&#9670;&nbsp;</a></span>hermite_weights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; theoretica::hermite_weights </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>roots</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hermite weights for Gauss-Hermite quadrature of n-th order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">roots</td><td>The n roots of the n-th Hermite polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Hermite weights for Gauss-Hermite quadrature </dd></dl>

</div>
</div>
<a id="ad830de3729f8f2bea38d60ef706cf968" name="ad830de3729f8f2bea38d60ef706cf968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad830de3729f8f2bea38d60ef706cf968">&#9670;&nbsp;</a></span>icbrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnsignedIntType  = uint64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UnsignedIntType theoretica::icbrt </td>
          <td>(</td>
          <td class="paramtype">UnsignedIntType&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the integer cubic root of a positive integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A positive integer number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rounded down cubic root of n A binary search algorithm is used. </dd></dl>

</div>
</div>
<a id="a3901b8b9a442e4b71368650c2ce1ee31" name="a3901b8b9a442e4b71368650c2ce1ee31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3901b8b9a442e4b71368650c2ce1ee31">&#9670;&nbsp;</a></span>identity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; theoretica::identity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Complex identity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50cd5107369678c27b30dbae079283c5" name="a50cd5107369678c27b30dbae079283c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50cd5107369678c27b30dbae079283c5">&#9670;&nbsp;</a></span>ilog2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnsignedIntType  = uint64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UnsignedIntType theoretica::ilog2 </td>
          <td>(</td>
          <td class="paramtype">UnsignedIntType&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the integer logarithm of x. </p>
<p >Defined as the biggest n so that 2^n is smaller than x. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>An integer value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integer logarithm of x </dd></dl>

</div>
</div>
<a id="ae095e7eee4b03eddc3b035b2bde14a7e" name="ae095e7eee4b03eddc3b035b2bde14a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae095e7eee4b03eddc3b035b2bde14a7e">&#9670;&nbsp;</a></span>integral() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use the best available algorithm to approximate the definite integral of a real function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An approximation of the integral of f </dd></dl>

</div>
</div>
<a id="aa29abada0134095a6d9a120c241ce461" name="aa29abada0134095a6d9a120c241ce461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa29abada0134095a6d9a120c241ce461">&#9670;&nbsp;</a></span>integral() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use the best available algorithm to approximate the definite integral of a real function to a given tolerance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">tol</td><td>Tolerance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An approximation of the integral of f </dd></dl>

</div>
</div>
<a id="a301de055cdb4b0a9888d68dc8382b5cf" name="a301de055cdb4b0a9888d68dc8382b5cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301de055cdb4b0a9888d68dc8382b5cf">&#9670;&nbsp;</a></span>integral_crude() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_crude </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, S &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a1f21bd68ba64b172c29d9fce15c8712d">vec2</a>, S &gt;&#160;</td>
          <td class="paramname"><em>extremes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate an integral by using Crude Monte Carlo integration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">extremes</td><td>A vector of the extremes of integration </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
    <tr><td class="paramname">N</td><td>The number of points to generate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07652c066aaca0e41b16a21554bc5a28" name="a07652c066aaca0e41b16a21554bc5a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07652c066aaca0e41b16a21554bc5a28">&#9670;&nbsp;</a></span>integral_crude() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_crude </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate an integral by using Crude Monte Carlo integration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
    <tr><td class="paramname">N</td><td>The number of points to generate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96bf598b39c148bddb7ceebd7aa9b446" name="a96bf598b39c148bddb7ceebd7aa9b446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96bf598b39c148bddb7ceebd7aa9b446">&#9670;&nbsp;</a></span>integral_gauss() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_gauss </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use Gaussian quadrature using the given points and weights. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">x</td><td>The points of evaluation </td></tr>
    <tr><td class="paramname">w</td><td>The weights of the linear combination </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa72ca0802148fca511bdb53d2cf958a8" name="aa72ca0802148fca511bdb53d2cf958a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa72ca0802148fca511bdb53d2cf958a8">&#9670;&nbsp;</a></span>integral_gauss() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_gauss </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use Gaussian quadrature using the given points and weights. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">x</td><td>The points of evaluation </td></tr>
    <tr><td class="paramname">w</td><td>The weights of the linear combination </td></tr>
    <tr><td class="paramname">n</td><td>The number of points used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a500bb7c67e29e96e7f6c3655b8f7d3b3" name="a500bb7c67e29e96e7f6c3655b8f7d3b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a500bb7c67e29e96e7f6c3655b8f7d3b3">&#9670;&nbsp;</a></span>integral_gauss() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_gauss </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>Winv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use Gaussian quadrature using the given points and weights. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">x</td><td>The points of evaluation </td></tr>
    <tr><td class="paramname">w</td><td>The weights of the linear combination </td></tr>
    <tr><td class="paramname">n</td><td>The number of points used </td></tr>
    <tr><td class="paramname">Winv</td><td>The inverse of the weight function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abbe2540b2ff381a14b61588280cb9016" name="abbe2540b2ff381a14b61588280cb9016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbe2540b2ff381a14b61588280cb9016">&#9670;&nbsp;</a></span>integral_hermite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_hermite </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use Gauss-Hermite quadrature of arbitrary degree to approximate an integral over (-inf, +inf) providing the roots of the n degree Hermite polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">x</td><td>The roots of the n degree Hermite polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Gauss-Hermite quadrature of the given function </dd></dl>

</div>
</div>
<a id="abd783739794f700157cc7f7d6f9d9632" name="abd783739794f700157cc7f7d6f9d9632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd783739794f700157cc7f7d6f9d9632">&#9670;&nbsp;</a></span>integral_hermite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_hermite </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use Gauss-Hermite quadrature of degree 2, 4, 8 or 16, using pre-computed values, to approximate an integral over (-inf, +inf). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">n</td><td>The order of the polynomial (available values are 2, 4, 8 or 16). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Gauss-Hermite quadrature of the given function </dd></dl>

</div>
</div>
<a id="a369a64e60df5e45af0bb4581a9f213da" name="a369a64e60df5e45af0bb4581a9f213da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369a64e60df5e45af0bb4581a9f213da">&#9670;&nbsp;</a></span>integral_hom() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_hom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate an integral by using Hit-or-miss Monte Carlo integration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">c</td><td>The function minimum in the domain [a, b] </td></tr>
    <tr><td class="paramname">d</td><td>The function maximum in the domain [a, b] </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
    <tr><td class="paramname">N</td><td>The number of points to generate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd8b0a1c223e7bc79b04046d4e8502da" name="afd8b0a1c223e7bc79b04046d4e8502da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd8b0a1c223e7bc79b04046d4e8502da">&#9670;&nbsp;</a></span>integral_hom() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_hom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>f_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate an integral by using Hit-or-miss Monte Carlo integration. </p>
<dl class="section note"><dt>Note</dt><dd>This implementation considers only the portion of the function over zero (useful for distributions for example), if you need to consider all of the values of the function in the domain of integration, use the other implementation of integral_hom </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">f_max</td><td>The function maximum in the [a, b] interval </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
    <tr><td class="paramname">N</td><td>The number of points to generate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1373c528867e33024d2975dfa7c41ca4" name="a1373c528867e33024d2975dfa7c41ca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1373c528867e33024d2975dfa7c41ca4">&#9670;&nbsp;</a></span>integral_hom_2d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_hom_2d </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>f_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use the Hit-or-Miss Monte Carlo method to approximate a double integral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The multivariate function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration on x </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration on x </td></tr>
    <tr><td class="paramname">c</td><td>The lower extreme of integration on y </td></tr>
    <tr><td class="paramname">d</td><td>The upper extreme of integration on y </td></tr>
    <tr><td class="paramname">f_max</td><td>The function maximum in the [a, b]x[c, d] interval </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
    <tr><td class="paramname">N</td><td>The number of points to generate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d1d65e5dba67ccf5199e5d5544e2484" name="a3d1d65e5dba67ccf5199e5d5544e2484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d1d65e5dba67ccf5199e5d5544e2484">&#9670;&nbsp;</a></span>integral_impsamp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_impsamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>Ginv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate an integral by using Crude Monte Carlo integration with importance sampling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">g</td><td>The importance function (normalized) </td></tr>
    <tr><td class="paramname">Ginv</td><td>The inverse of the primitive of g, with domain [0, 1] </td></tr>
    <tr><td class="paramname">gen</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
    <tr><td class="paramname">N</td><td>The number of points to generate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4a53869de63d5c2daf7790511ce8aac" name="aa4a53869de63d5c2daf7790511ce8aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a53869de63d5c2daf7790511ce8aac">&#9670;&nbsp;</a></span>integral_laguerre() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_laguerre </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use Gauss-Laguerre quadrature of arbitrary degree to approximate an integral over [0, +inf) providing the roots of the n degree Legendre polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">x</td><td>The roots of the n degree Laguerre polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Gauss-Laguerre quadrature of the given function </dd></dl>

</div>
</div>
<a id="a0c209d0975ad962d9b5e68a3661150ab" name="a0c209d0975ad962d9b5e68a3661150ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c209d0975ad962d9b5e68a3661150ab">&#9670;&nbsp;</a></span>integral_laguerre() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_laguerre </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use Gauss-Laguerre quadrature of arbitrary degree to approximate an integral over [a, b] providing the roots of the n degree Legendre polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">x</td><td>The roots of the n degree Laguerre polynomial </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Gauss-Laguerre quadrature of the given function </dd></dl>

</div>
</div>
<a id="ab15d3b8d15def86bb228a46811100bca" name="ab15d3b8d15def86bb228a46811100bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15d3b8d15def86bb228a46811100bca">&#9670;&nbsp;</a></span>integral_laguerre() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_laguerre </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use Gauss-Laguerre quadrature of degree 2, 4, 8 or 16, using pre-computed values, to approximate an integral over [0, +inf). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">n</td><td>The order of the polynomial (available values are 2, 4, 8 or 16). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Gauss-Legendre quadrature of the given function </dd></dl>

</div>
</div>
<a id="ad3f79a7b3f80ff901eba3340d1ba14a5" name="ad3f79a7b3f80ff901eba3340d1ba14a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f79a7b3f80ff901eba3340d1ba14a5">&#9670;&nbsp;</a></span>integral_legendre() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_legendre </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use Gauss-Legendre quadrature of arbitrary degree to approximate a definite integral providing the roots of the n degree Legendre polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">x</td><td>The roots of the n degree Legendre polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Gauss-Legendre quadrature of the given function </dd></dl>

</div>
</div>
<a id="a62ca5edbbdee0a51f8c0bfddb4c71f69" name="a62ca5edbbdee0a51f8c0bfddb4c71f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ca5edbbdee0a51f8c0bfddb4c71f69">&#9670;&nbsp;</a></span>integral_legendre() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_legendre </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use Gauss-Legendre quadrature of arbitrary degree to approximate a definite integral providing the roots of the n degree Legendre polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">x</td><td>The roots of the n degree Legendre polynomial </td></tr>
    <tr><td class="paramname">w</td><td>The weights computed for the n-th order quadrature </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Gauss-Legendre quadrature of the given function </dd></dl>

</div>
</div>
<a id="ad2038787a4650a9610cdf4639901677a" name="ad2038787a4650a9610cdf4639901677a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2038787a4650a9610cdf4639901677a">&#9670;&nbsp;</a></span>integral_legendre() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_legendre </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use Gauss-Legendre quadrature of arbitrary degree to approximate a definite integral providing the roots of the n degree Legendre polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">x</td><td>The roots of the n degree Legendre polynomial </td></tr>
    <tr><td class="paramname">w</td><td>The weights computed for the n-th order quadrature </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Gauss-Legendre quadrature of the given function </dd></dl>

</div>
</div>
<a id="aa8406b9711bb256a289bb656c4c52e39" name="aa8406b9711bb256a289bb656c4c52e39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8406b9711bb256a289bb656c4c52e39">&#9670;&nbsp;</a></span>integral_legendre() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_legendre </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use Gauss-Legendre quadrature of degree 2, 4, 8 or 16, using pre-computed values, to approximate an integral over [a, b]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">n</td><td>The order of the polynomial (available values are 2, 4, 8, 16 or 32). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Gauss-Legendre quadrature of the given function </dd></dl>

</div>
</div>
<a id="a1a48a7bb7296e78f5c1b0c5f5bcf4d93" name="a1a48a7bb7296e78f5c1b0c5f5bcf4d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a48a7bb7296e78f5c1b0c5f5bcf4d93">&#9670;&nbsp;</a></span>integral_midpoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_midpoint </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>steps</em> = <code><a class="el" href="namespacetheoretica.html#aa1f0e3448f94ada54d171499c0c95ae4">INTEGRATION_STEPS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate the definite integral of an arbitrary function using the midpoint method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">steps</td><td>The number of steps </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An approximation of the integral of f </dd></dl>

</div>
</div>
<a id="abad6a42bf9fd0176e622e01e0f7446a9" name="abad6a42bf9fd0176e622e01e0f7446a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad6a42bf9fd0176e622e01e0f7446a9">&#9670;&nbsp;</a></span>integral_quasi_crude() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_quasi_crude </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, S &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a1f21bd68ba64b172c29d9fce15c8712d">vec2</a>, S &gt;&#160;</td>
          <td class="paramname"><em>extremes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, S &gt;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate an integral by using Crude Quasi-Monte Carlo integration by sampling from the Weyl sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">extremes</td><td>A vector of the extremes of integration </td></tr>
    <tr><td class="paramname">alpha</td><td>A vector of the irrational numbers to use for the Weyl sequence </td></tr>
    <tr><td class="paramname">N</td><td>The number of points to generate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ed022df42e2b7152fc916433acbfbcc" name="a4ed022df42e2b7152fc916433acbfbcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed022df42e2b7152fc916433acbfbcc">&#9670;&nbsp;</a></span>integral_quasi_crude() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_quasi_crude </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, S &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a1f21bd68ba64b172c29d9fce15c8712d">vec2</a>, S &gt;&#160;</td>
          <td class="paramname"><em>extremes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em> = <code>1000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate an integral by using Crude Quasi-Monte Carlo integration by sampling from the Weyl sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">extremes</td><td>A vector of the extremes of integration </td></tr>
    <tr><td class="paramname">alpha</td><td>An irrational number </td></tr>
    <tr><td class="paramname">N</td><td>The number of points to generate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11c69bea27399e4d430e877b538ce777" name="a11c69bea27399e4d430e877b538ce777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c69bea27399e4d430e877b538ce777">&#9670;&nbsp;</a></span>integral_quasi_crude() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_quasi_crude </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate an integral by using Crude Quasi-Monte Carlo integration by sampling from the Weyl sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">N</td><td>The number of points to generate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2655b89d203adc197979dafd29fe518b" name="a2655b89d203adc197979dafd29fe518b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2655b89d203adc197979dafd29fe518b">&#9670;&nbsp;</a></span>integral_quasi_hom() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_quasi_hom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate an integral by using Hit-or-miss Quasi-Monte Carlo integration, sampling points from the Weyl bi-dimensional sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">f_max</td><td>The function maximum in the [a, b] interval </td></tr>
    <tr><td class="paramname">N</td><td>The number of points to generate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22f21b203e4325f357c2c84558239269" name="a22f21b203e4325f357c2c84558239269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f21b203e4325f357c2c84558239269">&#9670;&nbsp;</a></span>integral_quasi_hom() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_quasi_hom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>f_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate an integral by using Hit-or-miss Quasi-Monte Carlo integration, sampling points from the Weyl bi-dimensional sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">f_max</td><td>The function maximum in the [a, b] interval </td></tr>
    <tr><td class="paramname">N</td><td>The number of points to generate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0edff8be282482211b0cbc6cd022222e" name="a0edff8be282482211b0cbc6cd022222e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0edff8be282482211b0cbc6cd022222e">&#9670;&nbsp;</a></span>integral_quasi_impsamp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_quasi_impsamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>Ginv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate an integral by using Crude Quasi-Monte Carlo integration with importance sampling, using the Weyl sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">g</td><td>The importance function (normalized) </td></tr>
    <tr><td class="paramname">Ginv</td><td>The inverse of the primitive of g, with domain [0, 1] </td></tr>
    <tr><td class="paramname">gen</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
    <tr><td class="paramname">N</td><td>The number of points to generate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f6c51cd5ff6287130ab25a6efbbe2e5" name="a8f6c51cd5ff6287130ab25a6efbbe2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f6c51cd5ff6287130ab25a6efbbe2e5">&#9670;&nbsp;</a></span>integral_romberg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_romberg </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iter</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate the definite integral of an arbitrary function using Romberg's method accurate to the given order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">order</td><td>The order of accuracy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An approximation of the integral of f </dd></dl>

</div>
</div>
<a id="a15b399a5f43e97fecaa0017297df12d3" name="a15b399a5f43e97fecaa0017297df12d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15b399a5f43e97fecaa0017297df12d3">&#9670;&nbsp;</a></span>integral_romberg_tol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_romberg_tol </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>INTEGRATION_TOL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate the definite integral of an arbitrary function using Romberg's method to the given tolerance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">tolerance</td><td>Convergence tolerance for the algorithm </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An approximation of the integral of f </dd></dl>

</div>
</div>
<a id="ad5f3d75e6a0c23d23a5e685145437ff5" name="ad5f3d75e6a0c23d23a5e685145437ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f3d75e6a0c23d23a5e685145437ff5">&#9670;&nbsp;</a></span>integral_simpson()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_simpson </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>steps</em> = <code><a class="el" href="namespacetheoretica.html#aa1f0e3448f94ada54d171499c0c95ae4">INTEGRATION_STEPS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate the definite integral of an arbitrary function using Simpson's method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">steps</td><td>The number of steps </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An approximation of the integral of f </dd></dl>

</div>
</div>
<a id="a4cbfca610e297e184c272140d991e987" name="a4cbfca610e297e184c272140d991e987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cbfca610e297e184c272140d991e987">&#9670;&nbsp;</a></span>integral_trapezoid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_trapezoid </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>steps</em> = <code><a class="el" href="namespacetheoretica.html#aa1f0e3448f94ada54d171499c0c95ae4">INTEGRATION_STEPS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate the definite integral of an arbitrary function using the trapezoid method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">steps</td><td>The number of steps </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An approximation of the integral of f </dd></dl>

</div>
</div>
<a id="ad30054ccf81cf93e466c08361e4ff9fb" name="ad30054ccf81cf93e466c08361e4ff9fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad30054ccf81cf93e466c08361e4ff9fb">&#9670;&nbsp;</a></span>integrate_polynomial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = real&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; T &gt; theoretica::integrate_polynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the indefinite integral of a polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The polynomial to integrate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The indefinite polynomial integral </dd></dl>

</div>
</div>
<a id="a88f9a26f1ee40dea3fced3ee7e0c9aa9" name="a88f9a26f1ee40dea3fced3ee7e0c9aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f9a26f1ee40dea3fced3ee7e0c9aa9">&#9670;&nbsp;</a></span>interpolate_chebyshev()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; theoretica::interpolate_chebyshev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the interpolating polynomial of a real function using Chebyshev nodes as sampling points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to interpolate </td></tr>
    <tr><td class="paramname">a</td><td>Lower bound of the interval </td></tr>
    <tr><td class="paramname">b</td><td>Upper bound of the interval </td></tr>
    <tr><td class="paramname">order</td><td>Order of the resulting polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A polynomial of (n - 1) degree interpolating the function through the Chebyshev nodes.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetheoretica.html#a25e8ede5b63e3e928ba06999468f33ef" title="Compute the n Chebyshev nodes on a given interval.">chebyshev_nodes</a> </dd>
<dd>
<a class="el" href="namespacetheoretica.html#ab8b367e4460b8aec5f8c29282f671006" title="Compute the Lagrange polynomial interpolating a set of points.">lagrange_polynomial</a> </dd></dl>

</div>
</div>
<a id="a9dc2216d71f0d7147b5c0dacdeea80db" name="a9dc2216d71f0d7147b5c0dacdeea80db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dc2216d71f0d7147b5c0dacdeea80db">&#9670;&nbsp;</a></span>interpolate_grid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; theoretica::interpolate_grid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the interpolating polynomial of a real function on an equidistant point sample. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to interpolate </td></tr>
    <tr><td class="paramname">a</td><td>Lower bound of the interval </td></tr>
    <tr><td class="paramname">b</td><td>Upper bound of the interval </td></tr>
    <tr><td class="paramname">order</td><td>Order of the resulting polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A polynomial of (n - 1) degree interpolating the function </dd></dl>

</div>
</div>
<a id="a3e9b9fcd589d1358fb90effc83e1fc04" name="a3e9b9fcd589d1358fb90effc83e1fc04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e9b9fcd589d1358fb90effc83e1fc04">&#9670;&nbsp;</a></span>inverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; theoretica::inverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the conjugate of a complex number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52e31c328bc34c0d2fca2aad3bf78ca7" name="a52e31c328bc34c0d2fca2aad3bf78ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e31c328bc34c0d2fca2aad3bf78ca7">&#9670;&nbsp;</a></span>ipow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = real&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> T theoretica::ipow </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>neutral_element</em> = <code>T(1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the n-th positive power of x (where n is natural) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Any element of a multiplicative algebra </td></tr>
    <tr><td class="paramname">n</td><td>The integer exponent </td></tr>
    <tr><td class="paramname">neutral_element</td><td>The neutral element of the given type T </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x to the power n</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should be preferred when computing the power of objects which are not strictly numbers. </dd></dl>

</div>
</div>
<a id="a22e311a811c0c7e23c30e4496cfbe63d" name="a22e311a811c0c7e23c30e4496cfbe63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22e311a811c0c7e23c30e4496cfbe63d">&#9670;&nbsp;</a></span>is_nan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool theoretica::is_nan </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a generic variable is (equivalent to) a NaN number. </p>
<p >NaN numbers are the only variables which do not compare equal to themselves in floating point operations. This is valid for real types but also for any mathematical structure, as NaNs are used to report failure inside the library.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The mathematical structure to test for being a NaN or NaN-equivalent structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68914a563241494dfe7ac42f0462920c" name="a68914a563241494dfe7ac42f0462920c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68914a563241494dfe7ac42f0462920c">&#9670;&nbsp;</a></span>isqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnsignedIntType  = uint64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UnsignedIntType theoretica::isqrt </td>
          <td>(</td>
          <td class="paramtype">UnsignedIntType&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the integer square root of a positive integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A positive integer number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rounded down square root of n A binary search algorithm is used. </dd></dl>

</div>
</div>
<a id="a321928d10b6606c1cba0232a613e6dfe" name="a321928d10b6606c1cba0232a613e6dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a321928d10b6606c1cba0232a613e6dfe">&#9670;&nbsp;</a></span>kronecker_delta()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> T theoretica::kronecker_delta </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Kronecker delta, equals 1 if i is equal to j, 0 otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The first value to compare </td></tr>
    <tr><td class="paramname">j</td><td>The second value to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if i is equal to j, 0 otherwise </dd></dl>

</div>
</div>
<a id="a72d0f113bf884c2e04dbc257b9aaed2f" name="a72d0f113bf884c2e04dbc257b9aaed2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d0f113bf884c2e04dbc257b9aaed2f">&#9670;&nbsp;</a></span>l1_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::l1_norm </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the L1 norm of a vector. </p>
<p >\(L_1(\vec v) = \Sigma_i \ |v_i|\) </p>

</div>
</div>
<a id="ae3f58265a7030cb73e6aadc39b6f0599" name="ae3f58265a7030cb73e6aadc39b6f0599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f58265a7030cb73e6aadc39b6f0599">&#9670;&nbsp;</a></span>l2_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::l2_norm </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the L2 norm of a vector. </p>
<p >\(L_2(\vec v) = \sqrt{\Sigma_i \ v_i^2}\) </p>

</div>
</div>
<a id="ab8b367e4460b8aec5f8c29282f671006" name="ab8b367e4460b8aec5f8c29282f671006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b367e4460b8aec5f8c29282f671006">&#9670;&nbsp;</a></span>lagrange_polynomial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = real&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; T &gt; theoretica::lagrange_polynomial </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; T, 2 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Lagrange polynomial interpolating a set of points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>The set of n points to interpolate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A polynomial of (n - 1) degree interpolating the points </dd></dl>

</div>
</div>
<a id="a4b528fc8814c1dd197a21d49f1ad6c93" name="a4b528fc8814c1dd197a21d49f1ad6c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b528fc8814c1dd197a21d49f1ad6c93">&#9670;&nbsp;</a></span>laguerre_weights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; theoretica::laguerre_weights </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>roots</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Laguerre weights for Gauss-Laguerre quadrature of n-th order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">roots</td><td>The n roots of the n-th Laguerre polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Laguerre weights for Gauss-Laguerre quadrature </dd></dl>

</div>
</div>
<a id="acaa95392d9bfc3ddf34f3e82f4b6ae78" name="acaa95392d9bfc3ddf34f3e82f4b6ae78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa95392d9bfc3ddf34f3e82f4b6ae78">&#9670;&nbsp;</a></span>legendre_polynomial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; theoretica::legendre_polynomial </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the nth Legendre polynomial. </p>
<dl class="section note"><dt>Note</dt><dd>The result is not normalized </dd></dl>

</div>
</div>
<a id="aebbaeffb922b25d5f1758296b473939f" name="aebbaeffb922b25d5f1758296b473939f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebbaeffb922b25d5f1758296b473939f">&#9670;&nbsp;</a></span>legendre_roots()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; theoretica::legendre_roots </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Roots of the n-th Legendre polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The degree of the polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of the n roots of the Legendre polynomial </dd></dl>

</div>
</div>
<a id="a40aca2488b0466c4934fd050d3718760" name="a40aca2488b0466c4934fd050d3718760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40aca2488b0466c4934fd050d3718760">&#9670;&nbsp;</a></span>legendre_weights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; theoretica::legendre_weights </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>roots</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Legendre weights for Gauss-Legendre quadrature of n-th order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">roots</td><td>The n roots of the n-th Legendre polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Legendre weights for Gauss-Legendre quadrature </dd></dl>

</div>
</div>
<a id="afec5b6f456b010a5af7f3bce105cdea4" name="afec5b6f456b010a5af7f3bce105cdea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec5b6f456b010a5af7f3bce105cdea4">&#9670;&nbsp;</a></span>likelihood()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::likelihood </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ac7a0bafb035970e4921b84f75661e2b1">stat_function</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the likelihood of a distribution &lt;f&gt; with the given parameters &lt;theta&gt; and measures &lt;X&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The dataset of the sample </td></tr>
    <tr><td class="paramname">theta</td><td>The parameters of the distribution </td></tr>
    <tr><td class="paramname">f</td><td>The statistical distribution function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The likelihood of the given sample </dd></dl>

</div>
</div>
<a id="ab5b1bad8257e5090708d2fba48d2d2a0" name="ab5b1bad8257e5090708d2fba48d2d2a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b1bad8257e5090708d2fba48d2d2a0">&#9670;&nbsp;</a></span>linf_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::linf_norm </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Linf norm of a vector. </p>
<p >\(L_{inf}(\vec v) = max(|v_i|)\) </p>

</div>
</div>
<a id="aeaa4a4d5af15f371b28d87d35b504aae" name="aeaa4a4d5af15f371b28d87d35b504aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa4a4d5af15f371b28d87d35b504aae">&#9670;&nbsp;</a></span>ln() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; theoretica::ln </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the complex logarithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a748eca731a8c05226332e5723b7a9d91" name="a748eca731a8c05226332e5723b7a9d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748eca731a8c05226332e5723b7a9d91">&#9670;&nbsp;</a></span>ln() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::ln </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the natural logarithm of x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number bigger than 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The natural logarithm of x</dd></dl>
<p>Domain: (0, +inf] <br  />
On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fyl2x</code> instruction will be used. </p>

</div>
</div>
<a id="adb04217fd0bd9dd23daaa186d3756d1e" name="adb04217fd0bd9dd23daaa186d3756d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb04217fd0bd9dd23daaa186d3756d1e">&#9670;&nbsp;</a></span>log10()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::log10 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the base-10 logarithm of x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number bigger than 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The base-10 logarithm of x</dd></dl>
<p>Domain: (0, +inf] <br  />
On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fyl2x</code> instruction will be used. </p>

</div>
</div>
<a id="abbd0ef7aa0b136fbd1b4579cec14f369" name="abbd0ef7aa0b136fbd1b4579cec14f369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd0ef7aa0b136fbd1b4579cec14f369">&#9670;&nbsp;</a></span>log2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::log2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the binary logarithm of a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number bigger than 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binary logarithm of x</dd></dl>
<p>Domain: (0, +inf] <br  />
On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fyl2x</code> instruction will be used. </p>

</div>
</div>
<a id="a7e07a8227cf85be04e9554ea103854e7" name="a7e07a8227cf85be04e9554ea103854e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e07a8227cf85be04e9554ea103854e7">&#9670;&nbsp;</a></span>log_likelihood()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::log_likelihood </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ac7a0bafb035970e4921b84f75661e2b1">stat_function</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the log likelihood of a distribution &lt;f&gt; with the given parameters &lt;theta&gt; and measures &lt;X&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The dataset of the sample </td></tr>
    <tr><td class="paramname">theta</td><td>The parameters of the distribution </td></tr>
    <tr><td class="paramname">f</td><td>The statistical distribution function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log-likelihood of the given sample </dd></dl>

</div>
</div>
<a id="af8286ffe7f1090f451c53c06dd8849b7" name="af8286ffe7f1090f451c53c06dd8849b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8286ffe7f1090f451c53c06dd8849b7">&#9670;&nbsp;</a></span>lp_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::lp_norm </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Norms. </p>
<p >Compute the Lp norm of a vector. \(L_p(\vec v) = (\Sigma_i \ |v_i|^p)^{1/p}\) </p>

</div>
</div>
<a id="a07569756dda099ecabf425371da6a31d" name="a07569756dda099ecabf425371da6a31d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07569756dda099ecabf425371da6a31d">&#9670;&nbsp;</a></span>max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the greatest number between two real numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
    <tr><td class="paramname">y</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The greatest number between x and y</dd></dl>
<p>If <code>THEORETICA_BRANCHLESS</code> is defined, a branchless implementation will be used </p>

</div>
</div>
<a id="a5e295404d1712fb17851fe105715766e" name="a5e295404d1712fb17851fe105715766e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e295404d1712fb17851fe105715766e">&#9670;&nbsp;</a></span>max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T theoretica::max </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two objects and return the greatest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The first object to compare </td></tr>
    <tr><td class="paramname">y</td><td>The second object to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The greatest between the objects</dd></dl>
<p>The templated T type must have comparison operators. </p>

</div>
</div>
<a id="acd9ca806c04b6433f5e23a9a0fa25d4d" name="acd9ca806c04b6433f5e23a9a0fa25d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd9ca806c04b6433f5e23a9a0fa25d4d">&#9670;&nbsp;</a></span>maximize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; theoretica::maximize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;, N &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td>
          <td class="paramname"><em>guess</em> = <code><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt;<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>,&#160;N&gt;(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacetheoretica.html#a5ebee50e5a5a80baaa6532a736ce7d55">MINGRAD_TOLERANCE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use the best available algorithm to find a local maximum of the given multivariate function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to maximize </td></tr>
    <tr><td class="paramname">guess</td><td>The initial guess </td></tr>
    <tr><td class="paramname">tolerance</td><td>The minimum magnitude of the gradient to stop the algorithm at, defaults to MINGRAD_TOLERANCE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinates of the local maximum, NaN if the algorithm did not converge. </dd></dl>

</div>
</div>
<a id="a2ed9c4f8f3ecf08e0f2b062aebab37eb" name="a2ed9c4f8f3ecf08e0f2b062aebab37eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ed9c4f8f3ecf08e0f2b062aebab37eb">&#9670;&nbsp;</a></span>maximize_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; theoretica::maximize_grad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;, N &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td>
          <td class="paramname"><em>guess</em> = <code><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt;<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>,&#160;N&gt;(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>gamma</em> = <code><a class="el" href="namespacetheoretica.html#ab33f363492da480d62e2e0b5ad2c4ee9">MINGRAD_GAMMA</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacetheoretica.html#a5ebee50e5a5a80baaa6532a736ce7d55">MINGRAD_TOLERANCE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#acd4ef8ed777e402e2ae0c7f736ba20cb">MINGRAD_MAX_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a local maximum of the given multivariate function using fixed-step gradient descent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to maximize </td></tr>
    <tr><td class="paramname">guess</td><td>The initial guess, defaults to the origin </td></tr>
    <tr><td class="paramname">gamma</td><td>The fixed step size, defaults to MINGRAD_GAMMA </td></tr>
    <tr><td class="paramname">tolerance</td><td>The maximum magnitude of the gradient to stop the algorithm at, defaults to MINGRAD_TOLERANCE. </td></tr>
    <tr><td class="paramname">max_iter</td><td>The maximum number of iterations to perform before stopping execution of the routine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinates of the local maximum, NaN if the algorithm did not converge. </dd></dl>

</div>
</div>
<a id="ad6abfd74878f161330c5564560dc7451" name="ad6abfd74878f161330c5564560dc7451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6abfd74878f161330c5564560dc7451">&#9670;&nbsp;</a></span>maximize_lingrad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; theoretica::maximize_lingrad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;, N &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td>
          <td class="paramname"><em>guess</em> = <code><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt;<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>,&#160;N&gt;(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacetheoretica.html#a5ebee50e5a5a80baaa6532a736ce7d55">MINGRAD_TOLERANCE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#acd4ef8ed777e402e2ae0c7f736ba20cb">MINGRAD_MAX_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a local maximum of the given multivariate function using gradient descent with linear search. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to maximize </td></tr>
    <tr><td class="paramname">guess</td><td>The initial guess, defaults to the origin </td></tr>
    <tr><td class="paramname">tolerance</td><td>The minimum magnitude of the gradient to stop the algorithm at, defaults to MINGRAD_TOLERANCE. </td></tr>
    <tr><td class="paramname">max_iter</td><td>The maximum number of iterations to perform before stopping execution of the routine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinates of the local maximum, NaN if the algorithm did not converge. </dd></dl>

</div>
</div>
<a id="adf6e93b355b93426144ceb0f7b435ac3" name="adf6e93b355b93426144ceb0f7b435ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf6e93b355b93426144ceb0f7b435ac3">&#9670;&nbsp;</a></span>mc_error_propagation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::mc_error_propagation </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structtheoretica_1_1pdf__sampler.html">pdf_sampler</a> &gt;&#160;</td>
          <td class="paramname"><em>rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em> = <code>1<a class="el" href="namespacetheoretica.html#aa3c0a5082e6b4428b15b7b02d16eafc7">E</a>+6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Propagate the statistical error on a given function using the Monte Carlo method, by generating a sample following the probability distribution of the function and computing its standard deviation. </p>
<p >N sample vectors are generated from the <a class="el" href="structtheoretica_1_1pdf__sampler.html" title="A probability density function sampler which generates pseudorandom numbers following asymptotically ...">pdf_sampler</a> vector, with the same number of elements, and are then passed to the function to compute a sample of the final random variable and its sample standard deviation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to propagate error on </td></tr>
    <tr><td class="paramname">rv</td><td>A list of distribution samplers which sample from the probability distributions of the random variables. </td></tr>
    <tr><td class="paramname">N</td><td>The number of sampled values to use, defaults to 1 million. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The standard deviation of the Monte Carlo sample </dd></dl>

</div>
</div>
<a id="a4f05663c1a2c0ae0e9fdf9784db4036d" name="a4f05663c1a2c0ae0e9fdf9784db4036d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f05663c1a2c0ae0e9fdf9784db4036d">&#9670;&nbsp;</a></span>mc_sample()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function , typename VectorType  = std::vector&lt;real&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorType theoretica::mc_sample </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structtheoretica_1_1pdf__sampler.html">pdf_sampler</a> &gt;&#160;</td>
          <td class="paramname"><em>rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a Monte Carlo sample of values of a given function of arbitrary variables following the given distributions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function with argument vec&lt;real&gt; </td></tr>
    <tr><td class="paramname">rv</td><td>A vector of distribution samplers from the distributions of the random variables </td></tr>
    <tr><td class="paramname">N</td><td>The size of the sample </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sampled values </dd></dl>

</div>
</div>
<a id="aa4b235e6e95449fbb28f562c110f6aa3" name="aa4b235e6e95449fbb28f562c110f6aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b235e6e95449fbb28f562c110f6aa3">&#9670;&nbsp;</a></span>metropolis() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::metropolis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>pdf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtheoretica_1_1pdf__sampler.html">pdf_sampler</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>rnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>depth</em> = <code><a class="el" href="namespacetheoretica.html#a1ad823e40ceef73bd9114b0a05e6cd5f">METROPOLIS_DEPTH</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Metropolis algorithm for distribution sampling using a symmetric proposal distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pdf</td><td>The target distribution </td></tr>
    <tr><td class="paramname">g</td><td>A <a class="el" href="structtheoretica_1_1pdf__sampler.html" title="A probability density function sampler which generates pseudorandom numbers following asymptotically ...">pdf_sampler</a> already initialized to sample from the proposal distribution </td></tr>
    <tr><td class="paramname">rnd</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
    <tr><td class="paramname">depth</td><td>The number of iterations of the algorithm (defaults to METROPOLIS_DEPTH) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a171a1939d723ba99bf4e4905728df701" name="a171a1939d723ba99bf4e4905728df701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a171a1939d723ba99bf4e4905728df701">&#9670;&nbsp;</a></span>metropolis() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::metropolis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>pdf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtheoretica_1_1pdf__sampler.html">pdf_sampler</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>depth</em> = <code><a class="el" href="namespacetheoretica.html#a1ad823e40ceef73bd9114b0a05e6cd5f">METROPOLIS_DEPTH</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Metropolis algorithm for distribution sampling using a symmetric proposal distribution. </p>
<p >This function uses the same <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> as the proposal distribution sampler to generate uniform samples.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pdf</td><td>The target distribution </td></tr>
    <tr><td class="paramname">g</td><td>A <a class="el" href="structtheoretica_1_1pdf__sampler.html" title="A probability density function sampler which generates pseudorandom numbers following asymptotically ...">pdf_sampler</a> already initialized to sample from the proposal distribution </td></tr>
    <tr><td class="paramname">depth</td><td>The number of iterations of the algorithm (defaults to METROPOLIS_DEPTH) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac673920f8956ebea402eac4271f551ba" name="ac673920f8956ebea402eac4271f551ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac673920f8956ebea402eac4271f551ba">&#9670;&nbsp;</a></span>min() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the smallest number between two real numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
    <tr><td class="paramname">y</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest number between x and y</dd></dl>
<p>If <code>THEORETICA_BRANCHLESS</code> is defined, a branchless implementation will be used </p>

</div>
</div>
<a id="a70f4122359c1f32ba0741d098a5fbe69" name="a70f4122359c1f32ba0741d098a5fbe69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f4122359c1f32ba0741d098a5fbe69">&#9670;&nbsp;</a></span>min() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T theoretica::min </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two objects and return the greatest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The first object to compare </td></tr>
    <tr><td class="paramname">y</td><td>The second object to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest between the objects</dd></dl>
<p>The templated T type must have comparison operators. </p>

</div>
</div>
<a id="a1756ced9e0ae717d8eef965c993af5fe" name="a1756ced9e0ae717d8eef965c993af5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1756ced9e0ae717d8eef965c993af5fe">&#9670;&nbsp;</a></span>minimize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; theoretica::minimize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;, N &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td>
          <td class="paramname"><em>guess</em> = <code><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt;<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>,&#160;N&gt;(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacetheoretica.html#a5ebee50e5a5a80baaa6532a736ce7d55">MINGRAD_TOLERANCE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use the best available algorithm to find a local minimum of the given multivariate function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to minimize </td></tr>
    <tr><td class="paramname">guess</td><td>The initial guess </td></tr>
    <tr><td class="paramname">tolerance</td><td>The minimum magnitude of the gradient to stop the algorithm at, defaults to MINGRAD_TOLERANCE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinates of the local minimum, NaN if the algorithm did not converge. </dd></dl>

</div>
</div>
<a id="a6b9206e7284e0bf7c65a4d6ba3290cd8" name="a6b9206e7284e0bf7c65a4d6ba3290cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b9206e7284e0bf7c65a4d6ba3290cd8">&#9670;&nbsp;</a></span>minimize_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; theoretica::minimize_grad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;, N &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td>
          <td class="paramname"><em>guess</em> = <code><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt;<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>,&#160;N&gt;(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>gamma</em> = <code><a class="el" href="namespacetheoretica.html#ab33f363492da480d62e2e0b5ad2c4ee9">MINGRAD_GAMMA</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacetheoretica.html#a5ebee50e5a5a80baaa6532a736ce7d55">MINGRAD_TOLERANCE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#acd4ef8ed777e402e2ae0c7f736ba20cb">MINGRAD_MAX_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a local minimum of the given multivariate function using fixed-step gradient descent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to minimize </td></tr>
    <tr><td class="paramname">guess</td><td>The initial guess, defaults to the origin </td></tr>
    <tr><td class="paramname">gamma</td><td>The fixed step size, defaults to MINGRAD_GAMMA </td></tr>
    <tr><td class="paramname">tolerance</td><td>The maximum magnitude of the gradient to stop the algorithm at, defaults to MINGRAD_TOLERANCE. </td></tr>
    <tr><td class="paramname">max_iter</td><td>The maximum number of iterations to perform before stopping execution of the routine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinates of the local minimum, NaN if the algorithm did not converge. </dd></dl>

</div>
</div>
<a id="a54d1451b1f5fa91ec37aeedc52f5c1c8" name="a54d1451b1f5fa91ec37aeedc52f5c1c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54d1451b1f5fa91ec37aeedc52f5c1c8">&#9670;&nbsp;</a></span>minimize_lingrad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; theoretica::minimize_lingrad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;, N &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td>
          <td class="paramname"><em>guess</em> = <code><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt;<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>,&#160;N&gt;(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacetheoretica.html#a5ebee50e5a5a80baaa6532a736ce7d55">MINGRAD_TOLERANCE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#acd4ef8ed777e402e2ae0c7f736ba20cb">MINGRAD_MAX_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a local minimum of the given multivariate function using gradient descent with linear search. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to minimize </td></tr>
    <tr><td class="paramname">guess</td><td>The initial guess, defaults to the origin </td></tr>
    <tr><td class="paramname">tolerance</td><td>The maximum magnitude of the gradient to stop the algorithm at, defaults to MINGRAD_TOLERANCE. </td></tr>
    <tr><td class="paramname">max_iter</td><td>The maximum number of iterations to perform before stopping execution of the routine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinates of the local minimum, NaN if the algorithm did not converge. </dd></dl>

</div>
</div>
<a id="a672dbbc0ea824c71d7ca0dc26b346200" name="a672dbbc0ea824c71d7ca0dc26b346200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a672dbbc0ea824c71d7ca0dc26b346200">&#9670;&nbsp;</a></span>mix_mum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::mix_mum </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>MUM bit mixing function, computes the 128-bit product of a and b and the XOR of their high and low 64-bit parts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first operand </td></tr>
    <tr><td class="paramname">b</td><td>The second operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca2b51694a7dd4ded3a140f92366aaed" name="aca2b51694a7dd4ded3a140f92366aaed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca2b51694a7dd4ded3a140f92366aaed">&#9670;&nbsp;</a></span>mul_uint128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void theoretica::mul_uint128 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>c_low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>c_high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply two 64-bit integers and store the result in two 64-bit variables, keeping 128 bits of the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first number to multiply </td></tr>
    <tr><td class="paramname">b</td><td>The second number to multiply </td></tr>
    <tr><td class="paramname">c_low</td><td>The variable where to store the lowest 64 bits of the result </td></tr>
    <tr><td class="paramname">c_high</td><td>The variable where to store the highest 64 bits of the result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab918c2760ce54c9d49e15d942078b470" name="ab918c2760ce54c9d49e15d942078b470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab918c2760ce54c9d49e15d942078b470">&#9670;&nbsp;</a></span>multiroot_newton()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; theoretica::multiroot_newton </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">d_vec</a>&lt; N &gt;(*)(<a class="el" href="classtheoretica_1_1vec.html">d_vec</a>&lt; N &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td>
          <td class="paramname"><em>guess</em> = <code><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt;<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>,&#160;N&gt;(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacetheoretica.html#a5ebee50e5a5a80baaa6532a736ce7d55">MINGRAD_TOLERANCE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#acd4ef8ed777e402e2ae0c7f736ba20cb">MINGRAD_MAX_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate the root of a multivariate function using Newton's method with pure Jacobian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to find the root of </td></tr>
    <tr><td class="paramname">guess</td><td>The first guess (defaults to the origin) </td></tr>
    <tr><td class="paramname">tolerance</td><td>The tolerance over the final result (defaults to MINGRAD_TOLERANCE) </td></tr>
    <tr><td class="paramname">max_iter</td><td>The maximum number of iterations before stopping the algorithm </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The computed vector at which f is approximately zero </dd></dl>

</div>
</div>
<a id="afc6db3f30bb8eec3b5b9ae3bf70aeaca" name="afc6db3f30bb8eec3b5b9ae3bf70aeaca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc6db3f30bb8eec3b5b9ae3bf70aeaca">&#9670;&nbsp;</a></span>normalize_z_score()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dataset &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Dataset theoretica::normalize_z_score </td>
          <td>(</td>
          <td class="paramtype">const Dataset &amp;&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalize a data set using Z-score normalization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>data set to normalize </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The normalized data set </dd></dl>

</div>
</div>
<a id="a7b1848b188dc6aa193c71f8afb08df90" name="a7b1848b188dc6aa193c71f8afb08df90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1848b188dc6aa193c71f8afb08df90">&#9670;&nbsp;</a></span>ode_adams()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt; theoretica::ode_adams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>s0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integrate numerically a differential equation in N unknowns using the Dormand-Prince method of sixth order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function which computes the derivative of the state </td></tr>
    <tr><td class="paramname">s</td><td>The current state of the ODE </td></tr>
    <tr><td class="paramname">h</td><td>Step size Integrate numerically a differential equation in 1 unknown using the Adams-Bashforth linear multistep method of the second order </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69d5877a3794df2193a5f7bada42ed2d" name="a69d5877a3794df2193a5f7bada42ed2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69d5877a3794df2193a5f7bada42ed2d">&#9670;&nbsp;</a></span>ode_euler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt; theoretica::ode_euler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integrate numerically a differential equation in one unknown using Euler's method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function which computes the derivative of the state </td></tr>
    <tr><td class="paramname">s</td><td>The current state of the ODE </td></tr>
    <tr><td class="paramname">h</td><td>Step size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ac97182a0900bc58e53c78fa1b3eb2a" name="a9ac97182a0900bc58e53c78fa1b3eb2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac97182a0900bc58e53c78fa1b3eb2a">&#9670;&nbsp;</a></span>ode_euler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt; theoretica::ode_euler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;(*)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integrate numerically a differential equation in N unknowns using Euler's method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function which computes the derivative of the state </td></tr>
    <tr><td class="paramname">s</td><td>The current state of the ODE </td></tr>
    <tr><td class="paramname">h</td><td>Step size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada01c01adb4d24ed0d699dc375821d0c" name="ada01c01adb4d24ed0d699dc375821d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada01c01adb4d24ed0d699dc375821d0c">&#9670;&nbsp;</a></span>ode_heun() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt; theoretica::ode_heun </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integrate numerically a differential equation in one unknown using Heun's method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function which computes the derivative of the state </td></tr>
    <tr><td class="paramname">s</td><td>The current state of the ODE </td></tr>
    <tr><td class="paramname">h</td><td>Step size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acffbc50c378374fca79ddda6cd19fac2" name="acffbc50c378374fca79ddda6cd19fac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acffbc50c378374fca79ddda6cd19fac2">&#9670;&nbsp;</a></span>ode_heun() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt; theoretica::ode_heun </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;(*)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integrate numerically a differential equation in N unknowns using Heun's method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function which computes the derivative of the state </td></tr>
    <tr><td class="paramname">s</td><td>The current state of the ODE </td></tr>
    <tr><td class="paramname">h</td><td>Step size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57c7edfdb6e58fbe8b6b3b2c51f75e4d" name="a57c7edfdb6e58fbe8b6b3b2c51f75e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c7edfdb6e58fbe8b6b3b2c51f75e4d">&#9670;&nbsp;</a></span>ode_k38() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt; theoretica::ode_k38 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integrate numerically a differential equation in one unknown using Kutta's 3/8 rule method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function which computes the derivative of the state </td></tr>
    <tr><td class="paramname">s</td><td>The current state of the ODE </td></tr>
    <tr><td class="paramname">h</td><td>Step size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ff6c39e5861b2783b0d5adac8a16499" name="a0ff6c39e5861b2783b0d5adac8a16499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff6c39e5861b2783b0d5adac8a16499">&#9670;&nbsp;</a></span>ode_k38() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt; theoretica::ode_k38 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;(*)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integrate numerically a differential equation in N unknowns using Kutta's 3/8 rule method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function which computes the derivative of the state </td></tr>
    <tr><td class="paramname">s</td><td>The current state of the ODE </td></tr>
    <tr><td class="paramname">h</td><td>Step size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7ea0278567b60befbcb39c8bab85a15" name="ac7ea0278567b60befbcb39c8bab85a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7ea0278567b60befbcb39c8bab85a15">&#9670;&nbsp;</a></span>ode_midpoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt; theoretica::ode_midpoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integrate numerically a differential equation in one unknown using the midpoint method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function which computes the derivative of the state </td></tr>
    <tr><td class="paramname">s</td><td>The current state of the ODE </td></tr>
    <tr><td class="paramname">h</td><td>Step size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b1d1c17fc6cb0d6c7920d22e3a01ba2" name="a5b1d1c17fc6cb0d6c7920d22e3a01ba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b1d1c17fc6cb0d6c7920d22e3a01ba2">&#9670;&nbsp;</a></span>ode_midpoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt; theoretica::ode_midpoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;(*)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integrate numerically a differential equation in N unknowns using the midpoint method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function which computes the derivative of the state </td></tr>
    <tr><td class="paramname">s</td><td>The current state of the ODE </td></tr>
    <tr><td class="paramname">h</td><td>Step size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a539a16b5d0d26731a5443e992c3a9631" name="a539a16b5d0d26731a5443e992c3a9631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a539a16b5d0d26731a5443e992c3a9631">&#9670;&nbsp;</a></span>ode_rk2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt; theoretica::ode_rk2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integrate numerically a differential equation in one unknown using Runge-Kutta's method of second order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function which computes the derivative of the state </td></tr>
    <tr><td class="paramname">s</td><td>The current state of the ODE </td></tr>
    <tr><td class="paramname">h</td><td>Step size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d79a2989ae9ffe1f84e3011e6201db0" name="a9d79a2989ae9ffe1f84e3011e6201db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d79a2989ae9ffe1f84e3011e6201db0">&#9670;&nbsp;</a></span>ode_rk2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt; theoretica::ode_rk2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;(*)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integrate numerically a differential equation in N unknowns using Runge-Kutta's method of second order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function which computes the derivative of the state </td></tr>
    <tr><td class="paramname">s</td><td>The current state of the ODE </td></tr>
    <tr><td class="paramname">h</td><td>Step size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7dac900a06e7496e947bdf4764d8ead2" name="a7dac900a06e7496e947bdf4764d8ead2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dac900a06e7496e947bdf4764d8ead2">&#9670;&nbsp;</a></span>ode_rk4() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt; theoretica::ode_rk4 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integrate numerically a differential equation in one unknown using Runge-Kutta's method of fourth order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function which computes the derivative of the state </td></tr>
    <tr><td class="paramname">s</td><td>The current state of the ODE </td></tr>
    <tr><td class="paramname">h</td><td>Step size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a832fa924210cf7bb22186433282c8080" name="a832fa924210cf7bb22186433282c8080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832fa924210cf7bb22186433282c8080">&#9670;&nbsp;</a></span>ode_rk4() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt; theoretica::ode_rk4 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;(*)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integrate numerically a differential equation in N unknowns using Runge-Kutta's method of fourth order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function which computes the derivative of the state </td></tr>
    <tr><td class="paramname">s</td><td>The current state of the ODE </td></tr>
    <tr><td class="paramname">h</td><td>Step size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9628d333f307cc0dfe8578f29146615" name="aa9628d333f307cc0dfe8578f29146615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9628d333f307cc0dfe8578f29146615">&#9670;&nbsp;</a></span>pad2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnsignedIntType  = uint64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UnsignedIntType theoretica::pad2 </td>
          <td>(</td>
          <td class="paramtype">UnsignedIntType&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the smallest power 2 bigger or equal to x. </p>
<p >This function is useful to add padding to vectors and matrices to apply recursive algorithms such as the FFT. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>An integer number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest power of 2 bigger or equal to x </dd></dl>

</div>
</div>
<a id="a13248f2e439afdb6f72e0f2c1e79cc55" name="a13248f2e439afdb6f72e0f2c1e79cc55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13248f2e439afdb6f72e0f2c1e79cc55">&#9670;&nbsp;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = real&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> T theoretica::pow </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the n-th power of x (where n is natural) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Any element of a multiplicative algebra </td></tr>
    <tr><td class="paramname">n</td><td>The integer exponent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x to the power n </dd></dl>

</div>
</div>
<a id="a6f12dd8e0fc650fa75c9961e51d1406c" name="a6f12dd8e0fc650fa75c9961e51d1406c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f12dd8e0fc650fa75c9961e51d1406c">&#9670;&nbsp;</a></span>powf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::powf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate x elevated to a real exponent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
    <tr><td class="paramname">a</td><td>A real exponent</td></tr>
  </table>
  </dd>
</dl>
<p>Approximated as \(e^{a ln(|x|) sgn(x)}\) </p>

</div>
</div>
<a id="ad9e2f9b3a40981abbab7c998c4fb1554" name="ad9e2f9b3a40981abbab7c998c4fb1554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e2f9b3a40981abbab7c998c4fb1554">&#9670;&nbsp;</a></span>pvalue_chi_squared()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::pvalue_chi_squared </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>chi_sqr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ndf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the (right-tailed) p-value associated to a computed Chi-square value as the integral of the Chi-squared distribution from the given value to infinity (right-tailed). </p>
<p >An equivalent integral is computed using Gauss-Laguerre quadrature: \( p = \frac{e^{-X^2}}{2 \Gamma (k/2)} \int_0^{+\infty} (\sqrt{x + X^2})^{k - 2} e^{-x} dx \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chi_sqr</td><td>The computed Chi-squared </td></tr>
    <tr><td class="paramname">ndf</td><td>Number of Degrees of Freedom </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The computed p-value </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The current implementation has reduced precision for 260 &lt;= ndf &lt; 1000 because for ndf &gt;= 260 the Gaussian approximation is used, which becomes more precise the higher the ndf. </dd></dl>

</div>
</div>
<a id="aa7e523c1cc3621e7cbc1ac0df01913c3" name="aa7e523c1cc3621e7cbc1ac0df01913c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e523c1cc3621e7cbc1ac0df01913c3">&#9670;&nbsp;</a></span>qrand_weyl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::qrand_weyl </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>alpha</em> = <code><a class="el" href="namespacetheoretica.html#a6a6de16e5ee81d340ff91dbadb99edde">INVPHI</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Weyl quasi-random sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the element in the sequence </td></tr>
    <tr><td class="paramname">alpha</td><td>The base of the sequence, defaults to the inverse of the Golden Section</td></tr>
  </table>
  </dd>
</dl>
<p>The Weyl sequence is defined as \(x_n = \{n \alpha\}\), where \(\{ \}\) is the fractional part. </p><dl class="section note"><dt>Note</dt><dd>The alpha argument should be an irrational number. </dd></dl>

</div>
</div>
<a id="ac1d4be50bf77c6b368c94bb627305224" name="ac1d4be50bf77c6b368c94bb627305224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1d4be50bf77c6b368c94bb627305224">&#9670;&nbsp;</a></span>qrand_weyl2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a1f21bd68ba64b172c29d9fce15c8712d">vec2</a> theoretica::qrand_weyl2 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>0.7548776662466927</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Weyl quasi-random sequence in 2 dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the element in the sequence </td></tr>
    <tr><td class="paramname">alpha</td><td>The base of the sequence</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The alpha argument should be an irrational number. </dd></dl>

</div>
</div>
<a id="a216195a1bbd4fed54c50cce034e48bfa" name="a216195a1bbd4fed54c50cce034e48bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a216195a1bbd4fed54c50cce034e48bfa">&#9670;&nbsp;</a></span>qrand_weyl_multi()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; theoretica::qrand_weyl_multi </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Weyl quasi-random sequence in N dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the element in the sequence </td></tr>
    <tr><td class="paramname">alpha</td><td>The base of the sequence</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The alpha argument should be an irrational number. </dd></dl>

</div>
</div>
<a id="a6c5001951408c716ce4e6414cc45f420" name="a6c5001951408c716ce4e6414cc45f420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c5001951408c716ce4e6414cc45f420">&#9670;&nbsp;</a></span>qrand_weyl_recurr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::qrand_weyl_recurr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>prev</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>alpha</em> = <code><a class="el" href="namespacetheoretica.html#a6a6de16e5ee81d340ff91dbadb99edde">INVPHI</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Weyl quasi-random sequence (computed with recurrence relation) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prev</td><td>The previously computed value </td></tr>
    <tr><td class="paramname">alpha</td><td>The base of the sequence, defaults to the inverse of the Golden Section</td></tr>
  </table>
  </dd>
</dl>
<p>If no arguments are provided or prev is zero, the function computes the first element of the Weyl sequence associated to the parameter alpha. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetheoretica.html#aa7e523c1cc3621e7cbc1ac0df01913c3" title="Weyl quasi-random sequence.">qrand_weyl</a> </dd></dl>

</div>
</div>
<a id="a286f4d2ae42de1965c86c999927f128b" name="a286f4d2ae42de1965c86c999927f128b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a286f4d2ae42de1965c86c999927f128b">&#9670;&nbsp;</a></span>radians()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::radians </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>degrees</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert degrees to radians. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degrees</td><td>An angle in degrees </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted angle in radians</dd></dl>
<p>The <code>DEG2RAD</code> scalar factor is used. </p>

</div>
</div>
<a id="a473df88a9edd9ccc8dcf03665591575b" name="a473df88a9edd9ccc8dcf03665591575b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a473df88a9edd9ccc8dcf03665591575b">&#9670;&nbsp;</a></span>rand_cauchy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_cauchy </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper for rand_cauchy(real, real, PRNG) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>The parameters of the distribution </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada12d3bc9842b85e97e14f0eb975e132" name="ada12d3bc9842b85e97e14f0eb975e132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada12d3bc9842b85e97e14f0eb975e132">&#9670;&nbsp;</a></span>rand_cointoss() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_cointoss </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper for rand_cointoss(PRNG) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>The parameters of the distribution </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99ddd9fc13f4c8b28ea4025640cbadf4" name="a99ddd9fc13f4c8b28ea4025640cbadf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99ddd9fc13f4c8b28ea4025640cbadf4">&#9670;&nbsp;</a></span>rand_cointoss() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_cointoss </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Coin toss random generator. </p>
<p >Extracts 1 or -1 with equal probability.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36a41f7dda7d0ad8cc8a4559afcf2ad7" name="a36a41f7dda7d0ad8cc8a4559afcf2ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a41f7dda7d0ad8cc8a4559afcf2ad7">&#9670;&nbsp;</a></span>rand_congruential() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::rand_congruential </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Congruential pseudorandom number generation algorithm (wrapper) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The current recurrence value of the algorithm (x_n) </td></tr>
    <tr><td class="paramname">state</td><td>A vector containing the state of the algorithm (a, c, m in this order) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next generated pseudorandom number</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetheoretica.html#ab1025a8b933cfe7077936c4be27971c1" title="Congruential pseudorandom number generation algorithm.">rand_congruential</a> </dd></dl>

</div>
</div>
<a id="ab1025a8b933cfe7077936c4be27971c1" name="ab1025a8b933cfe7077936c4be27971c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1025a8b933cfe7077936c4be27971c1">&#9670;&nbsp;</a></span>rand_congruential() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::rand_congruential </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>a</em> = <code>48271</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>c</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>m</em> = <code>((uint64_t)&#160;1&#160;&lt;&lt;&#160;31)&#160;-&#160;1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Congruential pseudorandom number generation algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The current recurrence value of the algorithm (x_n) </td></tr>
    <tr><td class="paramname">a</td><td>The multiplier term </td></tr>
    <tr><td class="paramname">c</td><td>The increment term </td></tr>
    <tr><td class="paramname">m</td><td>The modulus term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next generated pseudorandom number</dd></dl>
<p>The congruential generator is defined by the recurrence formula \(x_{n+1} = (a x_n + c) mod m\) <br  />
If no parameters are passed, the generator defaults to a = 48271, c = 0, m = (1 &lt;&lt; 31) - 1. </p>

</div>
</div>
<a id="a709a55686cbd545429284beb16eef7b7" name="a709a55686cbd545429284beb16eef7b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a709a55686cbd545429284beb16eef7b7">&#9670;&nbsp;</a></span>rand_diceroll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_diceroll </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper for rand_diceroll(PRNG) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>The parameters of the distribution </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a968bc8465bcb421983d457b96469e9ef" name="a968bc8465bcb421983d457b96469e9ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a968bc8465bcb421983d457b96469e9ef">&#9670;&nbsp;</a></span>rand_diceroll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_diceroll </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dice roll random generator. </p>
<p >Extracts a random natural number in [1, faces] with equal probability.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">faces</td><td>The number of faces of the dice </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2e6165f6c783179d1b3c2e321b3e7d4" name="aa2e6165f6c783179d1b3c2e321b3e7d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e6165f6c783179d1b3c2e321b3e7d4">&#9670;&nbsp;</a></span>rand_exponential()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_exponential </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper for rand_exponential(real, PRNG) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>The parameters of the distribution </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad2c1865b7a5639ed82643a069554e3d" name="aad2c1865b7a5639ed82643a069554e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad2c1865b7a5639ed82643a069554e3d">&#9670;&nbsp;</a></span>rand_gaussian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_gaussian </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper for rand_gaussian(real, real, PRNG) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>The parameters of the distribution </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91d0c9531b268c00e759cb571422e01f" name="a91d0c9531b268c00e759cb571422e01f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91d0c9531b268c00e759cb571422e01f">&#9670;&nbsp;</a></span>rand_gaussian_boxmuller()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_gaussian_boxmuller </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a random number following a Gaussian distribution using the Box-Muller method. </p>
<dl class="section note"><dt>Note</dt><dd>This function may not be thread-safe as it uses static variables to keep track of spare generated values. </dd></dl>

</div>
</div>
<a id="a8c36b22d9b1f9f2beeab1c7be35fe8b3" name="a8c36b22d9b1f9f2beeab1c7be35fe8b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c36b22d9b1f9f2beeab1c7be35fe8b3">&#9670;&nbsp;</a></span>rand_gaussian_clt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_gaussian_clt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a random number in a range following a Gaussian distribution by exploiting the Central Limit Theorem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mean</td><td>The mean of the target distribution </td></tr>
    <tr><td class="paramname">sigma</td><td>The sigma of the target distribution </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a></td></tr>
  </table>
  </dd>
</dl>
<p>Exactly 12 real numbers in a range are generated and the mean is computed to get a single real number following (asymptotically) a Gaussian distribution. </p>

</div>
</div>
<a id="af2b8d1fc98c8429d4b342e860cab6ed1" name="af2b8d1fc98c8429d4b342e860cab6ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b8d1fc98c8429d4b342e860cab6ed1">&#9670;&nbsp;</a></span>rand_gaussian_clt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_gaussian_clt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a random number in a range following a Gaussian distribution by exploiting the Central Limit Theorem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mean</td><td>The mean of the target distribution </td></tr>
    <tr><td class="paramname">sigma</td><td>The sigma of the target distribution </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
    <tr><td class="paramname">N</td><td>The number of random numbers to generate</td></tr>
  </table>
  </dd>
</dl>
<p>Many real numbers in a range are generated and the mean is computed to get a single real number following (asymptotically) a Gaussian distribution.</p>
<dl class="section note"><dt>Note</dt><dd>This function uses a square root (th::sqrt) to rescale the output for variable N, the constant N implementation has better performance. </dd></dl>

</div>
</div>
<a id="ac8bdf0dc89459fedaf6950c0f9b96df5" name="ac8bdf0dc89459fedaf6950c0f9b96df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8bdf0dc89459fedaf6950c0f9b96df5">&#9670;&nbsp;</a></span>rand_gaussian_polar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_gaussian_polar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a random number following a Gaussian distribution using Marsaglia's polar method. </p>
<dl class="section note"><dt>Note</dt><dd>This function may not be thread-safe as it uses static variables to keep track of spare generated values. </dd></dl>

</div>
</div>
<a id="ab7c6bc4e4c3bc2e859b5ff1e4b344df4" name="ab7c6bc4e4c3bc2e859b5ff1e4b344df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7c6bc4e4c3bc2e859b5ff1e4b344df4">&#9670;&nbsp;</a></span>rand_middlesquare() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::rand_middlesquare </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>765872292751861</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Middle-square pseudorandom number generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>The (changing) seed of the algorithm</td></tr>
  </table>
  </dd>
</dl>
<p>An offset is added to the 64-bit seed and the result is squared, taking the middle 64-bit of the 128-bit result. </p>

</div>
</div>
<a id="abc42228ba03a0f01c33d192ba87766a9" name="abc42228ba03a0f01c33d192ba87766a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc42228ba03a0f01c33d192ba87766a9">&#9670;&nbsp;</a></span>rand_middlesquare() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::rand_middlesquare </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Middle-square pseudorandom number generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The seed of the algorithm </td></tr>
    <tr><td class="paramname">p</td><td>Algorithm parameters, p[0] is the offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae66a655f57ef0f6e436dfc03e800585b" name="ae66a655f57ef0f6e436dfc03e800585b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66a655f57ef0f6e436dfc03e800585b">&#9670;&nbsp;</a></span>rand_pareto()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_pareto </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper for rand_pareto(real, real, PRNG) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>The parameters of the distribution </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a012d14c9ef85d6f3028bf8ceb1008787" name="a012d14c9ef85d6f3028bf8ceb1008787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a012d14c9ef85d6f3028bf8ceb1008787">&#9670;&nbsp;</a></span>rand_rayleigh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_rayleigh </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper for rand_rayleigh(real, PRNG) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>The parameters of the distribution </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e708ed0859828011f0d262c93274ec3" name="a7e708ed0859828011f0d262c93274ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e708ed0859828011f0d262c93274ec3">&#9670;&nbsp;</a></span>rand_rejectsamp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_rejectsamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ac7a0bafb035970e4921b84f75661e2b1">stat_function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>Pinv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_tries</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a random number following any given distribution using rejection sampling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Target distribution </td></tr>
    <tr><td class="paramname">theta</td><td>The parameters of the target distribution </td></tr>
    <tr><td class="paramname">p</td><td>Proposal distribution </td></tr>
    <tr><td class="paramname">Pinv</td><td>Inverse cumulative function of the proposal distribution </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
    <tr><td class="paramname">max_tries</td><td>Maximum number of tries before stopping execution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a058181f973ba2744704e6c6211477a35" name="a058181f973ba2744704e6c6211477a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058181f973ba2744704e6c6211477a35">&#9670;&nbsp;</a></span>rand_splitmix64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::rand_splitmix64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SplitMix64 pseudorandom number generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The 64-bit state of the algorithm</td></tr>
  </table>
  </dd>
</dl>
<p>Adapted from the reference implementation by Sebastiano Vigna </p>

</div>
</div>
<a id="ad198dee1300488d1b3e51767d62beedf" name="ad198dee1300488d1b3e51767d62beedf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad198dee1300488d1b3e51767d62beedf">&#9670;&nbsp;</a></span>rand_splitmix64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::rand_splitmix64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SplitMix64 pseudorandom number generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The 64-bit state of the algorithm </td></tr>
    <tr><td class="paramname">p</td><td>Dummy variable (needed for function signature) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39df0b112f893ca611b133774bcc76b8" name="a39df0b112f893ca611b133774bcc76b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39df0b112f893ca611b133774bcc76b8">&#9670;&nbsp;</a></span>rand_trycatch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_trycatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ac7a0bafb035970e4921b84f75661e2b1">stat_function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#a3299f783527ae72a24c832a7b1cd8ef8">MAX_TRYANDCATCH_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a pseudorandom value following any probability distribution function using the Try-and-Catch (rejection) algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A probability distribution function </td></tr>
    <tr><td class="paramname">theta</td><td>The parameters of the pdf </td></tr>
    <tr><td class="paramname">x1</td><td>The left extreme of the rectangle </td></tr>
    <tr><td class="paramname">x2</td><td>The right extreme of the rectangle </td></tr>
    <tr><td class="paramname">y1</td><td>The lower extreme of the rectangle </td></tr>
    <tr><td class="paramname">y2</td><td>The upper extreme of the rectangle </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> to use for number generation </td></tr>
    <tr><td class="paramname">max_iter</td><td>The maximum number of failed generations before stopping execution (defaults to MAX_TRYANDCATCH_ITER) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A real number following the given pdf</dd></dl>
<p>Random real numbers are generated inside a rectangle defined by x1, x2, y1 and y2 following a uniform distribution. Only numbers below the pdf are returned. </p>

</div>
</div>
<a id="ad7e77a1836e1b966cdbb0934d5ebbbf2" name="ad7e77a1836e1b966cdbb0934d5ebbbf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e77a1836e1b966cdbb0934d5ebbbf2">&#9670;&nbsp;</a></span>rand_uniform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_uniform </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper for rand_uniform(real, real, PRNG) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>The parameters of the distribution </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a35e29644875a5421b3ac4d7203c28a" name="a6a35e29644875a5421b3ac4d7203c28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a35e29644875a5421b3ac4d7203c28a">&#9670;&nbsp;</a></span>rand_uniform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_uniform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="namespacetheoretica.html#a0e48eab9ce5928d0c754a40ddb2d068f">RAND_REAL_PREC</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a pseudorandom real number in [a, b] using a preexisting generator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The lower extreme of the interval </td></tr>
    <tr><td class="paramname">b</td><td>The higher extreme of the interval </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized pseudorandom number generator </td></tr>
    <tr><td class="paramname">prec</td><td>Precision parameters for the normalization, defaults to RAND_REAL_PREC.</td></tr>
  </table>
  </dd>
</dl>
<p>The algorithm generates a random integer number, computes its modulus and divides it by prec: \(x = \frac{(n mod p)}{2^p}\), where n is the random integer and p is the prec parameter </p>

</div>
</div>
<a id="a470e255aed45a7dba74af4af68b31d0d" name="a470e255aed45a7dba74af4af68b31d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a470e255aed45a7dba74af4af68b31d0d">&#9670;&nbsp;</a></span>rand_wyrand() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::rand_wyrand </td>
          <td>(</td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wyrand pseudorandom number generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>The (changing) seed of the algorithm </td></tr>
    <tr><td class="paramname">p0</td><td>Additive constant (ideally a large prime number) </td></tr>
    <tr><td class="paramname">p1</td><td>Mask for the algorithm</td></tr>
  </table>
  </dd>
</dl>
<p>Algorithm by Yi Wang </p>

</div>
</div>
<a id="a5deb3df62eb53ec187a4660d42d8d5f1" name="a5deb3df62eb53ec187a4660d42d8d5f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5deb3df62eb53ec187a4660d42d8d5f1">&#9670;&nbsp;</a></span>rand_wyrand() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::rand_wyrand </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wyrand pseudorandom number generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Dummy variable </td></tr>
    <tr><td class="paramname">p</td><td>Algorithm parameters</td></tr>
  </table>
  </dd>
</dl>
<p>p[0] is the initial seed, p[1] a large prime number and p[2] is the bit mask. </p>

</div>
</div>
<a id="aed6faedb3d913a589365b108f5ec304e" name="aed6faedb3d913a589365b108f5ec304e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed6faedb3d913a589365b108f5ec304e">&#9670;&nbsp;</a></span>rand_xoshiro() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::rand_xoshiro </td>
          <td>(</td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Xoshiro256++ pseudorandom number generation algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Dummy parameter (needed for function signature) </td></tr>
    <tr><td class="paramname">state</td><td>The four 64-bit integer state of the algorithm</td></tr>
  </table>
  </dd>
</dl>
<p>Adapted from the reference implementation by Sebastiano Vigna </p>

</div>
</div>
<a id="a13b30362a1d08c8522c5297efd6f4a47" name="a13b30362a1d08c8522c5297efd6f4a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b30362a1d08c8522c5297efd6f4a47">&#9670;&nbsp;</a></span>rand_xoshiro() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::rand_xoshiro </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Xoshiro256++ pseudorandom number generation algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Dummy parameter (needed for function signature) </td></tr>
    <tr><td class="paramname">state</td><td>The four 64-bit integer state of the algorithm </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11d4ff06b43d112a71509f9798619dcd" name="a11d4ff06b43d112a71509f9798619dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d4ff06b43d112a71509f9798619dcd">&#9670;&nbsp;</a></span>rms()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dataset &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rms </td>
          <td>(</td>
          <td class="paramtype">const Dataset &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the quadratic mean (Root Mean Square) of a set of values \(m_q = \sqrt{x_1^2 + x_2^2 + ...}\). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetheoretica.html#a9473c3dfdbe71e408fb3241d458254c0" title="Compute the quadratic mean (Root Mean Square) of a set of values .">quadratic_mean</a> </dd></dl>

</div>
</div>
<a id="acf52f04c3a1cefbb9dabab21cac0abbb" name="acf52f04c3a1cefbb9dabab21cac0abbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf52f04c3a1cefbb9dabab21cac0abbb">&#9670;&nbsp;</a></span>root()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::root </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the n-th root of x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
    <tr><td class="paramname">n</td><td>The root number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The n-th real root of x</dd></dl>
<p>The Newton-Raphson method is used, limited by the <code>THEORETICA_MAX_NEWTON_ITER</code> macro constant. </p>

</div>
</div>
<a id="aa801269604efdfd3b558948555da3d51" name="aa801269604efdfd3b558948555da3d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa801269604efdfd3b558948555da3d51">&#9670;&nbsp;</a></span>root_newton()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a> theoretica::root_newton </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt;&gt;(*)(<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt;&gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt;&gt;(*)(<a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt;&gt;)&#160;</td>
          <td class="paramname"><em>df</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt;&gt;&#160;</td>
          <td class="paramname"><em>guess</em> = <code><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt;&gt;(0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacetheoretica.html#ae3a871a5ce0e15ea45205f3e15eec423">NEWTON_RAPHSON_TOL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#a09bde3716d7598748a55fa65c9abb6e3">MAX_NEWTON_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate a root of an arbitrary complex function using Newton's method,. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The complex function to find the root of </td></tr>
    <tr><td class="paramname">df</td><td>The derivative of the function </td></tr>
    <tr><td class="paramname">guess</td><td>The initial guess, defaults to 0 </td></tr>
    <tr><td class="paramname">tolerance</td><td>The minimum tolerance to stop the algorithm when reached. </td></tr>
    <tr><td class="paramname">max_iter</td><td>The maximum number of iterations before stopping the algorithm. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a389c95a049e94d34f94da914afdde6d6" name="a389c95a049e94d34f94da914afdde6d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a389c95a049e94d34f94da914afdde6d6">&#9670;&nbsp;</a></span>roots() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Field &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Field &gt; theoretica::roots </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; Field &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacetheoretica.html#a28fc38a93f999c3c98056f3dac665f42">BISECTION_APPROX_TOL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>steps</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the roots of a polynomial. </p>
<p >A bound on roots is found using Cauchy's theorem. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The polynomial </td></tr>
    <tr><td class="paramname">steps</td><td>The number of steps to use (defaults to twice the polynomial's order) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of the roots of the polynomial </dd></dl>

</div>
</div>
<a id="a20336c8a6fb0653a8fe5c5f8bdf867f4" name="a20336c8a6fb0653a8fe5c5f8bdf867f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20336c8a6fb0653a8fe5c5f8bdf867f4">&#9670;&nbsp;</a></span>roots() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; theoretica::roots </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacetheoretica.html#a28fc38a93f999c3c98056f3dac665f42">BISECTION_APPROX_TOL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>steps</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the roots of a function inside a given interval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function of real variable </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of the interval </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of the interval </td></tr>
    <tr><td class="paramname">steps</td><td>The number of subintervals to check for alternating sign (optional)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the number of roots inside the interval is completely unknown, using many more steps should be preferred, to ensure all roots are found. </dd></dl>

</div>
</div>
<a id="ad61e39abd4fd4cd8cd83add5d0752e2f" name="ad61e39abd4fd4cd8cd83add5d0752e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad61e39abd4fd4cd8cd83add5d0752e2f">&#9670;&nbsp;</a></span>sgn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int theoretica::sgn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the sign of x (1 if positive, -1 if negative, 0 if null) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sign of x </dd></dl>

</div>
</div>
<a id="a8679d2642c8820e78e33f7aa3294f7eb" name="a8679d2642c8820e78e33f7aa3294f7eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8679d2642c8820e78e33f7aa3294f7eb">&#9670;&nbsp;</a></span>shuffle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void theoretica::shuffle </td>
          <td>(</td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rounds</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shuffle a set by exchanging random couples of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The set to shuffle (as a Vector with [] and .size() methods) </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
    <tr><td class="paramname">rounds</td><td>The number of pairs to exchange (defaults to (N - 1)^2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a76685197faa15403e24b836830cf5d" name="a7a76685197faa15403e24b836830cf5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a76685197faa15403e24b836830cf5d">&#9670;&nbsp;</a></span>sigmoid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::sigmoid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the sigmoid function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sigmoid function for x defined as \(\frac{1}{1 + e^{-x}}\) </dd></dl>

</div>
</div>
<a id="a2dbb7d4dc0c7a5138e34212ddd8dcda2" name="a2dbb7d4dc0c7a5138e34212ddd8dcda2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dbb7d4dc0c7a5138e34212ddd8dcda2">&#9670;&nbsp;</a></span>sin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; theoretica::sin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computer the complex sine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c2ea0b1258dfe34df321901707d1808" name="a2c2ea0b1258dfe34df321901707d1808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c2ea0b1258dfe34df321901707d1808">&#9670;&nbsp;</a></span>sin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::sin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the sine of a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>An angle in <b>radians</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sine of x</dd></dl>
<p>On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fsin</code> instruction will be used. </p>

</div>
</div>
<a id="a1efe3bd7ff87719aab92b67cec535096" name="a1efe3bd7ff87719aab92b67cec535096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1efe3bd7ff87719aab92b67cec535096">&#9670;&nbsp;</a></span>sinc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::sinc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the normalized sinc function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The normalized sinc function for x defined as \(\frac{sin(\pi x)}{\pi x}\) </dd></dl>

</div>
</div>
<a id="a0650ea8e1435cc518e960bfcecf5b66e" name="a0650ea8e1435cc518e960bfcecf5b66e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0650ea8e1435cc518e960bfcecf5b66e">&#9670;&nbsp;</a></span>sinh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::sinh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the hyperbolic sine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic sine of x</dd></dl>
<p>\(sinh = \frac{e^x - e^{-x}}{2}\) </p>

</div>
</div>
<a id="a42af84f096a0f9e11fdb72d13990bd52" name="a42af84f096a0f9e11fdb72d13990bd52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42af84f096a0f9e11fdb72d13990bd52">&#9670;&nbsp;</a></span>sqrt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; theoretica::sqrt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the complex square root. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2e4cf02f9bcb4caf5371ee05d67df8d" name="aa2e4cf02f9bcb4caf5371ee05d67df8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e4cf02f9bcb4caf5371ee05d67df8d">&#9670;&nbsp;</a></span>sqrt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::sqrt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the square root of a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The square root of x</dd></dl>
<p>Domain: [0, +inf] <br  />
The Newton-Raphson algorithm, optimized for the square root and limited by the <code>THEORETICA_MAX_NEWTON_ITER</code> macro constant, is used. Domain reduction to [0, 1] is applied to ensure convergence of the algorithm. On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fsqrt</code> instruction will be used. </p>

</div>
</div>
<a id="af13ddee06543aa9aa3deb827efd44f63" name="af13ddee06543aa9aa3deb827efd44f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af13ddee06543aa9aa3deb827efd44f63">&#9670;&nbsp;</a></span>square() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; theoretica::square </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the square of a complex number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a726a5e18c863dc41040f5df134553fa9" name="a726a5e18c863dc41040f5df134553fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726a5e18c863dc41040f5df134553fa9">&#9670;&nbsp;</a></span>square() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::square </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the square of a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The square of x</dd></dl>
<p>Domain: [-inf, +inf] </p>

</div>
</div>
<a id="ae6ee9950a8eb3137d913d95ad9632f25" name="ae6ee9950a8eb3137d913d95ad9632f25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ee9950a8eb3137d913d95ad9632f25">&#9670;&nbsp;</a></span>sturm_liouville()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::sturm_liouville </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a9ac9a6f3d85bd0f6ae607178431e51a6">d_real</a>&lt; N &gt;(*)(<a class="el" href="classtheoretica_1_1vec.html">d_vec</a>&lt; N &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a9ac9a6f3d85bd0f6ae607178431e51a6">d_real</a>&lt; N &gt;(*)(<a class="el" href="classtheoretica_1_1vec.html">d_vec</a>&lt; N &gt;)&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt;&#160;</td>
          <td class="paramname"><em>eta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Sturm-Liouville operator on a generic function of the form \(f: \mathbb{R}^{2N} \rightarrow \mathbb{R}\) with respect to a given Hamiltonian function of the form \(H: \mathbb{R}^{2N} \rightarrow \mathbb{R}\) where the first N arguments are the coordinates in phase space and the last N arguments are the conjugate momenta, for a given point in phase space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to apply the operator to </td></tr>
    <tr><td class="paramname">H</td><td>The Hamiltonian </td></tr>
    <tr><td class="paramname">eta</td><td>A vector containing N = 2K elements, where the first K elements are the coordinates and the last K elements are the conjugate momenta. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae79e89f4decc976f7538fd4f5683d963" name="ae79e89f4decc976f7538fd4f5683d963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae79e89f4decc976f7538fd4f5683d963">&#9670;&nbsp;</a></span>sum() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto theoretica::sum </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the sum of a vector of real values using pairwise summation to reduce round-off error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The vector of values to sum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20960b2923a0c3c41b4db5452fa1dbf3" name="a20960b2923a0c3c41b4db5452fa1dbf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20960b2923a0c3c41b4db5452fa1dbf3">&#9670;&nbsp;</a></span>sum() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto theoretica::sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the sum of a vector of real values using pairwise summation to reduce round-off error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The vector of values to sum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec3305c4f7617c88a3e8ee4deb5b7ef0" name="aec3305c4f7617c88a3e8ee4deb5b7ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec3305c4f7617c88a3e8ee4deb5b7ef0">&#9670;&nbsp;</a></span>sum() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto theoretica::sum </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the sum of a set of values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The vector of values to sum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a173a64c4f73cb7abd476b739005d94e7" name="a173a64c4f73cb7abd476b739005d94e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173a64c4f73cb7abd476b739005d94e7">&#9670;&nbsp;</a></span>sum_compensated()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::sum_compensated </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the sum of a set of values using the compensated Neumaier-Kahan-Babushka summation algorithm to reduce round-off error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The vector of real values to sum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a97cfad96b9bb73d76b8f5cc20f2896" name="a2a97cfad96b9bb73d76b8f5cc20f2896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a97cfad96b9bb73d76b8f5cc20f2896">&#9670;&nbsp;</a></span>sum_pairwise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::sum_pairwise </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>begin</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>base_size</em> = <code>128</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the sum of a set of values using pairwise summation to reduce round-off error. </p>
<p >The function does not check for validity of begin and end indices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The vector of real values to sum </td></tr>
    <tr><td class="paramname">begin</td><td>The starting index of the sum, defaults to 0 </td></tr>
    <tr><td class="paramname">end</td><td>One plus the last index of the sum, defaults to X.size() </td></tr>
    <tr><td class="paramname">base_size</td><td>The size of the base case, defaults to 128 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92971816c6dda74903738b66ff69fb9c" name="a92971816c6dda74903738b66ff69fb9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92971816c6dda74903738b66ff69fb9c">&#9670;&nbsp;</a></span>tan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt; theoretica::tan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the complex tangent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe9d9a32dc2c9f00de35c1b1a49b218e" name="abe9d9a32dc2c9f00de35c1b1a49b218e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9d9a32dc2c9f00de35c1b1a49b218e">&#9670;&nbsp;</a></span>tan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::tan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the tangent of x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>An angle in <b>radians</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tangent of x</dd></dl>
<p>On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fsincos</code> instruction will be used. </p>

</div>
</div>
<a id="aaf6b8fc4bb2609507cd1fae0f7d6c8a7" name="aaf6b8fc4bb2609507cd1fae0f7d6c8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf6b8fc4bb2609507cd1fae0f7d6c8a7">&#9670;&nbsp;</a></span>tanh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::tanh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the hyperbolic tangent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic tangent of x </dd></dl>

</div>
</div>
<a id="ad8c492643bae592a0e15d4d54aca8a5c" name="ad8c492643bae592a0e15d4d54aca8a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c492643bae592a0e15d4d54aca8a5c">&#9670;&nbsp;</a></span>tss()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dataset &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::tss </td>
          <td>(</td>
          <td class="paramtype">const Dataset &amp;&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total sum of squares (TSS) Computed as \(\sum_i^n (x_i - x_{mean})^2 \). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetheoretica.html#aaccd3a2b293f4d080b5fa2655ed89d7a" title="Total sum of squares (TSS) equal to , computed using Welford&#39;s one-pass method to improve numerical s...">total_sum_squares</a> </dd></dl>

</div>
</div>
<a id="a04c17656f2680b638683e38d85c503dd" name="a04c17656f2680b638683e38d85c503dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c17656f2680b638683e38d85c503dd">&#9670;&nbsp;</a></span>z_score()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::z_score </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Z-score of an observed value with respect to a Gaussian distribution with the given parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The observed value </td></tr>
    <tr><td class="paramname">mean</td><td>The mean of the distribution </td></tr>
    <tr><td class="paramname">sigma</td><td>The standard deviation of the distribution </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Z-score of x, computed as (x - mean) / sigma </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacetheoretica.html">theoretica</a></li>
    <li class="footer">Generated on Mon May 27 2024 16:34:39 for Theoretica by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
