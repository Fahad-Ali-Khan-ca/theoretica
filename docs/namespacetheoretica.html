<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Theoretica: theoretica Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Theoretica
   </div>
   <div id="projectbrief">A C++ numerical and automatic mathematical library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacetheoretica.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">theoretica Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Main namespace of the library which contains all functions and objects.  
<a href="namespacetheoretica.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetheoretica_1_1distribution"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1distribution.html">distribution</a></td></tr>
<tr class="memdesc:namespacetheoretica_1_1distribution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Probability distribution functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetheoretica_1_1special"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1special.html">special</a></td></tr>
<tr class="memdesc:namespacetheoretica_1_1special"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetheoretica_1_1taylor"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica_1_1taylor.html">taylor</a></td></tr>
<tr class="memdesc:namespacetheoretica_1_1taylor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Taylor series expansions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1complex.html">complex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex number in algebraic form \(a + ib\).  <a href="classtheoretica_1_1complex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1dual.html">dual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dual number class.  <a href="classtheoretica_1_1dual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1dual2.html">dual2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Second order dual number class.  <a href="classtheoretica_1_1dual2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1mat.html">mat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic matrix with real entries.  <a href="classtheoretica_1_1mat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multidual number algebra for functions of the form \(f: \mathbb{R}^n \rightarrow \mathbb{R}\).  <a href="classtheoretica_1_1multidual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current state of an ODE integration for an N dimensional differential equation.  <a href="structtheoretica_1_1ode__state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtheoretica_1_1ode__state_3_011_01_4.html">ode_state&lt; 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtheoretica_1_1pdf__sampler.html">pdf_sampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A probability density function sampler which generates pseudorandom numbers following asymptotically a given distribution.  <a href="structtheoretica_1_1pdf__sampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1phasor.html">phasor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex number in exponential form \(\rho e^{i \theta}\).  <a href="classtheoretica_1_1phasor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A polynomial of arbitrary order.  <a href="classtheoretica_1_1polynomial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pseudorandom number generator.  <a href="classtheoretica_1_1_p_r_n_g.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1quat.html">quat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quaternion in the form \(a + bi + cj + dk\), stored as \((a + \vec v)\) where \(a \in \mathbb{R}\) and \(\vec v \in \mathbb{R}^3\).  <a href="classtheoretica_1_1quat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1ratio.html">ratio</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">representing a ratio between two objects, like a fraction or a rational polynomial.  <a href="classtheoretica_1_1ratio.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1vec.html">vec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An N-dimensional vector of T type elements.  <a href="classtheoretica_1_1vec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a33850a221dc370e7a23083dd94a9abed"><td class="memItemLeft" align="right" valign="top"><a id="a33850a221dc370e7a23083dd94a9abed" name="a33850a221dc370e7a23083dd94a9abed"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>mat2</b> = <a class="el" href="classtheoretica_1_1mat.html">mat</a>&lt; 2, 2 &gt;</td></tr>
<tr class="memdesc:a33850a221dc370e7a23083dd94a9abed"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2x2 matrix with real entries. <br /></td></tr>
<tr class="separator:a33850a221dc370e7a23083dd94a9abed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2899e9929670cbd58f39d6f1642ce19"><td class="memItemLeft" align="right" valign="top"><a id="ae2899e9929670cbd58f39d6f1642ce19" name="ae2899e9929670cbd58f39d6f1642ce19"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>mat3</b> = <a class="el" href="classtheoretica_1_1mat.html">mat</a>&lt; 3, 3 &gt;</td></tr>
<tr class="memdesc:ae2899e9929670cbd58f39d6f1642ce19"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3x3 matrix with real entries. <br /></td></tr>
<tr class="separator:ae2899e9929670cbd58f39d6f1642ce19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28e3d5a1e0743ea34a6c627c47b421b"><td class="memItemLeft" align="right" valign="top"><a id="ae28e3d5a1e0743ea34a6c627c47b421b" name="ae28e3d5a1e0743ea34a6c627c47b421b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>mat4</b> = <a class="el" href="classtheoretica_1_1mat.html">mat</a>&lt; 4, 4 &gt;</td></tr>
<tr class="memdesc:ae28e3d5a1e0743ea34a6c627c47b421b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 4x4 matrix with real entries. <br /></td></tr>
<tr class="separator:ae28e3d5a1e0743ea34a6c627c47b421b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78450ba4db2e132788cc0566b22848b9"><td class="memItemLeft" align="right" valign="top"><a id="a78450ba4db2e132788cc0566b22848b9" name="a78450ba4db2e132788cc0566b22848b9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>vec2</b> = <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; 2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;</td></tr>
<tr class="memdesc:a78450ba4db2e132788cc0566b22848b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2-dimensional vector with real elements. <br /></td></tr>
<tr class="separator:a78450ba4db2e132788cc0566b22848b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9580d98118f2e1692c1f5d6dbf3ea5"><td class="memItemLeft" align="right" valign="top"><a id="a3a9580d98118f2e1692c1f5d6dbf3ea5" name="a3a9580d98118f2e1692c1f5d6dbf3ea5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>vec3</b> = <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; 3, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;</td></tr>
<tr class="memdesc:a3a9580d98118f2e1692c1f5d6dbf3ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3-dimensional vector with real elements. <br /></td></tr>
<tr class="separator:a3a9580d98118f2e1692c1f5d6dbf3ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b773a1d88bcfb2a577b25224fe5477"><td class="memItemLeft" align="right" valign="top"><a id="aa5b773a1d88bcfb2a577b25224fe5477" name="aa5b773a1d88bcfb2a577b25224fe5477"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>vec4</b> = <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; 4, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;</td></tr>
<tr class="memdesc:aa5b773a1d88bcfb2a577b25224fe5477"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 4-dimensional vector with real elements. <br /></td></tr>
<tr class="separator:aa5b773a1d88bcfb2a577b25224fe5477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049966946220f1f7e5eae57293703066"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> = double</td></tr>
<tr class="memdesc:a049966946220f1f7e5eae57293703066"><td class="mdescLeft">&#160;</td><td class="mdescRight">A real number, defined as a floating point type.  <a href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">More...</a><br /></td></tr>
<tr class="separator:a049966946220f1f7e5eae57293703066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60d62492ac4137c837c50b1fdc8a904"><td class="memItemLeft" align="right" valign="top"><a id="ad60d62492ac4137c837c50b1fdc8a904" name="ad60d62492ac4137c837c50b1fdc8a904"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>real_function</b> = std::function&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>)&gt;</td></tr>
<tr class="memdesc:ad60d62492ac4137c837c50b1fdc8a904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointer to a real function. <br /></td></tr>
<tr class="separator:ad60d62492ac4137c837c50b1fdc8a904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e54892f67a30eff9bede88ed8aad65"><td class="memItemLeft" align="right" valign="top"><a id="aa4e54892f67a30eff9bede88ed8aad65" name="aa4e54892f67a30eff9bede88ed8aad65"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>complex_function</b> = std::function&lt; <a class="el" href="classtheoretica_1_1complex.html">complex</a>(<a class="el" href="classtheoretica_1_1complex.html">complex</a>)&gt;</td></tr>
<tr class="memdesc:aa4e54892f67a30eff9bede88ed8aad65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointer to a complex function. <br /></td></tr>
<tr class="separator:aa4e54892f67a30eff9bede88ed8aad65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5955d73b5602813dca8d4d64bed8466d"><td class="memItemLeft" align="right" valign="top"><a id="a5955d73b5602813dca8d4d64bed8466d" name="a5955d73b5602813dca8d4d64bed8466d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>stat_function</b> = std::function&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a5955d73b5602813dca8d4d64bed8466d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointer to a statistical function. <br /></td></tr>
<tr class="separator:a5955d73b5602813dca8d4d64bed8466d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a50102b320dcdc6a61e5a15234327a7"><td class="memItemLeft" align="right" valign="top"><a id="a9a50102b320dcdc6a61e5a15234327a7" name="a9a50102b320dcdc6a61e5a15234327a7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>vec_buff</b> = std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;</td></tr>
<tr class="memdesc:a9a50102b320dcdc6a61e5a15234327a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamically allocated variable-size container Defined by default as an alias for <code>std::vector&lt;real&gt;</code> <br /></td></tr>
<tr class="separator:a9a50102b320dcdc6a61e5a15234327a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4ba8e2a5511c5650d331d0209013ff"><td class="memItemLeft" align="right" valign="top"><a id="adb4ba8e2a5511c5650d331d0209013ff" name="adb4ba8e2a5511c5650d331d0209013ff"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>polyn_recurr_formula</b> = <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;(*)(<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;, <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;, unsigned int)</td></tr>
<tr class="memdesc:adb4ba8e2a5511c5650d331d0209013ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polynomial sequence recurrence formula type Used for computing orthogonal polynomial basis elements. <br /></td></tr>
<tr class="separator:adb4ba8e2a5511c5650d331d0209013ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f8bd44356f8184466e4cc0d6986fe5"><td class="memItemLeft" align="right" valign="top"><a id="a99f8bd44356f8184466e4cc0d6986fe5" name="a99f8bd44356f8184466e4cc0d6986fe5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pseudorandom_function</b> = uint64_t(*)(uint64_t, std::vector&lt; uint64_t &gt; &amp;)</td></tr>
<tr class="memdesc:a99f8bd44356f8184466e4cc0d6986fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pseudorandom function pointer. <br /></td></tr>
<tr class="separator:a99f8bd44356f8184466e4cc0d6986fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17352cbe273b80ae0f08eac818eba84e"><td class="memItemLeft" align="right" valign="top"><a id="a17352cbe273b80ae0f08eac818eba84e" name="a17352cbe273b80ae0f08eac818eba84e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pdf_sampling_function</b> = <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*)(const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;)</td></tr>
<tr class="memdesc:a17352cbe273b80ae0f08eac818eba84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A p.d.f sampling function taking as input the parameters of the distribution and a pseudorandom number generator. <br /></td></tr>
<tr class="separator:a17352cbe273b80ae0f08eac818eba84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a47d8f770edb576685f4b8752f2eb9760"><td class="memItemLeft" align="right" valign="top"><a id="a47d8f770edb576685f4b8752f2eb9760" name="a47d8f770edb576685f4b8752f2eb9760"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a47d8f770edb576685f4b8752f2eb9760">MATH_ERRCODE</a> { <br />
&#160;&#160;<b>NO_ERROR</b> = 0x00
, <b>DIV_BY_ZERO</b> = 0x01
, <b>OUT_OF_DOMAIN</b> = 0x02
, <b>OUT_OF_RANGE</b> = 0x04
, <br />
&#160;&#160;<b>IMPOSSIBLE_OPERATION</b> = 0x08
, <b>NO_ALGO_CONVERGENCE</b> = 0x10
, <b>INVALID_ARGUMENT</b> = 0x20
<br />
 }</td></tr>
<tr class="memdesc:a47d8f770edb576685f4b8752f2eb9760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Math error enumeration. <br /></td></tr>
<tr class="separator:a47d8f770edb576685f4b8752f2eb9760"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a42b0b721edddef75a47581c66048cb7e"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a42b0b721edddef75a47581c66048cb7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a42b0b721edddef75a47581c66048cb7e">lp_norm</a> (Vector v, unsigned int p)</td></tr>
<tr class="memdesc:a42b0b721edddef75a47581c66048cb7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Norms.  <a href="namespacetheoretica.html#a42b0b721edddef75a47581c66048cb7e">More...</a><br /></td></tr>
<tr class="separator:a42b0b721edddef75a47581c66048cb7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1180d17fc1d5e33e624efc299319b7bd"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a1180d17fc1d5e33e624efc299319b7bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a1180d17fc1d5e33e624efc299319b7bd">l1_norm</a> (Vector v)</td></tr>
<tr class="memdesc:a1180d17fc1d5e33e624efc299319b7bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the L1 norm of a vector.  <a href="namespacetheoretica.html#a1180d17fc1d5e33e624efc299319b7bd">More...</a><br /></td></tr>
<tr class="separator:a1180d17fc1d5e33e624efc299319b7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0dda0991b7f146cc8f53578508fef4f"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:ae0dda0991b7f146cc8f53578508fef4f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ae0dda0991b7f146cc8f53578508fef4f">l2_norm</a> (Vector v)</td></tr>
<tr class="memdesc:ae0dda0991b7f146cc8f53578508fef4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the L2 norm of a vector.  <a href="namespacetheoretica.html#ae0dda0991b7f146cc8f53578508fef4f">More...</a><br /></td></tr>
<tr class="separator:ae0dda0991b7f146cc8f53578508fef4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac209c3a6870eb4e610312a7725ccea9b"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:ac209c3a6870eb4e610312a7725ccea9b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ac209c3a6870eb4e610312a7725ccea9b">linf_norm</a> (Vector v)</td></tr>
<tr class="memdesc:ac209c3a6870eb4e610312a7725ccea9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Linf norm of a vector.  <a href="namespacetheoretica.html#ac209c3a6870eb4e610312a7725ccea9b">More...</a><br /></td></tr>
<tr class="separator:ac209c3a6870eb4e610312a7725ccea9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e24ba47041f2f97e910ae3ee472992"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:ad1e24ba47041f2f97e910ae3ee472992"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ad1e24ba47041f2f97e910ae3ee472992">euclidean_distance</a> (Vector v1, Vector v2)</td></tr>
<tr class="memdesc:ad1e24ba47041f2f97e910ae3ee472992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distances.  <a href="namespacetheoretica.html#ad1e24ba47041f2f97e910ae3ee472992">More...</a><br /></td></tr>
<tr class="separator:ad1e24ba47041f2f97e910ae3ee472992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40519afba97d201123e11622e86d97fe"><td class="memTemplParams" colspan="2"><a id="a40519afba97d201123e11622e86d97fe" name="a40519afba97d201123e11622e86d97fe"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a40519afba97d201123e11622e86d97fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>distance</b> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; v1, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; v2)</td></tr>
<tr class="memdesc:a40519afba97d201123e11622e86d97fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Euclidean distance between two vectors. <br /></td></tr>
<tr class="separator:a40519afba97d201123e11622e86d97fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4072e50f928983654dd1b9054218d4b6"><td class="memItemLeft" align="right" valign="top"><a id="a4072e50f928983654dd1b9054218d4b6" name="a4072e50f928983654dd1b9054218d4b6"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>euclidean_distance</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b)</td></tr>
<tr class="memdesc:a4072e50f928983654dd1b9054218d4b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Euclidian distance between two values. <br /></td></tr>
<tr class="separator:a4072e50f928983654dd1b9054218d4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd7ad59889c6379feb35b7bbbb88120"><td class="memItemLeft" align="right" valign="top"><a id="aebd7ad59889c6379feb35b7bbbb88120" name="aebd7ad59889c6379feb35b7bbbb88120"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>distance</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b)</td></tr>
<tr class="memdesc:aebd7ad59889c6379feb35b7bbbb88120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Euclidian distance between two values. <br /></td></tr>
<tr class="separator:aebd7ad59889c6379feb35b7bbbb88120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a6eed0e568f87133e154601e0ceff5"><td class="memItemLeft" align="right" valign="top"><a id="a86a6eed0e568f87133e154601e0ceff5" name="a86a6eed0e568f87133e154601e0ceff5"></a>
<a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><b>distance</b> (<a class="el" href="classtheoretica_1_1complex.html">complex</a> z1, <a class="el" href="classtheoretica_1_1complex.html">complex</a> z2)</td></tr>
<tr class="memdesc:a86a6eed0e568f87133e154601e0ceff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the distance between two complex numbers. <br /></td></tr>
<tr class="separator:a86a6eed0e568f87133e154601e0ceff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a48bb5731f4b4a617f9d36512d6fa6"><td class="memTemplParams" colspan="2"><a id="af9a48bb5731f4b4a617f9d36512d6fa6" name="af9a48bb5731f4b4a617f9d36512d6fa6"></a>
template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:af9a48bb5731f4b4a617f9d36512d6fa6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>minkowski_distance</b> (Vector v1, Vector v2, unsigned int p)</td></tr>
<tr class="memdesc:af9a48bb5731f4b4a617f9d36512d6fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Minkowski distance between two vectors. <br /></td></tr>
<tr class="separator:af9a48bb5731f4b4a617f9d36512d6fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09993b93cbd658a8a17acc0b118023a"><td class="memItemLeft" align="right" valign="top"><a id="af09993b93cbd658a8a17acc0b118023a" name="af09993b93cbd658a8a17acc0b118023a"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>minkowski_distance</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int p)</td></tr>
<tr class="memdesc:af09993b93cbd658a8a17acc0b118023a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Euclidian distance between two values. <br /></td></tr>
<tr class="separator:af09993b93cbd658a8a17acc0b118023a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2937a87f18f3045e0cc87043e7e9fe4"><td class="memTemplParams" colspan="2"><a id="ad2937a87f18f3045e0cc87043e7e9fe4" name="ad2937a87f18f3045e0cc87043e7e9fe4"></a>
template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:ad2937a87f18f3045e0cc87043e7e9fe4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>hermitian_distance</b> (Vector v1, Vector v2)</td></tr>
<tr class="memdesc:ad2937a87f18f3045e0cc87043e7e9fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Hermitian distance between two vectors. <br /></td></tr>
<tr class="separator:ad2937a87f18f3045e0cc87043e7e9fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c6e7bcc698e9b94b880ee531f48b92"><td class="memTemplParams" colspan="2"><a id="ac1c6e7bcc698e9b94b880ee531f48b92" name="ac1c6e7bcc698e9b94b880ee531f48b92"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ac1c6e7bcc698e9b94b880ee531f48b92"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>distance</b> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1complex.html">complex</a> &gt; v1, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1complex.html">complex</a> &gt; v2)</td></tr>
<tr class="memdesc:ac1c6e7bcc698e9b94b880ee531f48b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Hermitian distance between two vectors. <br /></td></tr>
<tr class="separator:ac1c6e7bcc698e9b94b880ee531f48b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5a21a76bd702c5943a65f7e4d5d0c5"><td class="memTemplParams" colspan="2"><a id="adc5a21a76bd702c5943a65f7e4d5d0c5" name="adc5a21a76bd702c5943a65f7e4d5d0c5"></a>
template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:adc5a21a76bd702c5943a65f7e4d5d0c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>manhattan_distance</b> (Vector v1, Vector v2)</td></tr>
<tr class="memdesc:adc5a21a76bd702c5943a65f7e4d5d0c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Manhattan distance between two vectors. <br /></td></tr>
<tr class="separator:adc5a21a76bd702c5943a65f7e4d5d0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7b7fe98b0b884d7d0bc4d7a92d99a3"><td class="memTemplParams" colspan="2"><a id="a4e7b7fe98b0b884d7d0bc4d7a92d99a3" name="a4e7b7fe98b0b884d7d0bc4d7a92d99a3"></a>
template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a4e7b7fe98b0b884d7d0bc4d7a92d99a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chebyshev_distance</b> (Vector v1, Vector v2)</td></tr>
<tr class="memdesc:a4e7b7fe98b0b884d7d0bc4d7a92d99a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Chebyshev distance between two vectors. <br /></td></tr>
<tr class="separator:a4e7b7fe98b0b884d7d0bc4d7a92d99a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee0f3f9343e42b8bf44c9a1c61c325f"><td class="memTemplParams" colspan="2"><a id="a0ee0f3f9343e42b8bf44c9a1c61c325f" name="a0ee0f3f9343e42b8bf44c9a1c61c325f"></a>
template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a0ee0f3f9343e42b8bf44c9a1c61c325f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>discrete_distance</b> (Vector v1, Vector v2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#aa34d8798921a9b3b78e885a455ff4211">MACH_EPSILON</a>)</td></tr>
<tr class="memdesc:a0ee0f3f9343e42b8bf44c9a1c61c325f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the discrete distance between two vectors. <br /></td></tr>
<tr class="separator:a0ee0f3f9343e42b8bf44c9a1c61c325f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc94c724aff435e5e1800eae756ef426"><td class="memTemplParams" colspan="2"><a id="acc94c724aff435e5e1800eae756ef426" name="acc94c724aff435e5e1800eae756ef426"></a>
template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:acc94c724aff435e5e1800eae756ef426"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>canberra_distance</b> (Vector v1, Vector v2)</td></tr>
<tr class="memdesc:acc94c724aff435e5e1800eae756ef426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Canberra distance between two vectors. <br /></td></tr>
<tr class="separator:acc94c724aff435e5e1800eae756ef426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb129dc6cf8ffa761ad0577874b8cf58"><td class="memTemplParams" colspan="2"><a id="abb129dc6cf8ffa761ad0577874b8cf58" name="abb129dc6cf8ffa761ad0577874b8cf58"></a>
template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:abb129dc6cf8ffa761ad0577874b8cf58"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cosine_distance</b> (Vector v1, Vector v2)</td></tr>
<tr class="memdesc:abb129dc6cf8ffa761ad0577874b8cf58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cosine distance between two vectors. <br /></td></tr>
<tr class="separator:abb129dc6cf8ffa761ad0577874b8cf58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80bc707212ab3e8dc68a28b2a79e506"><td class="memTemplParams" colspan="2"><a id="aa80bc707212ab3e8dc68a28b2a79e506" name="aa80bc707212ab3e8dc68a28b2a79e506"></a>
template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:aa80bc707212ab3e8dc68a28b2a79e506"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>hamming_distance</b> (Vector v1, Vector v2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#aa34d8798921a9b3b78e885a455ff4211">MACH_EPSILON</a>)</td></tr>
<tr class="memdesc:aa80bc707212ab3e8dc68a28b2a79e506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Hamming distance between two vectors. <br /></td></tr>
<tr class="separator:aa80bc707212ab3e8dc68a28b2a79e506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366f1e5bb803f8fd91eb4776ea382d7b"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a366f1e5bb803f8fd91eb4776ea382d7b"><td class="memTemplItemLeft" align="right" valign="top">Vector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a366f1e5bb803f8fd91eb4776ea382d7b">sphere_inversion</a> (const Vector &amp;p, const Vector &amp;c=Vector(0), <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> r=1)</td></tr>
<tr class="memdesc:a366f1e5bb803f8fd91eb4776ea382d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sphere inversion of a point with respect to a sphere of radius r centered at a point c.  <a href="namespacetheoretica.html#a366f1e5bb803f8fd91eb4776ea382d7b">More...</a><br /></td></tr>
<tr class="separator:a366f1e5bb803f8fd91eb4776ea382d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5759776d0fbb1355ee30b05ff7dc854"><td class="memTemplParams" colspan="2">template&lt;unsigned int N, typename T &gt; </td></tr>
<tr class="memitem:ab5759776d0fbb1355ee30b05ff7dc854"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ab5759776d0fbb1355ee30b05ff7dc854">sphere_inversion</a> (const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, T &gt; &amp;p, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, T &gt; &amp;c=<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, T &gt;(0), T r=T(1))</td></tr>
<tr class="memdesc:ab5759776d0fbb1355ee30b05ff7dc854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sphere inversion of a point with respect to a sphere of radius r centered at a point c.  <a href="namespacetheoretica.html#ab5759776d0fbb1355ee30b05ff7dc854">More...</a><br /></td></tr>
<tr class="separator:ab5759776d0fbb1355ee30b05ff7dc854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46133a50196ddb171e0cf6a16321c92c"><td class="memTemplParams" colspan="2"><a id="a46133a50196ddb171e0cf6a16321c92c" name="a46133a50196ddb171e0cf6a16321c92c"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a46133a50196ddb171e0cf6a16321c92c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>solve</b> (<a class="el" href="classtheoretica_1_1mat.html">mat</a>&lt; N, N &gt; A, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; b)</td></tr>
<tr class="memdesc:a46133a50196ddb171e0cf6a16321c92c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a linear system. <br /></td></tr>
<tr class="separator:a46133a50196ddb171e0cf6a16321c92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a702b5e6317a8cb92da28782d857ddc47"><td class="memTemplParams" colspan="2"><a id="a702b5e6317a8cb92da28782d857ddc47" name="a702b5e6317a8cb92da28782d857ddc47"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a702b5e6317a8cb92da28782d857ddc47"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1mat.html">mat</a>&lt; N, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>solve</b> (<a class="el" href="classtheoretica_1_1mat.html">mat</a>&lt; N, N &gt; A, <a class="el" href="classtheoretica_1_1mat.html">mat</a>&lt; N, N &gt; B)</td></tr>
<tr class="memdesc:a702b5e6317a8cb92da28782d857ddc47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a linear system. <br /></td></tr>
<tr class="separator:a702b5e6317a8cb92da28782d857ddc47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eeeb57f2d2b147c1dcddfca6ee0e93b"><td class="memTemplParams" colspan="2"><a id="a0eeeb57f2d2b147c1dcddfca6ee0e93b" name="a0eeeb57f2d2b147c1dcddfca6ee0e93b"></a>
template&lt;unsigned int N, typename T &gt; </td></tr>
<tr class="memitem:a0eeeb57f2d2b147c1dcddfca6ee0e93b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dot</b> (const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, T &gt; &amp;v1, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, T &gt; &amp;v2)</td></tr>
<tr class="memdesc:a0eeeb57f2d2b147c1dcddfca6ee0e93b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dot product of two vectors. <br /></td></tr>
<tr class="separator:a0eeeb57f2d2b147c1dcddfca6ee0e93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12940c0bd43e6edcabb9064ccfd6cc5a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a12940c0bd43e6edcabb9064ccfd6cc5a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; 3, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a12940c0bd43e6edcabb9064ccfd6cc5a">cross</a> (const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; 3, T &gt; &amp;v1, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; 3, T &gt; &amp;v2)</td></tr>
<tr class="memdesc:a12940c0bd43e6edcabb9064ccfd6cc5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cross product of two vectors.  <a href="namespacetheoretica.html#a12940c0bd43e6edcabb9064ccfd6cc5a">More...</a><br /></td></tr>
<tr class="separator:a12940c0bd43e6edcabb9064ccfd6cc5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29355ce24067808f588917c0e178408"><td class="memTemplParams" colspan="2"><a id="ac29355ce24067808f588917c0e178408" name="ac29355ce24067808f588917c0e178408"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ac29355ce24067808f588917c0e178408"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gradient</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; &gt;), const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;x)</td></tr>
<tr class="memdesc:ac29355ce24067808f588917c0e178408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient for a given \(\vec x\) of a function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\) using automatic differentiation. <br /></td></tr>
<tr class="separator:ac29355ce24067808f588917c0e178408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5203ee6ec2e50782ff24f725618cfce"><td class="memTemplParams" colspan="2"><a id="ae5203ee6ec2e50782ff24f725618cfce" name="ae5203ee6ec2e50782ff24f725618cfce"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ae5203ee6ec2e50782ff24f725618cfce"><td class="memTemplItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gradient</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; &gt;))</td></tr>
<tr class="memdesc:ae5203ee6ec2e50782ff24f725618cfce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a function which computes the gradient of a given function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\) at a given \(\vec x\) using automatic differentiation. <br /></td></tr>
<tr class="separator:ae5203ee6ec2e50782ff24f725618cfce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7945a9959534ed6da94246f568393cd2"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a7945a9959534ed6da94246f568393cd2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a7945a9959534ed6da94246f568393cd2">gradient_mono</a> (<a class="el" href="classtheoretica_1_1dual.html">dual</a>(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1dual.html">dual</a> &gt;), const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;x)</td></tr>
<tr class="memdesc:a7945a9959534ed6da94246f568393cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient for a given \(\vec x\) of a function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\) using automatic differentiation.  <a href="namespacetheoretica.html#a7945a9959534ed6da94246f568393cd2">More...</a><br /></td></tr>
<tr class="separator:a7945a9959534ed6da94246f568393cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e77327c03871aa02fa44593b5e9f4b2"><td class="memTemplParams" colspan="2"><a id="a7e77327c03871aa02fa44593b5e9f4b2" name="a7e77327c03871aa02fa44593b5e9f4b2"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a7e77327c03871aa02fa44593b5e9f4b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>divergence</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; &gt;), const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;x)</td></tr>
<tr class="memdesc:a7e77327c03871aa02fa44593b5e9f4b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the divergence for a given \(\vec x\) of a function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\) using automatic differentiation. <br /></td></tr>
<tr class="separator:a7e77327c03871aa02fa44593b5e9f4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31183bcff5b5a13b12b43bf0a524bca7"><td class="memTemplParams" colspan="2"><a id="a31183bcff5b5a13b12b43bf0a524bca7" name="a31183bcff5b5a13b12b43bf0a524bca7"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a31183bcff5b5a13b12b43bf0a524bca7"><td class="memTemplItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>divergence</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; &gt;))</td></tr>
<tr class="memdesc:a31183bcff5b5a13b12b43bf0a524bca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a function which computes the divergence of a given function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\) at a given \(\vec x\) using automatic differentiation. <br /></td></tr>
<tr class="separator:a31183bcff5b5a13b12b43bf0a524bca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01412973394e4d319502a0fed1f8a9da"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a01412973394e4d319502a0fed1f8a9da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a01412973394e4d319502a0fed1f8a9da">divergence_mono</a> (<a class="el" href="classtheoretica_1_1dual.html">dual</a>(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1dual.html">dual</a> &gt;), const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;x)</td></tr>
<tr class="memdesc:a01412973394e4d319502a0fed1f8a9da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the divergence for a given \(\vec x\) of a function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\) using automatic differentiation.  <a href="namespacetheoretica.html#a01412973394e4d319502a0fed1f8a9da">More...</a><br /></td></tr>
<tr class="separator:a01412973394e4d319502a0fed1f8a9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17677cb37084438facefae074e4b29c0"><td class="memTemplParams" colspan="2"><a id="a17677cb37084438facefae074e4b29c0" name="a17677cb37084438facefae074e4b29c0"></a>
template&lt;unsigned int N, unsigned int M&gt; </td></tr>
<tr class="memitem:a17677cb37084438facefae074e4b29c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1mat.html">mat</a>&lt; M, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>jacobian</b> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; M, <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; &gt;), const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;x)</td></tr>
<tr class="memdesc:a17677cb37084438facefae074e4b29c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the jacobian of a generic function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}^M\). <br /></td></tr>
<tr class="separator:a17677cb37084438facefae074e4b29c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c19c0d3c4e8be2ba1741ce1607ba7d"><td class="memTemplParams" colspan="2"><a id="aa3c19c0d3c4e8be2ba1741ce1607ba7d" name="aa3c19c0d3c4e8be2ba1741ce1607ba7d"></a>
template&lt;unsigned int N, unsigned int M&gt; </td></tr>
<tr class="memitem:aa3c19c0d3c4e8be2ba1741ce1607ba7d"><td class="memTemplItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classtheoretica_1_1mat.html">mat</a>&lt; M, N &gt;(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>jacobian</b> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; M, <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; &gt;))</td></tr>
<tr class="memdesc:aa3c19c0d3c4e8be2ba1741ce1607ba7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a function which computes the jacobian of a generic function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}^M\) for a given $\vec x$. <br /></td></tr>
<tr class="separator:aa3c19c0d3c4e8be2ba1741ce1607ba7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd3491e35e0644f25ac5217a6c01ec6"><td class="memItemLeft" align="right" valign="top"><a id="a3cd3491e35e0644f25ac5217a6c01ec6" name="a3cd3491e35e0644f25ac5217a6c01ec6"></a>
<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>curl</b> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; 3, <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; 3 &gt; &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; 3, <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; 3 &gt; &gt;), const <a class="el" href="namespacetheoretica.html#a3a9580d98118f2e1692c1f5d6dbf3ea5">vec3</a> &amp;x)</td></tr>
<tr class="memdesc:a3cd3491e35e0644f25ac5217a6c01ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the curl for a given \(\vec x\) of a vector field defined by \(f: \mathbb{R}^3 \rightarrow \mathbb{R}^3\) using automatic differentiation. <br /></td></tr>
<tr class="separator:a3cd3491e35e0644f25ac5217a6c01ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7b36a24acfe8061c48512e27c1456e"><td class="memItemLeft" align="right" valign="top"><a id="aaa7b36a24acfe8061c48512e27c1456e" name="aaa7b36a24acfe8061c48512e27c1456e"></a>
std::function&lt; <a class="el" href="namespacetheoretica.html#a3a9580d98118f2e1692c1f5d6dbf3ea5">vec3</a>(<a class="el" href="namespacetheoretica.html#a3a9580d98118f2e1692c1f5d6dbf3ea5">vec3</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>curl</b> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; 3, <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; 3 &gt; &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; 3, <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; 3 &gt; &gt;))</td></tr>
<tr class="memdesc:aaa7b36a24acfe8061c48512e27c1456e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a function which computes the curl for a given \(\vec x\) of a vector field defined by \(f: \mathbb{R}^3 \rightarrow \mathbb{R}^3\) using automatic differentiation. <br /></td></tr>
<tr class="separator:aaa7b36a24acfe8061c48512e27c1456e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed789cb9f8123584b3e1f1f9a334f47d"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:aed789cb9f8123584b3e1f1f9a334f47d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aed789cb9f8123584b3e1f1f9a334f47d">directional_derivative</a> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; &gt;), const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;x, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;v)</td></tr>
<tr class="memdesc:aed789cb9f8123584b3e1f1f9a334f47d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the directional derivative of a generic function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\).  <a href="namespacetheoretica.html#aed789cb9f8123584b3e1f1f9a334f47d">More...</a><br /></td></tr>
<tr class="separator:aed789cb9f8123584b3e1f1f9a334f47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2b544ce53ec2f8e548afadd59a52d5"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a4f2b544ce53ec2f8e548afadd59a52d5"><td class="memTemplItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a4f2b544ce53ec2f8e548afadd59a52d5">directional_derivative</a> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; &gt;), const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;v)</td></tr>
<tr class="memdesc:a4f2b544ce53ec2f8e548afadd59a52d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a function which computes the directional derivative of a generic function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\).  <a href="namespacetheoretica.html#a4f2b544ce53ec2f8e548afadd59a52d5">More...</a><br /></td></tr>
<tr class="separator:a4f2b544ce53ec2f8e548afadd59a52d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65eada1a479ebab6b5ae8ce46a34f251"><td class="memTemplParams" colspan="2"><a id="a65eada1a479ebab6b5ae8ce46a34f251" name="a65eada1a479ebab6b5ae8ce46a34f251"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a65eada1a479ebab6b5ae8ce46a34f251"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>laplacian</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1dual2.html">dual2</a> &gt;), const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; &amp;x)</td></tr>
<tr class="memdesc:a65eada1a479ebab6b5ae8ce46a34f251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the laplacian differential operator for a generic function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\) at a given $\vec x$. <br /></td></tr>
<tr class="separator:a65eada1a479ebab6b5ae8ce46a34f251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a3d5f342854be1507a6461a49a57ca"><td class="memTemplParams" colspan="2"><a id="a96a3d5f342854be1507a6461a49a57ca" name="a96a3d5f342854be1507a6461a49a57ca"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a96a3d5f342854be1507a6461a49a57ca"><td class="memTemplItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>laplacian</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1dual2.html">dual2</a> &gt;))</td></tr>
<tr class="memdesc:a96a3d5f342854be1507a6461a49a57ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a function which computes the laplacian differential operator for a generic function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\) at a given $\vec x$. <br /></td></tr>
<tr class="separator:a96a3d5f342854be1507a6461a49a57ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0a5c7fbe93408ce58d40859bab3365"><td class="memTemplParams" colspan="2">template&lt;unsigned int M&gt; </td></tr>
<tr class="memitem:a3b0a5c7fbe93408ce58d40859bab3365"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a3b0a5c7fbe93408ce58d40859bab3365">sturm_liouville</a> (<a class="el" href="classtheoretica_1_1dual.html">dual</a>(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; M, <a class="el" href="classtheoretica_1_1dual.html">dual</a> &gt;), <a class="el" href="classtheoretica_1_1dual.html">dual</a>(*H)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; M, <a class="el" href="classtheoretica_1_1dual.html">dual</a> &gt;), <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; M &gt; eta)</td></tr>
<tr class="memdesc:a3b0a5c7fbe93408ce58d40859bab3365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Sturm-Liouville operator on a generic function of the form \(f: \mathbb{R}^{2N} \rightarrow \mathbb{R}\) with respect to a given Hamiltonian function of the form \(H: \mathbb{R}^{2N} \rightarrow \mathbb{R}\) where the first N arguments are the coordinates in phase space and the last N arguments are the conjugate momenta, for a given point in phase space.  <a href="namespacetheoretica.html#a3b0a5c7fbe93408ce58d40859bab3365">More...</a><br /></td></tr>
<tr class="separator:a3b0a5c7fbe93408ce58d40859bab3365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6629ddaf5a84d7a8f3159b749ef4db0"><td class="memItemLeft" align="right" valign="top"><a id="ae6629ddaf5a84d7a8f3159b749ef4db0" name="ae6629ddaf5a84d7a8f3159b749ef4db0"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>square</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:ae6629ddaf5a84d7a8f3159b749ef4db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square of a second order dual number. <br /></td></tr>
<tr class="separator:ae6629ddaf5a84d7a8f3159b749ef4db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6bc324bd8ae6bbd91b89c7491fe988"><td class="memItemLeft" align="right" valign="top"><a id="afd6bc324bd8ae6bbd91b89c7491fe988" name="afd6bc324bd8ae6bbd91b89c7491fe988"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cube</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:afd6bc324bd8ae6bbd91b89c7491fe988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cube of a second order dual number. <br /></td></tr>
<tr class="separator:afd6bc324bd8ae6bbd91b89c7491fe988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce493c565b387c0496eff49e137edb6"><td class="memItemLeft" align="right" valign="top"><a id="afce493c565b387c0496eff49e137edb6" name="afce493c565b387c0496eff49e137edb6"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pow</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x, int n)</td></tr>
<tr class="memdesc:afce493c565b387c0496eff49e137edb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the n-th power of a second order dual number. <br /></td></tr>
<tr class="separator:afce493c565b387c0496eff49e137edb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19dd33456cffdbba3f29d85061779e7c"><td class="memItemLeft" align="right" valign="top"><a id="a19dd33456cffdbba3f29d85061779e7c" name="a19dd33456cffdbba3f29d85061779e7c"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sqrt</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a19dd33456cffdbba3f29d85061779e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square root of a second order dual number. <br /></td></tr>
<tr class="separator:a19dd33456cffdbba3f29d85061779e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a34ba6bb56c26ba50c1b2c21d2da7e"><td class="memItemLeft" align="right" valign="top"><a id="ad7a34ba6bb56c26ba50c1b2c21d2da7e" name="ad7a34ba6bb56c26ba50c1b2c21d2da7e"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sin</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:ad7a34ba6bb56c26ba50c1b2c21d2da7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sine of a second order dual number. <br /></td></tr>
<tr class="separator:ad7a34ba6bb56c26ba50c1b2c21d2da7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97cec74fe963806729cbdd0d43de5cd3"><td class="memItemLeft" align="right" valign="top"><a id="a97cec74fe963806729cbdd0d43de5cd3" name="a97cec74fe963806729cbdd0d43de5cd3"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cos</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a97cec74fe963806729cbdd0d43de5cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cosine of a second order dual number. <br /></td></tr>
<tr class="separator:a97cec74fe963806729cbdd0d43de5cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81dcde719b69b4d63ecd3127cb289d9"><td class="memItemLeft" align="right" valign="top"><a id="ac81dcde719b69b4d63ecd3127cb289d9" name="ac81dcde719b69b4d63ecd3127cb289d9"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tan</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:ac81dcde719b69b4d63ecd3127cb289d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the tangent of a second order dual number. <br /></td></tr>
<tr class="separator:ac81dcde719b69b4d63ecd3127cb289d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5fed4cfa9af5d148c59a6005422edc"><td class="memItemLeft" align="right" valign="top"><a id="a9d5fed4cfa9af5d148c59a6005422edc" name="a9d5fed4cfa9af5d148c59a6005422edc"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cot</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a9d5fed4cfa9af5d148c59a6005422edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cotangent of a second order dual number. <br /></td></tr>
<tr class="separator:a9d5fed4cfa9af5d148c59a6005422edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3def790003197bb019f5933b4db45c44"><td class="memItemLeft" align="right" valign="top"><a id="a3def790003197bb019f5933b4db45c44" name="a3def790003197bb019f5933b4db45c44"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>exp</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a3def790003197bb019f5933b4db45c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the exponential of a second order dual number. <br /></td></tr>
<tr class="separator:a3def790003197bb019f5933b4db45c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec5b4f8c9f0d58d65415cec30915d16"><td class="memItemLeft" align="right" valign="top"><a id="a1ec5b4f8c9f0d58d65415cec30915d16" name="a1ec5b4f8c9f0d58d65415cec30915d16"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ln</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a1ec5b4f8c9f0d58d65415cec30915d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a second order dual number. <br /></td></tr>
<tr class="separator:a1ec5b4f8c9f0d58d65415cec30915d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e46804be47f0c4865014a4a763cf76"><td class="memItemLeft" align="right" valign="top"><a id="a29e46804be47f0c4865014a4a763cf76" name="a29e46804be47f0c4865014a4a763cf76"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>log2</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a29e46804be47f0c4865014a4a763cf76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a second order dual number. <br /></td></tr>
<tr class="separator:a29e46804be47f0c4865014a4a763cf76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5101414a44ee9cfda63aea95ea40ef97"><td class="memItemLeft" align="right" valign="top"><a id="a5101414a44ee9cfda63aea95ea40ef97" name="a5101414a44ee9cfda63aea95ea40ef97"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>log10</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a5101414a44ee9cfda63aea95ea40ef97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a second order dual number. <br /></td></tr>
<tr class="separator:a5101414a44ee9cfda63aea95ea40ef97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29720d3e71b280bb3ea048aa71bc3655"><td class="memItemLeft" align="right" valign="top"><a id="a29720d3e71b280bb3ea048aa71bc3655" name="a29720d3e71b280bb3ea048aa71bc3655"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>abs</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a29720d3e71b280bb3ea048aa71bc3655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the absolute value of a second order dual number. <br /></td></tr>
<tr class="separator:a29720d3e71b280bb3ea048aa71bc3655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3761005d81ac85b7297426bfc3f62ea2"><td class="memItemLeft" align="right" valign="top"><a id="a3761005d81ac85b7297426bfc3f62ea2" name="a3761005d81ac85b7297426bfc3f62ea2"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>asin</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a3761005d81ac85b7297426bfc3f62ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arcsine of a second order dual number. <br /></td></tr>
<tr class="separator:a3761005d81ac85b7297426bfc3f62ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf13d7437b2dbea2212cbff3d519b9e5"><td class="memItemLeft" align="right" valign="top"><a id="acf13d7437b2dbea2212cbff3d519b9e5" name="acf13d7437b2dbea2212cbff3d519b9e5"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>acos</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:acf13d7437b2dbea2212cbff3d519b9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arcosine of a second order dual number. <br /></td></tr>
<tr class="separator:acf13d7437b2dbea2212cbff3d519b9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0493013e208bb00505abbc4ca37f292"><td class="memItemLeft" align="right" valign="top"><a id="af0493013e208bb00505abbc4ca37f292" name="af0493013e208bb00505abbc4ca37f292"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>atan</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:af0493013e208bb00505abbc4ca37f292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arctangent of a second order dual number. <br /></td></tr>
<tr class="separator:af0493013e208bb00505abbc4ca37f292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f05865ec8d49e6abf889d81e1cd428"><td class="memItemLeft" align="right" valign="top"><a id="ad5f05865ec8d49e6abf889d81e1cd428" name="ad5f05865ec8d49e6abf889d81e1cd428"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>square</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:ad5f05865ec8d49e6abf889d81e1cd428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square of a dual number. <br /></td></tr>
<tr class="separator:ad5f05865ec8d49e6abf889d81e1cd428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab28b5c479cfd017f81b9806aa27838e"><td class="memItemLeft" align="right" valign="top"><a id="aab28b5c479cfd017f81b9806aa27838e" name="aab28b5c479cfd017f81b9806aa27838e"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cube</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:aab28b5c479cfd017f81b9806aa27838e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cube of a dual number. <br /></td></tr>
<tr class="separator:aab28b5c479cfd017f81b9806aa27838e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad063ce053e951e9183799584090c0e"><td class="memItemLeft" align="right" valign="top"><a id="a4ad063ce053e951e9183799584090c0e" name="a4ad063ce053e951e9183799584090c0e"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pow</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x, int n)</td></tr>
<tr class="memdesc:a4ad063ce053e951e9183799584090c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the n-th power of a dual number. <br /></td></tr>
<tr class="separator:a4ad063ce053e951e9183799584090c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e64e0c5a3452708528e6fb46f97b84e"><td class="memItemLeft" align="right" valign="top"><a id="a6e64e0c5a3452708528e6fb46f97b84e" name="a6e64e0c5a3452708528e6fb46f97b84e"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sqrt</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a6e64e0c5a3452708528e6fb46f97b84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square root of a dual number. <br /></td></tr>
<tr class="separator:a6e64e0c5a3452708528e6fb46f97b84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8369c63cfe1b787c3916865de1ac534b"><td class="memItemLeft" align="right" valign="top"><a id="a8369c63cfe1b787c3916865de1ac534b" name="a8369c63cfe1b787c3916865de1ac534b"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sin</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a8369c63cfe1b787c3916865de1ac534b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sine of a dual number. <br /></td></tr>
<tr class="separator:a8369c63cfe1b787c3916865de1ac534b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39630b09f7294762464b1eb5301b508f"><td class="memItemLeft" align="right" valign="top"><a id="a39630b09f7294762464b1eb5301b508f" name="a39630b09f7294762464b1eb5301b508f"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cos</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a39630b09f7294762464b1eb5301b508f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cosine of a dual number. <br /></td></tr>
<tr class="separator:a39630b09f7294762464b1eb5301b508f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef33e5920ccf4cfe7f79c70ebc9dfbb"><td class="memItemLeft" align="right" valign="top"><a id="afef33e5920ccf4cfe7f79c70ebc9dfbb" name="afef33e5920ccf4cfe7f79c70ebc9dfbb"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tan</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:afef33e5920ccf4cfe7f79c70ebc9dfbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the tangent of a dual number. <br /></td></tr>
<tr class="separator:afef33e5920ccf4cfe7f79c70ebc9dfbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdf17b1485bdfb0f967caee134136b6"><td class="memItemLeft" align="right" valign="top"><a id="aacdf17b1485bdfb0f967caee134136b6" name="aacdf17b1485bdfb0f967caee134136b6"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cot</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:aacdf17b1485bdfb0f967caee134136b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cotangent of a dual number. <br /></td></tr>
<tr class="separator:aacdf17b1485bdfb0f967caee134136b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21974bc022495f59a7702ce937f4544c"><td class="memItemLeft" align="right" valign="top"><a id="a21974bc022495f59a7702ce937f4544c" name="a21974bc022495f59a7702ce937f4544c"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>exp</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a21974bc022495f59a7702ce937f4544c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the exponential of a dual number. <br /></td></tr>
<tr class="separator:a21974bc022495f59a7702ce937f4544c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8acf40b0d2b7e4f62d95dd4bec0b169d"><td class="memItemLeft" align="right" valign="top"><a id="a8acf40b0d2b7e4f62d95dd4bec0b169d" name="a8acf40b0d2b7e4f62d95dd4bec0b169d"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ln</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a8acf40b0d2b7e4f62d95dd4bec0b169d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a dual number. <br /></td></tr>
<tr class="separator:a8acf40b0d2b7e4f62d95dd4bec0b169d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d6466e16b24bd1dfac49fd0c50ed79"><td class="memItemLeft" align="right" valign="top"><a id="a30d6466e16b24bd1dfac49fd0c50ed79" name="a30d6466e16b24bd1dfac49fd0c50ed79"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>log2</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a30d6466e16b24bd1dfac49fd0c50ed79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a dual number. <br /></td></tr>
<tr class="separator:a30d6466e16b24bd1dfac49fd0c50ed79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254b955eacdab15792dcb9d871559499"><td class="memItemLeft" align="right" valign="top"><a id="a254b955eacdab15792dcb9d871559499" name="a254b955eacdab15792dcb9d871559499"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>log10</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a254b955eacdab15792dcb9d871559499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a dual number. <br /></td></tr>
<tr class="separator:a254b955eacdab15792dcb9d871559499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3796818092440b5f1745c67b1162ddcf"><td class="memItemLeft" align="right" valign="top"><a id="a3796818092440b5f1745c67b1162ddcf" name="a3796818092440b5f1745c67b1162ddcf"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>abs</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a3796818092440b5f1745c67b1162ddcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the absolute value of a dual number. <br /></td></tr>
<tr class="separator:a3796818092440b5f1745c67b1162ddcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892e7542b82c516e65023555a0e30f6b"><td class="memItemLeft" align="right" valign="top"><a id="a892e7542b82c516e65023555a0e30f6b" name="a892e7542b82c516e65023555a0e30f6b"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>asin</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a892e7542b82c516e65023555a0e30f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arcsine of a dual number. <br /></td></tr>
<tr class="separator:a892e7542b82c516e65023555a0e30f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7f07a4d7a0abca49824b5926f259f1"><td class="memItemLeft" align="right" valign="top"><a id="abd7f07a4d7a0abca49824b5926f259f1" name="abd7f07a4d7a0abca49824b5926f259f1"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>acos</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:abd7f07a4d7a0abca49824b5926f259f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arccosine of a dual number. <br /></td></tr>
<tr class="separator:abd7f07a4d7a0abca49824b5926f259f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9ae8cb187999582be3db40cf149f43"><td class="memItemLeft" align="right" valign="top"><a id="a6b9ae8cb187999582be3db40cf149f43" name="a6b9ae8cb187999582be3db40cf149f43"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>atan</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a6b9ae8cb187999582be3db40cf149f43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arctangent of a dual number. <br /></td></tr>
<tr class="separator:a6b9ae8cb187999582be3db40cf149f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8c95ef4ed4e4da6af87e9eee675f82"><td class="memItemLeft" align="right" valign="top"><a id="a1f8c95ef4ed4e4da6af87e9eee675f82" name="a1f8c95ef4ed4e4da6af87e9eee675f82"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sinh</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a1f8c95ef4ed4e4da6af87e9eee675f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic sine of a dual number. <br /></td></tr>
<tr class="separator:a1f8c95ef4ed4e4da6af87e9eee675f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8d81973a127a1e66c180cba58d08ee"><td class="memItemLeft" align="right" valign="top"><a id="a1b8d81973a127a1e66c180cba58d08ee" name="a1b8d81973a127a1e66c180cba58d08ee"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cosh</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a1b8d81973a127a1e66c180cba58d08ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic cosine of a dual number. <br /></td></tr>
<tr class="separator:a1b8d81973a127a1e66c180cba58d08ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf2c5dcfac28891e1e8a3accdf7dd21"><td class="memItemLeft" align="right" valign="top"><a id="afbf2c5dcfac28891e1e8a3accdf7dd21" name="afbf2c5dcfac28891e1e8a3accdf7dd21"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tanh</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:afbf2c5dcfac28891e1e8a3accdf7dd21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic tangent of a dual number. <br /></td></tr>
<tr class="separator:afbf2c5dcfac28891e1e8a3accdf7dd21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab864254bd5f629822f3d1fcee3cff6b7"><td class="memTemplParams" colspan="2"><a id="ab864254bd5f629822f3d1fcee3cff6b7" name="ab864254bd5f629822f3d1fcee3cff6b7"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ab864254bd5f629822f3d1fcee3cff6b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>square</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:ab864254bd5f629822f3d1fcee3cff6b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square of a multidual number. <br /></td></tr>
<tr class="separator:ab864254bd5f629822f3d1fcee3cff6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae356adeb60d93c78bd5d27ddf49a6c66"><td class="memTemplParams" colspan="2"><a id="ae356adeb60d93c78bd5d27ddf49a6c66" name="ae356adeb60d93c78bd5d27ddf49a6c66"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ae356adeb60d93c78bd5d27ddf49a6c66"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cube</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:ae356adeb60d93c78bd5d27ddf49a6c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cube of a multidual number. <br /></td></tr>
<tr class="separator:ae356adeb60d93c78bd5d27ddf49a6c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb716c77e812d83d2aed787ff39b62e"><td class="memTemplParams" colspan="2"><a id="adfb716c77e812d83d2aed787ff39b62e" name="adfb716c77e812d83d2aed787ff39b62e"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:adfb716c77e812d83d2aed787ff39b62e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>pow</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x, int n)</td></tr>
<tr class="memdesc:adfb716c77e812d83d2aed787ff39b62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the n-th power of a multidual number. <br /></td></tr>
<tr class="separator:adfb716c77e812d83d2aed787ff39b62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aaa215522430587c6c8dc7971269fb5"><td class="memTemplParams" colspan="2"><a id="a8aaa215522430587c6c8dc7971269fb5" name="a8aaa215522430587c6c8dc7971269fb5"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a8aaa215522430587c6c8dc7971269fb5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sqrt</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:a8aaa215522430587c6c8dc7971269fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square root of a multidual number. <br /></td></tr>
<tr class="separator:a8aaa215522430587c6c8dc7971269fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1444ff9faf0b4b247468462d7b7cb01"><td class="memTemplParams" colspan="2"><a id="af1444ff9faf0b4b247468462d7b7cb01" name="af1444ff9faf0b4b247468462d7b7cb01"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:af1444ff9faf0b4b247468462d7b7cb01"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sin</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:af1444ff9faf0b4b247468462d7b7cb01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sine of a multidual number. <br /></td></tr>
<tr class="separator:af1444ff9faf0b4b247468462d7b7cb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ac8631aae8f4c3ae5dc63cbabc57c8"><td class="memTemplParams" colspan="2"><a id="ac8ac8631aae8f4c3ae5dc63cbabc57c8" name="ac8ac8631aae8f4c3ae5dc63cbabc57c8"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ac8ac8631aae8f4c3ae5dc63cbabc57c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cos</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:ac8ac8631aae8f4c3ae5dc63cbabc57c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cosine of a multidual number. <br /></td></tr>
<tr class="separator:ac8ac8631aae8f4c3ae5dc63cbabc57c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe9ca76dc4db09890a618a1d77da20b"><td class="memTemplParams" colspan="2"><a id="aafe9ca76dc4db09890a618a1d77da20b" name="aafe9ca76dc4db09890a618a1d77da20b"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:aafe9ca76dc4db09890a618a1d77da20b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tan</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:aafe9ca76dc4db09890a618a1d77da20b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the tangent of a multidual number. <br /></td></tr>
<tr class="separator:aafe9ca76dc4db09890a618a1d77da20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8839aa97612a40db14f1c8818b463d0"><td class="memTemplParams" colspan="2"><a id="ac8839aa97612a40db14f1c8818b463d0" name="ac8839aa97612a40db14f1c8818b463d0"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ac8839aa97612a40db14f1c8818b463d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cot</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:ac8839aa97612a40db14f1c8818b463d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cotangent of a multidual number. <br /></td></tr>
<tr class="separator:ac8839aa97612a40db14f1c8818b463d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311ed7edb65295b9284b3f10e5fa5f90"><td class="memTemplParams" colspan="2"><a id="a311ed7edb65295b9284b3f10e5fa5f90" name="a311ed7edb65295b9284b3f10e5fa5f90"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a311ed7edb65295b9284b3f10e5fa5f90"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>exp</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:a311ed7edb65295b9284b3f10e5fa5f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the exponential of a multidual number. <br /></td></tr>
<tr class="separator:a311ed7edb65295b9284b3f10e5fa5f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecb01797f9cac464a6dea02d5a73e34"><td class="memTemplParams" colspan="2"><a id="adecb01797f9cac464a6dea02d5a73e34" name="adecb01797f9cac464a6dea02d5a73e34"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:adecb01797f9cac464a6dea02d5a73e34"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ln</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:adecb01797f9cac464a6dea02d5a73e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a multidual number. <br /></td></tr>
<tr class="separator:adecb01797f9cac464a6dea02d5a73e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84cf28a3ec07fef45f28617946e62961"><td class="memTemplParams" colspan="2"><a id="a84cf28a3ec07fef45f28617946e62961" name="a84cf28a3ec07fef45f28617946e62961"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a84cf28a3ec07fef45f28617946e62961"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>log2</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:a84cf28a3ec07fef45f28617946e62961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a multidual number. <br /></td></tr>
<tr class="separator:a84cf28a3ec07fef45f28617946e62961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace737cd7c21a314c33915adf9956a640"><td class="memTemplParams" colspan="2"><a id="ace737cd7c21a314c33915adf9956a640" name="ace737cd7c21a314c33915adf9956a640"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ace737cd7c21a314c33915adf9956a640"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>log10</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:ace737cd7c21a314c33915adf9956a640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a multidual number. <br /></td></tr>
<tr class="separator:ace737cd7c21a314c33915adf9956a640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb87636665493a0584655ad754e4c53"><td class="memTemplParams" colspan="2"><a id="a4eb87636665493a0584655ad754e4c53" name="a4eb87636665493a0584655ad754e4c53"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a4eb87636665493a0584655ad754e4c53"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:a4eb87636665493a0584655ad754e4c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the absolute value of a multidual number. <br /></td></tr>
<tr class="separator:a4eb87636665493a0584655ad754e4c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9fac1b91317d696fc2b4ea479b30b9"><td class="memTemplParams" colspan="2"><a id="a5b9fac1b91317d696fc2b4ea479b30b9" name="a5b9fac1b91317d696fc2b4ea479b30b9"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a5b9fac1b91317d696fc2b4ea479b30b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>asin</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:a5b9fac1b91317d696fc2b4ea479b30b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arcsine of a multidual number. <br /></td></tr>
<tr class="separator:a5b9fac1b91317d696fc2b4ea479b30b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf0ac356621f93c30fc6bdd9a1977a3"><td class="memTemplParams" colspan="2"><a id="afcf0ac356621f93c30fc6bdd9a1977a3" name="afcf0ac356621f93c30fc6bdd9a1977a3"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:afcf0ac356621f93c30fc6bdd9a1977a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>acos</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:afcf0ac356621f93c30fc6bdd9a1977a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arccosine of a multidual number. <br /></td></tr>
<tr class="separator:afcf0ac356621f93c30fc6bdd9a1977a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f31ace8ee7a5730ba7f0b1a60df5835"><td class="memTemplParams" colspan="2"><a id="a0f31ace8ee7a5730ba7f0b1a60df5835" name="a0f31ace8ee7a5730ba7f0b1a60df5835"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a0f31ace8ee7a5730ba7f0b1a60df5835"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>atan</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:a0f31ace8ee7a5730ba7f0b1a60df5835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arctangent of a multidual number. <br /></td></tr>
<tr class="separator:a0f31ace8ee7a5730ba7f0b1a60df5835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c71523f7f9d97e48c2de258ef952500"><td class="memTemplParams" colspan="2"><a id="a8c71523f7f9d97e48c2de258ef952500" name="a8c71523f7f9d97e48c2de258ef952500"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a8c71523f7f9d97e48c2de258ef952500"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sinh</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:a8c71523f7f9d97e48c2de258ef952500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic sine of a multidual number. <br /></td></tr>
<tr class="separator:a8c71523f7f9d97e48c2de258ef952500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b0ad9b86faf6ab2d308f9f76d31010"><td class="memTemplParams" colspan="2"><a id="ae2b0ad9b86faf6ab2d308f9f76d31010" name="ae2b0ad9b86faf6ab2d308f9f76d31010"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ae2b0ad9b86faf6ab2d308f9f76d31010"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cosh</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:ae2b0ad9b86faf6ab2d308f9f76d31010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic cosine of a multidual number. <br /></td></tr>
<tr class="separator:ae2b0ad9b86faf6ab2d308f9f76d31010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa990eeebdd5fb8e93c96c4ed6ff91317"><td class="memTemplParams" colspan="2"><a id="aa990eeebdd5fb8e93c96c4ed6ff91317" name="aa990eeebdd5fb8e93c96c4ed6ff91317"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:aa990eeebdd5fb8e93c96c4ed6ff91317"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tanh</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:aa990eeebdd5fb8e93c96c4ed6ff91317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic tangent of a multidual number. <br /></td></tr>
<tr class="separator:aa990eeebdd5fb8e93c96c4ed6ff91317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db068fdfc750be0e45e3fcaa77fc458"><td class="memTemplParams" colspan="2">template&lt;typename T  = real&gt; </td></tr>
<tr class="memitem:a3db068fdfc750be0e45e3fcaa77fc458"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a3db068fdfc750be0e45e3fcaa77fc458">deriv_polynomial</a> (const <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a3db068fdfc750be0e45e3fcaa77fc458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the derivative of a polynomial.  <a href="namespacetheoretica.html#a3db068fdfc750be0e45e3fcaa77fc458">More...</a><br /></td></tr>
<tr class="separator:a3db068fdfc750be0e45e3fcaa77fc458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bbf1baa785f514b3e3a74f80fbd9546"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a5bbf1baa785f514b3e3a74f80fbd9546"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a5bbf1baa785f514b3e3a74f80fbd9546">deriv_central</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h=<a class="el" href="namespacetheoretica.html#a72dfe63d1cce5e9c204cba3493a4e598">DERIV_STEPSIZE</a>)</td></tr>
<tr class="memdesc:a5bbf1baa785f514b3e3a74f80fbd9546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derivative approximation using the central method.  <a href="namespacetheoretica.html#a5bbf1baa785f514b3e3a74f80fbd9546">More...</a><br /></td></tr>
<tr class="separator:a5bbf1baa785f514b3e3a74f80fbd9546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936dad7b99b64c874223aa537c3ad84f"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a936dad7b99b64c874223aa537c3ad84f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a936dad7b99b64c874223aa537c3ad84f">deriv_forward</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h=<a class="el" href="namespacetheoretica.html#a72dfe63d1cce5e9c204cba3493a4e598">DERIV_STEPSIZE</a>)</td></tr>
<tr class="memdesc:a936dad7b99b64c874223aa537c3ad84f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derivative approximation using the forward method.  <a href="namespacetheoretica.html#a936dad7b99b64c874223aa537c3ad84f">More...</a><br /></td></tr>
<tr class="separator:a936dad7b99b64c874223aa537c3ad84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fda7d7c90a088c8bdbf28b0908c71e8"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a0fda7d7c90a088c8bdbf28b0908c71e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a0fda7d7c90a088c8bdbf28b0908c71e8">deriv_backward</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h=<a class="el" href="namespacetheoretica.html#a72dfe63d1cce5e9c204cba3493a4e598">DERIV_STEPSIZE</a>)</td></tr>
<tr class="memdesc:a0fda7d7c90a088c8bdbf28b0908c71e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derivative approximation using the backward method.  <a href="namespacetheoretica.html#a0fda7d7c90a088c8bdbf28b0908c71e8">More...</a><br /></td></tr>
<tr class="separator:a0fda7d7c90a088c8bdbf28b0908c71e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f963a737accf2110a8ed71a5064320"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a93f963a737accf2110a8ed71a5064320"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a93f963a737accf2110a8ed71a5064320">deriv_ridders2</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h=<a class="el" href="namespacetheoretica.html#a72dfe63d1cce5e9c204cba3493a4e598">DERIV_STEPSIZE</a>)</td></tr>
<tr class="memdesc:a93f963a737accf2110a8ed71a5064320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ridder's derivative approximation of second degree.  <a href="namespacetheoretica.html#a93f963a737accf2110a8ed71a5064320">More...</a><br /></td></tr>
<tr class="separator:a93f963a737accf2110a8ed71a5064320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c5277448360f087fa63323020675c6"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a08c5277448360f087fa63323020675c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a08c5277448360f087fa63323020675c6">deriv_ridders</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h=0.01, unsigned int degree=3)</td></tr>
<tr class="memdesc:a08c5277448360f087fa63323020675c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ridder's derivative approximation of arbitrary degree.  <a href="namespacetheoretica.html#a08c5277448360f087fa63323020675c6">More...</a><br /></td></tr>
<tr class="separator:a08c5277448360f087fa63323020675c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13c23d95e0130b1e29ac617f313f27d"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:af13c23d95e0130b1e29ac617f313f27d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#af13c23d95e0130b1e29ac617f313f27d">deriv</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h=<a class="el" href="namespacetheoretica.html#a72dfe63d1cce5e9c204cba3493a4e598">DERIV_STEPSIZE</a>)</td></tr>
<tr class="memdesc:af13c23d95e0130b1e29ac617f313f27d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the best available algorithm to approximate the derivative of a real function.  <a href="namespacetheoretica.html#af13c23d95e0130b1e29ac617f313f27d">More...</a><br /></td></tr>
<tr class="separator:af13c23d95e0130b1e29ac617f313f27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad376dcd3be0e15133bbedf6ad1160587"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:ad376dcd3be0e15133bbedf6ad1160587"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ad376dcd3be0e15133bbedf6ad1160587">deriv2</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h=<a class="el" href="namespacetheoretica.html#a72dfe63d1cce5e9c204cba3493a4e598">DERIV_STEPSIZE</a>)</td></tr>
<tr class="memdesc:ad376dcd3be0e15133bbedf6ad1160587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the best available algorithm to approximate the second derivative of a real function.  <a href="namespacetheoretica.html#ad376dcd3be0e15133bbedf6ad1160587">More...</a><br /></td></tr>
<tr class="separator:ad376dcd3be0e15133bbedf6ad1160587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30054ccf81cf93e466c08361e4ff9fb"><td class="memTemplParams" colspan="2">template&lt;typename T  = real&gt; </td></tr>
<tr class="memitem:ad30054ccf81cf93e466c08361e4ff9fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ad30054ccf81cf93e466c08361e4ff9fb">integrate_polynomial</a> (const <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:ad30054ccf81cf93e466c08361e4ff9fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the indefinite integral of a polynomial.  <a href="namespacetheoretica.html#ad30054ccf81cf93e466c08361e4ff9fb">More...</a><br /></td></tr>
<tr class="separator:ad30054ccf81cf93e466c08361e4ff9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a48a7bb7296e78f5c1b0c5f5bcf4d93"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a1a48a7bb7296e78f5c1b0c5f5bcf4d93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a1a48a7bb7296e78f5c1b0c5f5bcf4d93">integral_midpoint</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int steps=<a class="el" href="namespacetheoretica.html#aa1f0e3448f94ada54d171499c0c95ae4">INTEGRATION_STEPS</a>)</td></tr>
<tr class="memdesc:a1a48a7bb7296e78f5c1b0c5f5bcf4d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate the definite integral of an arbitrary function using the midpoint method.  <a href="namespacetheoretica.html#a1a48a7bb7296e78f5c1b0c5f5bcf4d93">More...</a><br /></td></tr>
<tr class="separator:a1a48a7bb7296e78f5c1b0c5f5bcf4d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cbfca610e297e184c272140d991e987"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a4cbfca610e297e184c272140d991e987"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a4cbfca610e297e184c272140d991e987">integral_trapezoid</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int steps=<a class="el" href="namespacetheoretica.html#aa1f0e3448f94ada54d171499c0c95ae4">INTEGRATION_STEPS</a>)</td></tr>
<tr class="memdesc:a4cbfca610e297e184c272140d991e987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate the definite integral of an arbitrary function using the trapezoid method.  <a href="namespacetheoretica.html#a4cbfca610e297e184c272140d991e987">More...</a><br /></td></tr>
<tr class="separator:a4cbfca610e297e184c272140d991e987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f3d75e6a0c23d23a5e685145437ff5"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:ad5f3d75e6a0c23d23a5e685145437ff5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ad5f3d75e6a0c23d23a5e685145437ff5">integral_simpson</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int steps=<a class="el" href="namespacetheoretica.html#aa1f0e3448f94ada54d171499c0c95ae4">INTEGRATION_STEPS</a>)</td></tr>
<tr class="memdesc:ad5f3d75e6a0c23d23a5e685145437ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate the definite integral of an arbitrary function using Simpson's method.  <a href="namespacetheoretica.html#ad5f3d75e6a0c23d23a5e685145437ff5">More...</a><br /></td></tr>
<tr class="separator:ad5f3d75e6a0c23d23a5e685145437ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710ca6ff97e6d14f5f42bab6462d9fa2"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a710ca6ff97e6d14f5f42bab6462d9fa2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a710ca6ff97e6d14f5f42bab6462d9fa2">integral_romberg</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int order=16)</td></tr>
<tr class="memdesc:a710ca6ff97e6d14f5f42bab6462d9fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate the definite integral of an arbitrary function using Romberg's method accurate to the given order.  <a href="namespacetheoretica.html#a710ca6ff97e6d14f5f42bab6462d9fa2">More...</a><br /></td></tr>
<tr class="separator:a710ca6ff97e6d14f5f42bab6462d9fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae095e7eee4b03eddc3b035b2bde14a7e"><td class="memTemplParams" colspan="2">template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:ae095e7eee4b03eddc3b035b2bde14a7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ae095e7eee4b03eddc3b035b2bde14a7e">integral</a> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b)</td></tr>
<tr class="memdesc:ae095e7eee4b03eddc3b035b2bde14a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the best available algorithm to approximate the definite integral of a real function.  <a href="namespacetheoretica.html#ae095e7eee4b03eddc3b035b2bde14a7e">More...</a><br /></td></tr>
<tr class="separator:ae095e7eee4b03eddc3b035b2bde14a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33677028b95163d88cfe6343d84ce31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ae33677028b95163d88cfe6343d84ce31">integrate_ode_euler</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*f)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>), <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt; s, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h)</td></tr>
<tr class="memdesc:ae33677028b95163d88cfe6343d84ce31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate numerically a differential equation in one unknown using Euler's method.  <a href="namespacetheoretica.html#ae33677028b95163d88cfe6343d84ce31">More...</a><br /></td></tr>
<tr class="separator:ae33677028b95163d88cfe6343d84ce31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab472cc6c088fd942b4a9203eb6b75add"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ab472cc6c088fd942b4a9203eb6b75add"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ab472cc6c088fd942b4a9203eb6b75add">integrate_ode_euler</a> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;(*f)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;), <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt; s, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h)</td></tr>
<tr class="memdesc:ab472cc6c088fd942b4a9203eb6b75add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate numerically a differential equation in N unknowns using Euler's method.  <a href="namespacetheoretica.html#ab472cc6c088fd942b4a9203eb6b75add">More...</a><br /></td></tr>
<tr class="separator:ab472cc6c088fd942b4a9203eb6b75add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599ac0edf98cb7ed53f9554c29b74da9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a599ac0edf98cb7ed53f9554c29b74da9">integrate_ode_midpoint</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*f)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>), <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt; s, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h)</td></tr>
<tr class="memdesc:a599ac0edf98cb7ed53f9554c29b74da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate numerically a differential equation in one unknown using the midpoint method.  <a href="namespacetheoretica.html#a599ac0edf98cb7ed53f9554c29b74da9">More...</a><br /></td></tr>
<tr class="separator:a599ac0edf98cb7ed53f9554c29b74da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74bcfb58dfec609f28f1fa45064fc827"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a74bcfb58dfec609f28f1fa45064fc827"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a74bcfb58dfec609f28f1fa45064fc827">integrate_ode_midpoint</a> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;(*f)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;), <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt; s, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h)</td></tr>
<tr class="memdesc:a74bcfb58dfec609f28f1fa45064fc827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate numerically a differential equation in N unknowns using the midpoint method.  <a href="namespacetheoretica.html#a74bcfb58dfec609f28f1fa45064fc827">More...</a><br /></td></tr>
<tr class="separator:a74bcfb58dfec609f28f1fa45064fc827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b75bb553d0ae78a096c11498d6118d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a92b75bb553d0ae78a096c11498d6118d">integrate_ode_heun</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*f)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>), <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt; s, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h)</td></tr>
<tr class="memdesc:a92b75bb553d0ae78a096c11498d6118d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate numerically a differential equation in one unknown using Heun's method.  <a href="namespacetheoretica.html#a92b75bb553d0ae78a096c11498d6118d">More...</a><br /></td></tr>
<tr class="separator:a92b75bb553d0ae78a096c11498d6118d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33e3c75bb18df5b0130a2d13db00576"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:aa33e3c75bb18df5b0130a2d13db00576"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa33e3c75bb18df5b0130a2d13db00576">integrate_ode_heun</a> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;(*f)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;), <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt; s, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h)</td></tr>
<tr class="memdesc:aa33e3c75bb18df5b0130a2d13db00576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate numerically a differential equation in N unknowns using Heun's method.  <a href="namespacetheoretica.html#aa33e3c75bb18df5b0130a2d13db00576">More...</a><br /></td></tr>
<tr class="separator:aa33e3c75bb18df5b0130a2d13db00576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd5fd5128198f53ec484aed09b99542"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#adcd5fd5128198f53ec484aed09b99542">integrate_ode_rk4</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*f)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>), <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt; s, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h)</td></tr>
<tr class="memdesc:adcd5fd5128198f53ec484aed09b99542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate numerically a differential equation in one unknown using Runge-Kutta's method of fourth order.  <a href="namespacetheoretica.html#adcd5fd5128198f53ec484aed09b99542">More...</a><br /></td></tr>
<tr class="separator:adcd5fd5128198f53ec484aed09b99542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016fb5701cea5c9b53c7aaefd7fc6d00"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a016fb5701cea5c9b53c7aaefd7fc6d00"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a016fb5701cea5c9b53c7aaefd7fc6d00">integrate_ode_rk4</a> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;(*f)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;), <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt; s, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h)</td></tr>
<tr class="memdesc:a016fb5701cea5c9b53c7aaefd7fc6d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate numerically a differential equation in N unknowns using Runge-Kutta's method of fourth order.  <a href="namespacetheoretica.html#a016fb5701cea5c9b53c7aaefd7fc6d00">More...</a><br /></td></tr>
<tr class="separator:a016fb5701cea5c9b53c7aaefd7fc6d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b8a7c7bae8e200528ade408f85dc87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa9b8a7c7bae8e200528ade408f85dc87">integrate_ode_k38</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*f)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>), <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt; s, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h)</td></tr>
<tr class="memdesc:aa9b8a7c7bae8e200528ade408f85dc87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate numerically a differential equation in one unknown using Kutta's 3/8 rule method.  <a href="namespacetheoretica.html#aa9b8a7c7bae8e200528ade408f85dc87">More...</a><br /></td></tr>
<tr class="separator:aa9b8a7c7bae8e200528ade408f85dc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586d26495e48bc20c35c8afac60a580c"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a586d26495e48bc20c35c8afac60a580c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a586d26495e48bc20c35c8afac60a580c">integrate_ode_k38</a> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;(*f)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;), <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt; s, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h)</td></tr>
<tr class="memdesc:a586d26495e48bc20c35c8afac60a580c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate numerically a differential equation in N unknowns using Kutta's 3/8 rule method.  <a href="namespacetheoretica.html#a586d26495e48bc20c35c8afac60a580c">More...</a><br /></td></tr>
<tr class="separator:a586d26495e48bc20c35c8afac60a580c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d5cf57c54575f08fe7b71e5d47ed636"><td class="memItemLeft" align="right" valign="top"><a id="a6d5cf57c54575f08fe7b71e5d47ed636" name="a6d5cf57c54575f08fe7b71e5d47ed636"></a>
<a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>integrate_ode_adams</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*f)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>), <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt; s0, <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt; s1, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h)</td></tr>
<tr class="memdesc:a6d5cf57c54575f08fe7b71e5d47ed636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate numerically a differential equation in 1 unknown. <br /></td></tr>
<tr class="separator:a6d5cf57c54575f08fe7b71e5d47ed636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21cee67096b1486d5f22e47e7296c00e"><td class="memTemplParams" colspan="2"><a id="a21cee67096b1486d5f22e47e7296c00e" name="a21cee67096b1486d5f22e47e7296c00e"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a21cee67096b1486d5f22e47e7296c00e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>integrate_ode_adams</b> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;(*f)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;), <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt; s0, <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt; s1, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h)</td></tr>
<tr class="memdesc:a21cee67096b1486d5f22e47e7296c00e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate numerically a differential equation in N unknowns. <br /></td></tr>
<tr class="separator:a21cee67096b1486d5f22e47e7296c00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a34f2bb3ca733a933398f62d3680f1"><td class="memItemLeft" align="right" valign="top"><a id="a33a34f2bb3ca733a933398f62d3680f1" name="a33a34f2bb3ca733a933398f62d3680f1"></a>
<a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>integrate_ode_adams3</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*f)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>), <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt; s0, <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt; s1, <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt; s2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h)</td></tr>
<tr class="memdesc:a33a34f2bb3ca733a933398f62d3680f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate numerically a differential equation in 1 unknown. <br /></td></tr>
<tr class="separator:a33a34f2bb3ca733a933398f62d3680f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc0cff7a77c84ed46647e81e3367fe2"><td class="memTemplParams" colspan="2"><a id="a1fc0cff7a77c84ed46647e81e3367fe2" name="a1fc0cff7a77c84ed46647e81e3367fe2"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a1fc0cff7a77c84ed46647e81e3367fe2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>integrate_ode_adams3</b> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;(*f)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;), <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt; s0, <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt; s1, <a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt; s2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> h)</td></tr>
<tr class="memdesc:a1fc0cff7a77c84ed46647e81e3367fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate numerically a differential equation in N unknowns. <br /></td></tr>
<tr class="separator:a1fc0cff7a77c84ed46647e81e3367fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90fa837617e2c026520db02b8b616009"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a90fa837617e2c026520db02b8b616009">identity</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a> z)</td></tr>
<tr class="memdesc:a90fa837617e2c026520db02b8b616009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex identity.  <a href="namespacetheoretica.html#a90fa837617e2c026520db02b8b616009">More...</a><br /></td></tr>
<tr class="separator:a90fa837617e2c026520db02b8b616009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa9e6cd9857b4f64165ebebfd58ec3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a4fa9e6cd9857b4f64165ebebfd58ec3b">conjugate</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a> z)</td></tr>
<tr class="memdesc:a4fa9e6cd9857b4f64165ebebfd58ec3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the conjugate of a complex number.  <a href="namespacetheoretica.html#a4fa9e6cd9857b4f64165ebebfd58ec3b">More...</a><br /></td></tr>
<tr class="separator:a4fa9e6cd9857b4f64165ebebfd58ec3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf893a13dda9fd79be929e4dea4a80f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#abcf893a13dda9fd79be929e4dea4a80f">inverse</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a> z)</td></tr>
<tr class="memdesc:abcf893a13dda9fd79be929e4dea4a80f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the conjugate of a complex number.  <a href="namespacetheoretica.html#abcf893a13dda9fd79be929e4dea4a80f">More...</a><br /></td></tr>
<tr class="separator:abcf893a13dda9fd79be929e4dea4a80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d09bcf107dc6230badf2b29e25ffcad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a9d09bcf107dc6230badf2b29e25ffcad">square</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a> z)</td></tr>
<tr class="memdesc:a9d09bcf107dc6230badf2b29e25ffcad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square of a complex number.  <a href="namespacetheoretica.html#a9d09bcf107dc6230badf2b29e25ffcad">More...</a><br /></td></tr>
<tr class="separator:a9d09bcf107dc6230badf2b29e25ffcad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a0b9841198983905b57496cad4869e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa8a0b9841198983905b57496cad4869e">cube</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a> z)</td></tr>
<tr class="memdesc:aa8a0b9841198983905b57496cad4869e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cube of a complex number.  <a href="namespacetheoretica.html#aa8a0b9841198983905b57496cad4869e">More...</a><br /></td></tr>
<tr class="separator:aa8a0b9841198983905b57496cad4869e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463ef7c6f8731bab9581d4021e92a60b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a463ef7c6f8731bab9581d4021e92a60b">exp</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a> z)</td></tr>
<tr class="memdesc:a463ef7c6f8731bab9581d4021e92a60b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex exponential.  <a href="namespacetheoretica.html#a463ef7c6f8731bab9581d4021e92a60b">More...</a><br /></td></tr>
<tr class="separator:a463ef7c6f8731bab9581d4021e92a60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f49fa3c3999e2a64956c3cb44bf596c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a0f49fa3c3999e2a64956c3cb44bf596c">abs</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a> z)</td></tr>
<tr class="memdesc:a0f49fa3c3999e2a64956c3cb44bf596c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the modulus of a complex number.  <a href="namespacetheoretica.html#a0f49fa3c3999e2a64956c3cb44bf596c">More...</a><br /></td></tr>
<tr class="separator:a0f49fa3c3999e2a64956c3cb44bf596c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6f6e44aa2d8dabd4a2710e313f65d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a1b6f6e44aa2d8dabd4a2710e313f65d8">sin</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a> z)</td></tr>
<tr class="memdesc:a1b6f6e44aa2d8dabd4a2710e313f65d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computer the complex sine.  <a href="namespacetheoretica.html#a1b6f6e44aa2d8dabd4a2710e313f65d8">More...</a><br /></td></tr>
<tr class="separator:a1b6f6e44aa2d8dabd4a2710e313f65d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32015dfa47fc795e0fefcf26b5c0375d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a32015dfa47fc795e0fefcf26b5c0375d">cos</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a> z)</td></tr>
<tr class="memdesc:a32015dfa47fc795e0fefcf26b5c0375d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex cosine.  <a href="namespacetheoretica.html#a32015dfa47fc795e0fefcf26b5c0375d">More...</a><br /></td></tr>
<tr class="separator:a32015dfa47fc795e0fefcf26b5c0375d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc57357e424703aa6ea643697c2f6d24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#abc57357e424703aa6ea643697c2f6d24">tan</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a> z)</td></tr>
<tr class="memdesc:abc57357e424703aa6ea643697c2f6d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex tangent.  <a href="namespacetheoretica.html#abc57357e424703aa6ea643697c2f6d24">More...</a><br /></td></tr>
<tr class="separator:abc57357e424703aa6ea643697c2f6d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f593debadf5736178434aa3fe476a5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a0f593debadf5736178434aa3fe476a5c">sqrt</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a> z)</td></tr>
<tr class="memdesc:a0f593debadf5736178434aa3fe476a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex square root.  <a href="namespacetheoretica.html#a0f593debadf5736178434aa3fe476a5c">More...</a><br /></td></tr>
<tr class="separator:a0f593debadf5736178434aa3fe476a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace32efc4e4b7b555c8cdc340e7adff4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ace32efc4e4b7b555c8cdc340e7adff4a">ln</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a> z)</td></tr>
<tr class="memdesc:ace32efc4e4b7b555c8cdc340e7adff4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex logarithm.  <a href="namespacetheoretica.html#ace32efc4e4b7b555c8cdc340e7adff4a">More...</a><br /></td></tr>
<tr class="separator:ace32efc4e4b7b555c8cdc340e7adff4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c4590079678ebac8a917eeda049bf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ab6c4590079678ebac8a917eeda049bf4">asin</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a> z)</td></tr>
<tr class="memdesc:ab6c4590079678ebac8a917eeda049bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex arcsine.  <a href="namespacetheoretica.html#ab6c4590079678ebac8a917eeda049bf4">More...</a><br /></td></tr>
<tr class="separator:ab6c4590079678ebac8a917eeda049bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a281d198a95a4d2f0f85ccd003948f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a8a281d198a95a4d2f0f85ccd003948f6">acos</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a> z)</td></tr>
<tr class="memdesc:a8a281d198a95a4d2f0f85ccd003948f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex arccosine.  <a href="namespacetheoretica.html#a8a281d198a95a4d2f0f85ccd003948f6">More...</a><br /></td></tr>
<tr class="separator:a8a281d198a95a4d2f0f85ccd003948f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423991094f40604ba94e6ae9275d5ea8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a423991094f40604ba94e6ae9275d5ea8">atan</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a> z)</td></tr>
<tr class="memdesc:a423991094f40604ba94e6ae9275d5ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex arctangent.  <a href="namespacetheoretica.html#a423991094f40604ba94e6ae9275d5ea8">More...</a><br /></td></tr>
<tr class="separator:a423991094f40604ba94e6ae9275d5ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2b51694a7dd4ded3a140f92366aaed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aca2b51694a7dd4ded3a140f92366aaed">mul_uint128</a> (uint64_t a, uint64_t b, uint64_t &amp;c_low, uint64_t &amp;c_high)</td></tr>
<tr class="memdesc:aca2b51694a7dd4ded3a140f92366aaed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two 64-bit integers and store the result in two 64-bit variables, keeping 128 bits of the result.  <a href="namespacetheoretica.html#aca2b51694a7dd4ded3a140f92366aaed">More...</a><br /></td></tr>
<tr class="separator:aca2b51694a7dd4ded3a140f92366aaed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672dbbc0ea824c71d7ca0dc26b346200"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a672dbbc0ea824c71d7ca0dc26b346200">mix_mum</a> (uint64_t a, uint64_t b)</td></tr>
<tr class="memdesc:a672dbbc0ea824c71d7ca0dc26b346200"><td class="mdescLeft">&#160;</td><td class="mdescRight">MUM bit mixing function.  <a href="namespacetheoretica.html#a672dbbc0ea824c71d7ca0dc26b346200">More...</a><br /></td></tr>
<tr class="separator:a672dbbc0ea824c71d7ca0dc26b346200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249d8d6497120d311e2abbfc11c5f54d"><td class="memTemplParams" colspan="2">template&lt;typename ShiftableType &gt; </td></tr>
<tr class="memitem:a249d8d6497120d311e2abbfc11c5f54d"><td class="memTemplItemLeft" align="right" valign="top">ShiftableType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a249d8d6497120d311e2abbfc11c5f54d">bit_rotate</a> (ShiftableType x, unsigned int i)</td></tr>
<tr class="memdesc:a249d8d6497120d311e2abbfc11c5f54d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit rotation using shifting.  <a href="namespacetheoretica.html#a249d8d6497120d311e2abbfc11c5f54d">More...</a><br /></td></tr>
<tr class="separator:a249d8d6497120d311e2abbfc11c5f54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710c25d508e9e9ae9ed4e734fe4cd6f9"><td class="memItemLeft" align="right" valign="top"><a id="a710c25d508e9e9ae9ed4e734fe4cd6f9" name="a710c25d508e9e9ae9ed4e734fe4cd6f9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>th_errcode_to_errno</b> (<a class="el" href="namespacetheoretica.html#a47d8f770edb576685f4b8752f2eb9760">MATH_ERRCODE</a> err)</td></tr>
<tr class="memdesc:a710c25d508e9e9ae9ed4e734fe4cd6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a MATH_ERRCODE to errno error codes. <br /></td></tr>
<tr class="separator:a710c25d508e9e9ae9ed4e734fe4cd6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95680d1669eee1549fe112b9a846519"><td class="memItemLeft" align="right" valign="top"><a id="ae95680d1669eee1549fe112b9a846519" name="ae95680d1669eee1549fe112b9a846519"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>nan</b> ()</td></tr>
<tr class="memdesc:ae95680d1669eee1549fe112b9a846519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a quiet NaN number in floating point representation. <br /></td></tr>
<tr class="separator:ae95680d1669eee1549fe112b9a846519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e311a811c0c7e23c30e4496cfbe63d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a22e311a811c0c7e23c30e4496cfbe63d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a22e311a811c0c7e23c30e4496cfbe63d">is_nan</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a22e311a811c0c7e23c30e4496cfbe63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a generic variable is (equivalent to) a NaN number.  <a href="namespacetheoretica.html#a22e311a811c0c7e23c30e4496cfbe63d">More...</a><br /></td></tr>
<tr class="separator:a22e311a811c0c7e23c30e4496cfbe63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252ec9220e4dab52b18b400381624538"><td class="memItemLeft" align="right" valign="top"><a id="a252ec9220e4dab52b18b400381624538" name="a252ec9220e4dab52b18b400381624538"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>inf</b> ()</td></tr>
<tr class="memdesc:a252ec9220e4dab52b18b400381624538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return positive infinity in floating point representation. <br /></td></tr>
<tr class="separator:a252ec9220e4dab52b18b400381624538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e3b9080dde2e7542682cf79f0bbf50"><td class="memItemLeft" align="right" valign="top"><a id="ac8e3b9080dde2e7542682cf79f0bbf50" name="ac8e3b9080dde2e7542682cf79f0bbf50"></a>
<a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>identity</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:ac8e3b9080dde2e7542682cf79f0bbf50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identity. <br /></td></tr>
<tr class="separator:ac8e3b9080dde2e7542682cf79f0bbf50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cae4ecd47fdcd7dea25fa5ce03647cd"><td class="memItemLeft" align="right" valign="top"><a id="a6cae4ecd47fdcd7dea25fa5ce03647cd" name="a6cae4ecd47fdcd7dea25fa5ce03647cd"></a>
<a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>conjugate</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a6cae4ecd47fdcd7dea25fa5ce03647cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex conjugate of a real number (identity) <br /></td></tr>
<tr class="separator:a6cae4ecd47fdcd7dea25fa5ce03647cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726a5e18c863dc41040f5df134553fa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a726a5e18c863dc41040f5df134553fa9">square</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a726a5e18c863dc41040f5df134553fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square of a real number.  <a href="namespacetheoretica.html#a726a5e18c863dc41040f5df134553fa9">More...</a><br /></td></tr>
<tr class="separator:a726a5e18c863dc41040f5df134553fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bfa8d12242c241b6f56cebc9cdc60ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a6bfa8d12242c241b6f56cebc9cdc60ed">cube</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a6bfa8d12242c241b6f56cebc9cdc60ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cube of a real number.  <a href="namespacetheoretica.html#a6bfa8d12242c241b6f56cebc9cdc60ed">More...</a><br /></td></tr>
<tr class="separator:a6bfa8d12242c241b6f56cebc9cdc60ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68914a563241494dfe7ac42f0462920c"><td class="memTemplParams" colspan="2">template&lt;typename UnsignedIntType  = uint64_t&gt; </td></tr>
<tr class="memitem:a68914a563241494dfe7ac42f0462920c"><td class="memTemplItemLeft" align="right" valign="top">UnsignedIntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a68914a563241494dfe7ac42f0462920c">isqrt</a> (UnsignedIntType n)</td></tr>
<tr class="memdesc:a68914a563241494dfe7ac42f0462920c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the integer square root of a positive integer.  <a href="namespacetheoretica.html#a68914a563241494dfe7ac42f0462920c">More...</a><br /></td></tr>
<tr class="separator:a68914a563241494dfe7ac42f0462920c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad830de3729f8f2bea38d60ef706cf968"><td class="memTemplParams" colspan="2">template&lt;typename UnsignedIntType  = uint64_t&gt; </td></tr>
<tr class="memitem:ad830de3729f8f2bea38d60ef706cf968"><td class="memTemplItemLeft" align="right" valign="top">UnsignedIntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ad830de3729f8f2bea38d60ef706cf968">icbrt</a> (UnsignedIntType n)</td></tr>
<tr class="memdesc:ad830de3729f8f2bea38d60ef706cf968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the integer cubic root of a positive integer.  <a href="namespacetheoretica.html#ad830de3729f8f2bea38d60ef706cf968">More...</a><br /></td></tr>
<tr class="separator:ad830de3729f8f2bea38d60ef706cf968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e4cf02f9bcb4caf5371ee05d67df8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa2e4cf02f9bcb4caf5371ee05d67df8d">sqrt</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:aa2e4cf02f9bcb4caf5371ee05d67df8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square root of a real number.  <a href="namespacetheoretica.html#aa2e4cf02f9bcb4caf5371ee05d67df8d">More...</a><br /></td></tr>
<tr class="separator:aa2e4cf02f9bcb4caf5371ee05d67df8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c3b797f94ec5bc22b4c22f85417c93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a61c3b797f94ec5bc22b4c22f85417c93">cbrt</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a61c3b797f94ec5bc22b4c22f85417c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cubic root of x.  <a href="namespacetheoretica.html#a61c3b797f94ec5bc22b4c22f85417c93">More...</a><br /></td></tr>
<tr class="separator:a61c3b797f94ec5bc22b4c22f85417c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5177ff64d981840e149d1e282f1b27e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa5177ff64d981840e149d1e282f1b27e">abs</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:aa5177ff64d981840e149d1e282f1b27e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the absolute value of a real number.  <a href="namespacetheoretica.html#aa5177ff64d981840e149d1e282f1b27e">More...</a><br /></td></tr>
<tr class="separator:aa5177ff64d981840e149d1e282f1b27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61e39abd4fd4cd8cd83add5d0752e2f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ad61e39abd4fd4cd8cd83add5d0752e2f">sgn</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:ad61e39abd4fd4cd8cd83add5d0752e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sign of x (1 if positive, -1 if negative, 0 if null)  <a href="namespacetheoretica.html#ad61e39abd4fd4cd8cd83add5d0752e2f">More...</a><br /></td></tr>
<tr class="separator:ad61e39abd4fd4cd8cd83add5d0752e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad5c92586d6a0f841bfcd3759eff317"><td class="memItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#afad5c92586d6a0f841bfcd3759eff317">floor</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:afad5c92586d6a0f841bfcd3759eff317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the floor of x Computes the maximum integer number that is smaller than x.  <a href="namespacetheoretica.html#afad5c92586d6a0f841bfcd3759eff317">More...</a><br /></td></tr>
<tr class="separator:afad5c92586d6a0f841bfcd3759eff317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d079c3d95f2bc80c4619d13ff7263a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a85d079c3d95f2bc80c4619d13ff7263a">fract</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a85d079c3d95f2bc80c4619d13ff7263a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the fractional part of a real number.  <a href="namespacetheoretica.html#a85d079c3d95f2bc80c4619d13ff7263a">More...</a><br /></td></tr>
<tr class="separator:a85d079c3d95f2bc80c4619d13ff7263a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07569756dda099ecabf425371da6a31d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a07569756dda099ecabf425371da6a31d">max</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> y)</td></tr>
<tr class="memdesc:a07569756dda099ecabf425371da6a31d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the greatest number between two real numbers.  <a href="namespacetheoretica.html#a07569756dda099ecabf425371da6a31d">More...</a><br /></td></tr>
<tr class="separator:a07569756dda099ecabf425371da6a31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e295404d1712fb17851fe105715766e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5e295404d1712fb17851fe105715766e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a5e295404d1712fb17851fe105715766e">max</a> (T x, T y)</td></tr>
<tr class="memdesc:a5e295404d1712fb17851fe105715766e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two objects and return the greatest.  <a href="namespacetheoretica.html#a5e295404d1712fb17851fe105715766e">More...</a><br /></td></tr>
<tr class="separator:a5e295404d1712fb17851fe105715766e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac673920f8956ebea402eac4271f551ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ac673920f8956ebea402eac4271f551ba">min</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> y)</td></tr>
<tr class="memdesc:ac673920f8956ebea402eac4271f551ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the smallest number between two real numbers.  <a href="namespacetheoretica.html#ac673920f8956ebea402eac4271f551ba">More...</a><br /></td></tr>
<tr class="separator:ac673920f8956ebea402eac4271f551ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f4122359c1f32ba0741d098a5fbe69"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a70f4122359c1f32ba0741d098a5fbe69"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a70f4122359c1f32ba0741d098a5fbe69">min</a> (T x, T y)</td></tr>
<tr class="memdesc:a70f4122359c1f32ba0741d098a5fbe69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two objects and return the greatest.  <a href="namespacetheoretica.html#a70f4122359c1f32ba0741d098a5fbe69">More...</a><br /></td></tr>
<tr class="separator:a70f4122359c1f32ba0741d098a5fbe69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a4ad4c5446986fe2d255a03be337a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#af1a4ad4c5446986fe2d255a03be337a1">clamp</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b)</td></tr>
<tr class="memdesc:af1a4ad4c5446986fe2d255a03be337a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamp x between a and b.  <a href="namespacetheoretica.html#af1a4ad4c5446986fe2d255a03be337a1">More...</a><br /></td></tr>
<tr class="separator:af1a4ad4c5446986fe2d255a03be337a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf4d125306e3fffc7287aa42f9005a1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acdf4d125306e3fffc7287aa42f9005a1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#acdf4d125306e3fffc7287aa42f9005a1">clamp</a> (T x, T a, T b)</td></tr>
<tr class="memdesc:acdf4d125306e3fffc7287aa42f9005a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamp a value between two other values.  <a href="namespacetheoretica.html#acdf4d125306e3fffc7287aa42f9005a1">More...</a><br /></td></tr>
<tr class="separator:acdf4d125306e3fffc7287aa42f9005a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd0ef7aa0b136fbd1b4579cec14f369"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#abbd0ef7aa0b136fbd1b4579cec14f369">log2</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:abbd0ef7aa0b136fbd1b4579cec14f369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the binary logarithm of a real number.  <a href="namespacetheoretica.html#abbd0ef7aa0b136fbd1b4579cec14f369">More...</a><br /></td></tr>
<tr class="separator:abbd0ef7aa0b136fbd1b4579cec14f369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb04217fd0bd9dd23daaa186d3756d1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#adb04217fd0bd9dd23daaa186d3756d1e">log10</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:adb04217fd0bd9dd23daaa186d3756d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the base-10 logarithm of x.  <a href="namespacetheoretica.html#adb04217fd0bd9dd23daaa186d3756d1e">More...</a><br /></td></tr>
<tr class="separator:adb04217fd0bd9dd23daaa186d3756d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748eca731a8c05226332e5723b7a9d91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a748eca731a8c05226332e5723b7a9d91">ln</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a748eca731a8c05226332e5723b7a9d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of x.  <a href="namespacetheoretica.html#a748eca731a8c05226332e5723b7a9d91">More...</a><br /></td></tr>
<tr class="separator:a748eca731a8c05226332e5723b7a9d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13248f2e439afdb6f72e0f2c1e79cc55"><td class="memTemplParams" colspan="2">template&lt;typename T  = real&gt; </td></tr>
<tr class="memitem:a13248f2e439afdb6f72e0f2c1e79cc55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a13248f2e439afdb6f72e0f2c1e79cc55">pow</a> (T x, int n)</td></tr>
<tr class="memdesc:a13248f2e439afdb6f72e0f2c1e79cc55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the n-th power of x (where n is natural)  <a href="namespacetheoretica.html#a13248f2e439afdb6f72e0f2c1e79cc55">More...</a><br /></td></tr>
<tr class="separator:a13248f2e439afdb6f72e0f2c1e79cc55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5b285f294e32d7e2a601152d67b4b2"><td class="memTemplParams" colspan="2"><a id="a8b5b285f294e32d7e2a601152d67b4b2" name="a8b5b285f294e32d7e2a601152d67b4b2"></a>
template&lt;typename IntType  = unsigned long long int&gt; </td></tr>
<tr class="memitem:a8b5b285f294e32d7e2a601152d67b4b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fact</b> (unsigned int n)</td></tr>
<tr class="memdesc:a8b5b285f294e32d7e2a601152d67b4b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the factorial of n. <br /></td></tr>
<tr class="separator:a8b5b285f294e32d7e2a601152d67b4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61f8810fcedeaa35f54c834e934828e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ac61f8810fcedeaa35f54c834e934828e">exp</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:ac61f8810fcedeaa35f54c834e934828e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute \(e^x\).  <a href="namespacetheoretica.html#ac61f8810fcedeaa35f54c834e934828e">More...</a><br /></td></tr>
<tr class="separator:ac61f8810fcedeaa35f54c834e934828e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f12dd8e0fc650fa75c9961e51d1406c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a6f12dd8e0fc650fa75c9961e51d1406c">powf</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a)</td></tr>
<tr class="memdesc:a6f12dd8e0fc650fa75c9961e51d1406c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate x elevated to a real exponent.  <a href="namespacetheoretica.html#a6f12dd8e0fc650fa75c9961e51d1406c">More...</a><br /></td></tr>
<tr class="separator:a6f12dd8e0fc650fa75c9961e51d1406c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf52f04c3a1cefbb9dabab21cac0abbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#acf52f04c3a1cefbb9dabab21cac0abbb">root</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, int n)</td></tr>
<tr class="memdesc:acf52f04c3a1cefbb9dabab21cac0abbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the n-th root of x.  <a href="namespacetheoretica.html#acf52f04c3a1cefbb9dabab21cac0abbb">More...</a><br /></td></tr>
<tr class="separator:acf52f04c3a1cefbb9dabab21cac0abbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2ea0b1258dfe34df321901707d1808"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a2c2ea0b1258dfe34df321901707d1808">sin</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a2c2ea0b1258dfe34df321901707d1808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sine of a real number.  <a href="namespacetheoretica.html#a2c2ea0b1258dfe34df321901707d1808">More...</a><br /></td></tr>
<tr class="separator:a2c2ea0b1258dfe34df321901707d1808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af684d7159e22012dc5229c31eb66fceb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#af684d7159e22012dc5229c31eb66fceb">cos</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:af684d7159e22012dc5229c31eb66fceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cosine of a real number.  <a href="namespacetheoretica.html#af684d7159e22012dc5229c31eb66fceb">More...</a><br /></td></tr>
<tr class="separator:af684d7159e22012dc5229c31eb66fceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9d9a32dc2c9f00de35c1b1a49b218e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#abe9d9a32dc2c9f00de35c1b1a49b218e">tan</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:abe9d9a32dc2c9f00de35c1b1a49b218e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the tangent of x.  <a href="namespacetheoretica.html#abe9d9a32dc2c9f00de35c1b1a49b218e">More...</a><br /></td></tr>
<tr class="separator:abe9d9a32dc2c9f00de35c1b1a49b218e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6f43e74456bea35fb757f17db47da8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aec6f43e74456bea35fb757f17db47da8">cot</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:aec6f43e74456bea35fb757f17db47da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cotangent of x.  <a href="namespacetheoretica.html#aec6f43e74456bea35fb757f17db47da8">More...</a><br /></td></tr>
<tr class="separator:aec6f43e74456bea35fb757f17db47da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426b70abe4783e75806e1ae8c9e9e2bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a426b70abe4783e75806e1ae8c9e9e2bd">atan</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a426b70abe4783e75806e1ae8c9e9e2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arctangent.  <a href="namespacetheoretica.html#a426b70abe4783e75806e1ae8c9e9e2bd">More...</a><br /></td></tr>
<tr class="separator:a426b70abe4783e75806e1ae8c9e9e2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b06e5bf997c4447c10f2fa96649347"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a79b06e5bf997c4447c10f2fa96649347">asin</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a79b06e5bf997c4447c10f2fa96649347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arcsine.  <a href="namespacetheoretica.html#a79b06e5bf997c4447c10f2fa96649347">More...</a><br /></td></tr>
<tr class="separator:a79b06e5bf997c4447c10f2fa96649347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2d69e3a3387958a27d4a03ed478a99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a7f2d69e3a3387958a27d4a03ed478a99">acos</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a7f2d69e3a3387958a27d4a03ed478a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arccosine.  <a href="namespacetheoretica.html#a7f2d69e3a3387958a27d4a03ed478a99">More...</a><br /></td></tr>
<tr class="separator:a7f2d69e3a3387958a27d4a03ed478a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae6ab14a39d6132b6858934dadaaf3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a6ae6ab14a39d6132b6858934dadaaf3e">atan2</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> y, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a6ae6ab14a39d6132b6858934dadaaf3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 2 argument arctangent.  <a href="namespacetheoretica.html#a6ae6ab14a39d6132b6858934dadaaf3e">More...</a><br /></td></tr>
<tr class="separator:a6ae6ab14a39d6132b6858934dadaaf3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0650ea8e1435cc518e960bfcecf5b66e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a0650ea8e1435cc518e960bfcecf5b66e">sinh</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a0650ea8e1435cc518e960bfcecf5b66e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic sine.  <a href="namespacetheoretica.html#a0650ea8e1435cc518e960bfcecf5b66e">More...</a><br /></td></tr>
<tr class="separator:a0650ea8e1435cc518e960bfcecf5b66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fc03cbb1de8180e51183bb82c0bb28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a12fc03cbb1de8180e51183bb82c0bb28">cosh</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a12fc03cbb1de8180e51183bb82c0bb28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic cosine.  <a href="namespacetheoretica.html#a12fc03cbb1de8180e51183bb82c0bb28">More...</a><br /></td></tr>
<tr class="separator:a12fc03cbb1de8180e51183bb82c0bb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6b8fc4bb2609507cd1fae0f7d6c8a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aaf6b8fc4bb2609507cd1fae0f7d6c8a7">tanh</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:aaf6b8fc4bb2609507cd1fae0f7d6c8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic tangent.  <a href="namespacetheoretica.html#aaf6b8fc4bb2609507cd1fae0f7d6c8a7">More...</a><br /></td></tr>
<tr class="separator:aaf6b8fc4bb2609507cd1fae0f7d6c8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f957ad9b2354268f56ab1ca3843080"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a96f957ad9b2354268f56ab1ca3843080">coth</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a96f957ad9b2354268f56ab1ca3843080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic cotangent.  <a href="namespacetheoretica.html#a96f957ad9b2354268f56ab1ca3843080">More...</a><br /></td></tr>
<tr class="separator:a96f957ad9b2354268f56ab1ca3843080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c497fcd02e23df8fa0f197922c4e2c"><td class="memItemLeft" align="right" valign="top"><a id="a54c497fcd02e23df8fa0f197922c4e2c" name="a54c497fcd02e23df8fa0f197922c4e2c"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>asinh</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a54c497fcd02e23df8fa0f197922c4e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inverse hyperbolic sine. <br /></td></tr>
<tr class="separator:a54c497fcd02e23df8fa0f197922c4e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124297369ecba10c8516dc5a920aad1a"><td class="memItemLeft" align="right" valign="top"><a id="a124297369ecba10c8516dc5a920aad1a" name="a124297369ecba10c8516dc5a920aad1a"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>acosh</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a124297369ecba10c8516dc5a920aad1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inverse hyperbolic cosine. <br /></td></tr>
<tr class="separator:a124297369ecba10c8516dc5a920aad1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85064afd88800f3129e97d2e2955be4"><td class="memItemLeft" align="right" valign="top"><a id="ab85064afd88800f3129e97d2e2955be4" name="ab85064afd88800f3129e97d2e2955be4"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>atanh</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:ab85064afd88800f3129e97d2e2955be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inverse hyperbolic tangent. <br /></td></tr>
<tr class="separator:ab85064afd88800f3129e97d2e2955be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a76685197faa15403e24b836830cf5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a7a76685197faa15403e24b836830cf5d">sigmoid</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a7a76685197faa15403e24b836830cf5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sigmoid function.  <a href="namespacetheoretica.html#a7a76685197faa15403e24b836830cf5d">More...</a><br /></td></tr>
<tr class="separator:a7a76685197faa15403e24b836830cf5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1efe3bd7ff87719aab92b67cec535096"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a1efe3bd7ff87719aab92b67cec535096">sinc</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a1efe3bd7ff87719aab92b67cec535096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the normalized sinc function.  <a href="namespacetheoretica.html#a1efe3bd7ff87719aab92b67cec535096">More...</a><br /></td></tr>
<tr class="separator:a1efe3bd7ff87719aab92b67cec535096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024554cae44fb42700e8f68d235f0f15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a024554cae44fb42700e8f68d235f0f15">heaviside</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a024554cae44fb42700e8f68d235f0f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the heaviside function.  <a href="namespacetheoretica.html#a024554cae44fb42700e8f68d235f0f15">More...</a><br /></td></tr>
<tr class="separator:a024554cae44fb42700e8f68d235f0f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129bf1f1085a76b92999e0faeb30e831"><td class="memTemplParams" colspan="2">template&lt;typename IntType  = unsigned long long int&gt; </td></tr>
<tr class="memitem:a129bf1f1085a76b92999e0faeb30e831"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a129bf1f1085a76b92999e0faeb30e831">binomial_coeff</a> (unsigned int n, unsigned int m)</td></tr>
<tr class="memdesc:a129bf1f1085a76b92999e0faeb30e831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the binomial coefficient.  <a href="namespacetheoretica.html#a129bf1f1085a76b92999e0faeb30e831">More...</a><br /></td></tr>
<tr class="separator:a129bf1f1085a76b92999e0faeb30e831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286f4d2ae42de1965c86c999927f128b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a286f4d2ae42de1965c86c999927f128b">radians</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> <a class="el" href="namespacetheoretica.html#a840b8c27d0a8398f33858b1f8d55732d">degrees</a>)</td></tr>
<tr class="memdesc:a286f4d2ae42de1965c86c999927f128b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert degrees to radians.  <a href="namespacetheoretica.html#a286f4d2ae42de1965c86c999927f128b">More...</a><br /></td></tr>
<tr class="separator:a286f4d2ae42de1965c86c999927f128b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840b8c27d0a8398f33858b1f8d55732d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a840b8c27d0a8398f33858b1f8d55732d">degrees</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> <a class="el" href="namespacetheoretica.html#a286f4d2ae42de1965c86c999927f128b">radians</a>)</td></tr>
<tr class="memdesc:a840b8c27d0a8398f33858b1f8d55732d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert radians to degrees.  <a href="namespacetheoretica.html#a840b8c27d0a8398f33858b1f8d55732d">More...</a><br /></td></tr>
<tr class="separator:a840b8c27d0a8398f33858b1f8d55732d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321928d10b6606c1cba0232a613e6dfe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a321928d10b6606c1cba0232a613e6dfe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a321928d10b6606c1cba0232a613e6dfe">kronecker_delta</a> (T i, T j)</td></tr>
<tr class="memdesc:a321928d10b6606c1cba0232a613e6dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kronecker delta, equals 1 if i is equal to j, 0 otherwise.  <a href="namespacetheoretica.html#a321928d10b6606c1cba0232a613e6dfe">More...</a><br /></td></tr>
<tr class="separator:a321928d10b6606c1cba0232a613e6dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87fed634613f9a7756b807368d316cd9"><td class="memItemLeft" align="right" valign="top"><a id="a87fed634613f9a7756b807368d316cd9" name="a87fed634613f9a7756b807368d316cd9"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>product</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X)</td></tr>
<tr class="memdesc:a87fed634613f9a7756b807368d316cd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product of a set of values. <br /></td></tr>
<tr class="separator:a87fed634613f9a7756b807368d316cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d272b1cd91c9ac9f1c2049bd627f90e"><td class="memItemLeft" align="right" valign="top"><a id="a9d272b1cd91c9ac9f1c2049bd627f90e" name="a9d272b1cd91c9ac9f1c2049bd627f90e"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>product_sum</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y)</td></tr>
<tr class="memdesc:a9d272b1cd91c9ac9f1c2049bd627f90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum the products of two sets of values. <br /></td></tr>
<tr class="separator:a9d272b1cd91c9ac9f1c2049bd627f90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8e23a7720015a774c4cdcd119a434b"><td class="memItemLeft" align="right" valign="top"><a id="a8c8e23a7720015a774c4cdcd119a434b" name="a8c8e23a7720015a774c4cdcd119a434b"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>product_sum_squares</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y)</td></tr>
<tr class="memdesc:a8c8e23a7720015a774c4cdcd119a434b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum the products of the squares of two sets of data. <br /></td></tr>
<tr class="separator:a8c8e23a7720015a774c4cdcd119a434b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2455c2163719c1f26553aeff27dfe4"><td class="memItemLeft" align="right" valign="top"><a id="a0e2455c2163719c1f26553aeff27dfe4" name="a0e2455c2163719c1f26553aeff27dfe4"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>product_sum</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Z)</td></tr>
<tr class="memdesc:a0e2455c2163719c1f26553aeff27dfe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum the products of three sets of values. <br /></td></tr>
<tr class="separator:a0e2455c2163719c1f26553aeff27dfe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad506ec29923258e070ed286a31e2d9a6"><td class="memItemLeft" align="right" valign="top"><a id="ad506ec29923258e070ed286a31e2d9a6" name="ad506ec29923258e070ed286a31e2d9a6"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>quotient_sum</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y)</td></tr>
<tr class="memdesc:ad506ec29923258e070ed286a31e2d9a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum the quotients of two sets of values. <br /></td></tr>
<tr class="separator:ad506ec29923258e070ed286a31e2d9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2add9ac96bf83be926b67ac98871d519"><td class="memItemLeft" align="right" valign="top"><a id="a2add9ac96bf83be926b67ac98871d519" name="a2add9ac96bf83be926b67ac98871d519"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sum_squares</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X)</td></tr>
<tr class="memdesc:a2add9ac96bf83be926b67ac98871d519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum the squares of a set of values. <br /></td></tr>
<tr class="separator:a2add9ac96bf83be926b67ac98871d519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218096ebc25892ce56a9b64e1c9d38c0"><td class="memItemLeft" align="right" valign="top"><a id="a218096ebc25892ce56a9b64e1c9d38c0" name="a218096ebc25892ce56a9b64e1c9d38c0"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sum</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X)</td></tr>
<tr class="memdesc:a218096ebc25892ce56a9b64e1c9d38c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum together a set of values. <br /></td></tr>
<tr class="separator:a218096ebc25892ce56a9b64e1c9d38c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f1d3ea55880b60ec911458c6289aa0"><td class="memItemLeft" align="right" valign="top"><a id="a77f1d3ea55880b60ec911458c6289aa0" name="a77f1d3ea55880b60ec911458c6289aa0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>apply</b> (<a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*f)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>))</td></tr>
<tr class="memdesc:a77f1d3ea55880b60ec911458c6289aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function to a set of values. <br /></td></tr>
<tr class="separator:a77f1d3ea55880b60ec911458c6289aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983d37129521ddc1e34a1490a7994ddb"><td class="memItemLeft" align="right" valign="top"><a id="a983d37129521ddc1e34a1490a7994ddb" name="a983d37129521ddc1e34a1490a7994ddb"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>max</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X)</td></tr>
<tr class="memdesc:a983d37129521ddc1e34a1490a7994ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the maximum value inside a dataset. <br /></td></tr>
<tr class="separator:a983d37129521ddc1e34a1490a7994ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a7e33426590d28749cc79608f5a3a6"><td class="memItemLeft" align="right" valign="top"><a id="a36a7e33426590d28749cc79608f5a3a6" name="a36a7e33426590d28749cc79608f5a3a6"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>min</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X)</td></tr>
<tr class="memdesc:a36a7e33426590d28749cc79608f5a3a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the minimum value inside a dataset. <br /></td></tr>
<tr class="separator:a36a7e33426590d28749cc79608f5a3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c0ba4b2b6a02fb3ba5770165b9a2f1"><td class="memItemLeft" align="right" valign="top"><a id="a62c0ba4b2b6a02fb3ba5770165b9a2f1" name="a62c0ba4b2b6a02fb3ba5770165b9a2f1"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;obj)</td></tr>
<tr class="memdesc:a62c0ba4b2b6a02fb3ba5770165b9a2f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream the buffer in string representation to an output stream (std::ostream) <br /></td></tr>
<tr class="separator:a62c0ba4b2b6a02fb3ba5770165b9a2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3f2ff840d6e5dae38dfc1e6176a7be"><td class="memTemplParams" colspan="2">template&lt;typename T  = real&gt; </td></tr>
<tr class="memitem:a9b3f2ff840d6e5dae38dfc1e6176a7be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a9b3f2ff840d6e5dae38dfc1e6176a7be">lagrange_polynomial</a> (const std::vector&lt; <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; 2, T &gt; &gt; &amp;points)</td></tr>
<tr class="memdesc:a9b3f2ff840d6e5dae38dfc1e6176a7be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Lagrange polynomial interpolating a set of points.  <a href="namespacetheoretica.html#a9b3f2ff840d6e5dae38dfc1e6176a7be">More...</a><br /></td></tr>
<tr class="separator:a9b3f2ff840d6e5dae38dfc1e6176a7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77c5c6195e30df1e423b0922cc0776e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#af77c5c6195e30df1e423b0922cc0776e">chebyshev_nodes</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int n)</td></tr>
<tr class="memdesc:af77c5c6195e30df1e423b0922cc0776e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the n Chebyshev nodes on a given interval.  <a href="namespacetheoretica.html#af77c5c6195e30df1e423b0922cc0776e">More...</a><br /></td></tr>
<tr class="separator:af77c5c6195e30df1e423b0922cc0776e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc2216d71f0d7147b5c0dacdeea80db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a9dc2216d71f0d7147b5c0dacdeea80db">interpolate_grid</a> (<a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int order)</td></tr>
<tr class="memdesc:a9dc2216d71f0d7147b5c0dacdeea80db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the interpolating polynomial of a real function on an equidistant point sample.  <a href="namespacetheoretica.html#a9dc2216d71f0d7147b5c0dacdeea80db">More...</a><br /></td></tr>
<tr class="separator:a9dc2216d71f0d7147b5c0dacdeea80db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f9a26f1ee40dea3fced3ee7e0c9aa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a88f9a26f1ee40dea3fced3ee7e0c9aa9">interpolate_chebyshev</a> (<a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int order)</td></tr>
<tr class="memdesc:a88f9a26f1ee40dea3fced3ee7e0c9aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the interpolating polynomial of a real function using Chebyshev nodes as sampling points.  <a href="namespacetheoretica.html#a88f9a26f1ee40dea3fced3ee7e0c9aa9">More...</a><br /></td></tr>
<tr class="separator:a88f9a26f1ee40dea3fced3ee7e0c9aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0edd44311fc206d96919ab11d1977a9"><td class="memItemLeft" align="right" valign="top"><a id="aa0edd44311fc206d96919ab11d1977a9" name="aa0edd44311fc206d96919ab11d1977a9"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lerp</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x1, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> interp)</td></tr>
<tr class="memdesc:aa0edd44311fc206d96919ab11d1977a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear interpolation. <br /></td></tr>
<tr class="separator:aa0edd44311fc206d96919ab11d1977a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7765f4fbfe237744fe9819a6aaae2376"><td class="memTemplParams" colspan="2"><a id="a7765f4fbfe237744fe9819a6aaae2376" name="a7765f4fbfe237744fe9819a6aaae2376"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a7765f4fbfe237744fe9819a6aaae2376"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>lerp</b> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; P1, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; P2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> interp)</td></tr>
<tr class="memdesc:a7765f4fbfe237744fe9819a6aaae2376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear interpolation. <br /></td></tr>
<tr class="separator:a7765f4fbfe237744fe9819a6aaae2376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a854543c4d5334c61247aed920937c7"><td class="memItemLeft" align="right" valign="top"><a id="a7a854543c4d5334c61247aed920937c7" name="a7a854543c4d5334c61247aed920937c7"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>invlerp</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x1, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> value)</td></tr>
<tr class="memdesc:a7a854543c4d5334c61247aed920937c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse linear interpolation. <br /></td></tr>
<tr class="separator:a7a854543c4d5334c61247aed920937c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ed1580590487a3d2b7b0c836b23e7b"><td class="memTemplParams" colspan="2"><a id="a40ed1580590487a3d2b7b0c836b23e7b" name="a40ed1580590487a3d2b7b0c836b23e7b"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a40ed1580590487a3d2b7b0c836b23e7b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>invlerp</b> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; P1, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; P2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> value)</td></tr>
<tr class="memdesc:a40ed1580590487a3d2b7b0c836b23e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse linear interpolation. <br /></td></tr>
<tr class="separator:a40ed1580590487a3d2b7b0c836b23e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d55941e7aa059d066873e4116c531b0"><td class="memItemLeft" align="right" valign="top"><a id="a6d55941e7aa059d066873e4116c531b0" name="a6d55941e7aa059d066873e4116c531b0"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>remap</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> iFrom, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> iTo, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> oFrom, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> oTo, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> value)</td></tr>
<tr class="memdesc:a6d55941e7aa059d066873e4116c531b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remap a value from one range to another. <br /></td></tr>
<tr class="separator:a6d55941e7aa059d066873e4116c531b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289be70d029eee26d9ee9e975a40b5fa"><td class="memTemplParams" colspan="2"><a id="a289be70d029eee26d9ee9e975a40b5fa" name="a289be70d029eee26d9ee9e975a40b5fa"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a289be70d029eee26d9ee9e975a40b5fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>remap</b> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; iFrom, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; iTo, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; oFrom, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; oTo, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> value)</td></tr>
<tr class="memdesc:a289be70d029eee26d9ee9e975a40b5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remap a vector value from one range to another. <br /></td></tr>
<tr class="separator:a289be70d029eee26d9ee9e975a40b5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38cddd68590c7b5e6d70646776b648f9"><td class="memTemplParams" colspan="2"><a id="a38cddd68590c7b5e6d70646776b648f9" name="a38cddd68590c7b5e6d70646776b648f9"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a38cddd68590c7b5e6d70646776b648f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nlerp</b> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; P1, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; P2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> interp)</td></tr>
<tr class="memdesc:a38cddd68590c7b5e6d70646776b648f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalized linear interpolation. <br /></td></tr>
<tr class="separator:a38cddd68590c7b5e6d70646776b648f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c80e941d5c102eae47c3935afdc0e4"><td class="memTemplParams" colspan="2"><a id="aa8c80e941d5c102eae47c3935afdc0e4" name="aa8c80e941d5c102eae47c3935afdc0e4"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:aa8c80e941d5c102eae47c3935afdc0e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>slerp</b> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; P1, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; P2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> t)</td></tr>
<tr class="memdesc:aa8c80e941d5c102eae47c3935afdc0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spherical interpolation. <br /></td></tr>
<tr class="separator:aa8c80e941d5c102eae47c3935afdc0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b8a327e65a2d21993a28009828faae"><td class="memItemLeft" align="right" valign="top"><a id="a75b8a327e65a2d21993a28009828faae" name="a75b8a327e65a2d21993a28009828faae"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>smoothstep</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x1, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> interp)</td></tr>
<tr class="memdesc:a75b8a327e65a2d21993a28009828faae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smoothstep interpolation. <br /></td></tr>
<tr class="separator:a75b8a327e65a2d21993a28009828faae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423c4bdba84ea280878dcef43b5df206"><td class="memItemLeft" align="right" valign="top"><a id="a423c4bdba84ea280878dcef43b5df206" name="a423c4bdba84ea280878dcef43b5df206"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>smootherstep</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x1, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> interp)</td></tr>
<tr class="memdesc:a423c4bdba84ea280878dcef43b5df206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smootherstep interpolation. <br /></td></tr>
<tr class="separator:a423c4bdba84ea280878dcef43b5df206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69213a79c487ca5266077e64f7624fb3"><td class="memTemplParams" colspan="2"><a id="a69213a79c487ca5266077e64f7624fb3" name="a69213a79c487ca5266077e64f7624fb3"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a69213a79c487ca5266077e64f7624fb3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>quadratic_bezier</b> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; P0, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; P1, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; P2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> t)</td></tr>
<tr class="memdesc:a69213a79c487ca5266077e64f7624fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quadratic Bezier curve. <br /></td></tr>
<tr class="separator:a69213a79c487ca5266077e64f7624fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b261d224ea1a2878b802013eae0fbaf"><td class="memTemplParams" colspan="2"><a id="a2b261d224ea1a2878b802013eae0fbaf" name="a2b261d224ea1a2878b802013eae0fbaf"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a2b261d224ea1a2878b802013eae0fbaf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cubic_bezier</b> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; P0, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; P1, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; P2, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; P3, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> t)</td></tr>
<tr class="memdesc:a2b261d224ea1a2878b802013eae0fbaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cubic Bezier curve. <br /></td></tr>
<tr class="separator:a2b261d224ea1a2878b802013eae0fbaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaac9bb0b5b83e96e4312cef9d99af68"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:aeaac9bb0b5b83e96e4312cef9d99af68"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aeaac9bb0b5b83e96e4312cef9d99af68">bezier</a> (std::vector&lt; <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; &gt; points, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> t)</td></tr>
<tr class="memdesc:aeaac9bb0b5b83e96e4312cef9d99af68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic Bezier curve in N dimensions.  <a href="namespacetheoretica.html#aeaac9bb0b5b83e96e4312cef9d99af68">More...</a><br /></td></tr>
<tr class="separator:aeaac9bb0b5b83e96e4312cef9d99af68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30bf47b100bccb63fb06b68397a7c28c"><td class="memTemplParams" colspan="2"><a id="a30bf47b100bccb63fb06b68397a7c28c" name="a30bf47b100bccb63fb06b68397a7c28c"></a>
template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a30bf47b100bccb63fb06b68397a7c28c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>approx_max_goldensection</b> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b)</td></tr>
<tr class="memdesc:a30bf47b100bccb63fb06b68397a7c28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a function maximum using the Golden Section search algorithm. <br /></td></tr>
<tr class="separator:a30bf47b100bccb63fb06b68397a7c28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297397efe063a52c126c2232fc65d03a"><td class="memTemplParams" colspan="2"><a id="a297397efe063a52c126c2232fc65d03a" name="a297397efe063a52c126c2232fc65d03a"></a>
template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a297397efe063a52c126c2232fc65d03a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>approx_min_goldensection</b> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b)</td></tr>
<tr class="memdesc:a297397efe063a52c126c2232fc65d03a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a function minimum using the Golden Section search algorithm. <br /></td></tr>
<tr class="separator:a297397efe063a52c126c2232fc65d03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f27c104f6244cc0dda21b4bc46a225c"><td class="memTemplParams" colspan="2"><a id="a4f27c104f6244cc0dda21b4bc46a225c" name="a4f27c104f6244cc0dda21b4bc46a225c"></a>
template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a4f27c104f6244cc0dda21b4bc46a225c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>approx_max_newton</b> (RealFunction f, RealFunction Df, RealFunction D2f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:a4f27c104f6244cc0dda21b4bc46a225c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a function maximum given the function and the first two derivatives using Newton-Raphson. <br /></td></tr>
<tr class="separator:a4f27c104f6244cc0dda21b4bc46a225c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1efb73e66d3a6ca97a2904aa06f3f6"><td class="memTemplParams" colspan="2"><a id="a8a1efb73e66d3a6ca97a2904aa06f3f6" name="a8a1efb73e66d3a6ca97a2904aa06f3f6"></a>
template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a8a1efb73e66d3a6ca97a2904aa06f3f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>approx_min_newton</b> (RealFunction f, RealFunction Df, RealFunction D2f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:a8a1efb73e66d3a6ca97a2904aa06f3f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a function minimum given the function and the first two derivatives using Newton-Raphson. <br /></td></tr>
<tr class="separator:a8a1efb73e66d3a6ca97a2904aa06f3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec19c3cb57810dac37ac300c895bb50"><td class="memTemplParams" colspan="2"><a id="a9ec19c3cb57810dac37ac300c895bb50" name="a9ec19c3cb57810dac37ac300c895bb50"></a>
template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a9ec19c3cb57810dac37ac300c895bb50"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>approx_max_bisection</b> (RealFunction f, RealFunction Df, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b)</td></tr>
<tr class="memdesc:a9ec19c3cb57810dac37ac300c895bb50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a function maximum inside an interval given the function and its first derivative using bisection on the derivative. <br /></td></tr>
<tr class="separator:a9ec19c3cb57810dac37ac300c895bb50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2040484743eb55bcd56e4c79f20ea6e1"><td class="memTemplParams" colspan="2"><a id="a2040484743eb55bcd56e4c79f20ea6e1" name="a2040484743eb55bcd56e4c79f20ea6e1"></a>
template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a2040484743eb55bcd56e4c79f20ea6e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>approx_min_bisection</b> (RealFunction f, RealFunction Df, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b)</td></tr>
<tr class="memdesc:a2040484743eb55bcd56e4c79f20ea6e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a function minimum inside an interval given the function and its first derivative using bisection on the derivative. <br /></td></tr>
<tr class="separator:a2040484743eb55bcd56e4c79f20ea6e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38995aba223210db261b147df9efc1d"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:aa38995aba223210db261b147df9efc1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa38995aba223210db261b147df9efc1d">minimize_grad</a> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; &gt;), <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; guess=<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;(0), <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> gamma=<a class="el" href="namespacetheoretica.html#ab33f363492da480d62e2e0b5ad2c4ee9">MINGRAD_GAMMA</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#a5ebee50e5a5a80baaa6532a736ce7d55">MINGRAD_TOLERANCE</a>, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#acd4ef8ed777e402e2ae0c7f736ba20cb">MINGRAD_MAX_ITER</a>)</td></tr>
<tr class="memdesc:aa38995aba223210db261b147df9efc1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a local minimum of the given multivariate function using fixed-step gradient descent.  <a href="namespacetheoretica.html#aa38995aba223210db261b147df9efc1d">More...</a><br /></td></tr>
<tr class="separator:aa38995aba223210db261b147df9efc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb593b1732cc1d59184ca33c0d82ac8"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:adeb593b1732cc1d59184ca33c0d82ac8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#adeb593b1732cc1d59184ca33c0d82ac8">maximize_grad</a> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; &gt;), <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; guess=<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;(0), <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> gamma=<a class="el" href="namespacetheoretica.html#ab33f363492da480d62e2e0b5ad2c4ee9">MINGRAD_GAMMA</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#a5ebee50e5a5a80baaa6532a736ce7d55">MINGRAD_TOLERANCE</a>, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#acd4ef8ed777e402e2ae0c7f736ba20cb">MINGRAD_MAX_ITER</a>)</td></tr>
<tr class="memdesc:adeb593b1732cc1d59184ca33c0d82ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a local maximum of the given multivariate function using fixed-step gradient descent.  <a href="namespacetheoretica.html#adeb593b1732cc1d59184ca33c0d82ac8">More...</a><br /></td></tr>
<tr class="separator:adeb593b1732cc1d59184ca33c0d82ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4c98e4f539167c2b5af80fe78fedd5"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a2c4c98e4f539167c2b5af80fe78fedd5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a2c4c98e4f539167c2b5af80fe78fedd5">minimize_lingrad</a> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; &gt;), <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; guess=<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;(0), <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> tolerance=<a class="el" href="namespacetheoretica.html#a5ebee50e5a5a80baaa6532a736ce7d55">MINGRAD_TOLERANCE</a>, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#acd4ef8ed777e402e2ae0c7f736ba20cb">MINGRAD_MAX_ITER</a>)</td></tr>
<tr class="memdesc:a2c4c98e4f539167c2b5af80fe78fedd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a local minimum of the given multivariate function using gradient descent with linear search.  <a href="namespacetheoretica.html#a2c4c98e4f539167c2b5af80fe78fedd5">More...</a><br /></td></tr>
<tr class="separator:a2c4c98e4f539167c2b5af80fe78fedd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8940cabdea5cdb34d24ba521f22939"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a6c8940cabdea5cdb34d24ba521f22939"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a6c8940cabdea5cdb34d24ba521f22939">minimize</a> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; &gt;), <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; guess=<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;(0))</td></tr>
<tr class="memdesc:a6c8940cabdea5cdb34d24ba521f22939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the best available algorithm to find a local minimum of the given multivariate function.  <a href="namespacetheoretica.html#a6c8940cabdea5cdb34d24ba521f22939">More...</a><br /></td></tr>
<tr class="separator:a6c8940cabdea5cdb34d24ba521f22939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51700f99ca632df7d692a5ebc2b91c1"><td class="memTemplParams" colspan="2"><a id="aa51700f99ca632df7d692a5ebc2b91c1" name="aa51700f99ca632df7d692a5ebc2b91c1"></a>
template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:aa51700f99ca632df7d692a5ebc2b91c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>approx_root_bisection</b> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b)</td></tr>
<tr class="memdesc:aa51700f99ca632df7d692a5ebc2b91c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a root of an arbitrary function using bisection inside a compact interval [a, b] where f(a) * f(b) &lt; 0. <br /></td></tr>
<tr class="separator:aa51700f99ca632df7d692a5ebc2b91c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229a29edbdd8530878f3a2c21073fcb3"><td class="memTemplParams" colspan="2"><a id="a229a29edbdd8530878f3a2c21073fcb3" name="a229a29edbdd8530878f3a2c21073fcb3"></a>
template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a229a29edbdd8530878f3a2c21073fcb3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>approx_root_newton</b> (RealFunction f, RealFunction Df, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:a229a29edbdd8530878f3a2c21073fcb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a root of an arbitrary function using Newthon's method. <br /></td></tr>
<tr class="separator:a229a29edbdd8530878f3a2c21073fcb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4ac513ec5910fb28aaacbdd75583b1"><td class="memItemLeft" align="right" valign="top"><a id="a0a4ac513ec5910fb28aaacbdd75583b1" name="a0a4ac513ec5910fb28aaacbdd75583b1"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>approx_root_newton</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a>(*f)(<a class="el" href="classtheoretica_1_1dual.html">dual</a>), <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:a0a4ac513ec5910fb28aaacbdd75583b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a root of an arbitrary function using Newthon's method, computing the derivative using automatic differentiation. <br /></td></tr>
<tr class="separator:a0a4ac513ec5910fb28aaacbdd75583b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a99a3c1aefa232bd14f4153eb4183c"><td class="memItemLeft" align="right" valign="top"><a id="a69a99a3c1aefa232bd14f4153eb4183c" name="a69a99a3c1aefa232bd14f4153eb4183c"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>approx_polyn_root_newton</b> (<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; p, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:a69a99a3c1aefa232bd14f4153eb4183c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a root of a polynomial using Newthon's method. <br /></td></tr>
<tr class="separator:a69a99a3c1aefa232bd14f4153eb4183c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf31ac9c03d1bf657ac87ebac89285bf"><td class="memTemplParams" colspan="2"><a id="adf31ac9c03d1bf657ac87ebac89285bf" name="adf31ac9c03d1bf657ac87ebac89285bf"></a>
template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:adf31ac9c03d1bf657ac87ebac89285bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>approx_root_halley</b> (RealFunction f, RealFunction Df, RealFunction D2f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:adf31ac9c03d1bf657ac87ebac89285bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a root of an arbitrary function using Halley's method. <br /></td></tr>
<tr class="separator:adf31ac9c03d1bf657ac87ebac89285bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9fa575e8737274611d740292c1c8a4e"><td class="memItemLeft" align="right" valign="top"><a id="ad9fa575e8737274611d740292c1c8a4e" name="ad9fa575e8737274611d740292c1c8a4e"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>approx_root_halley</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>(*f)(<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>), <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:ad9fa575e8737274611d740292c1c8a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a root of an arbitrary function using Halley's method. <br /></td></tr>
<tr class="separator:ad9fa575e8737274611d740292c1c8a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e0bd719d5274d2179dbcd1be6988b3"><td class="memItemLeft" align="right" valign="top"><a id="a93e0bd719d5274d2179dbcd1be6988b3" name="a93e0bd719d5274d2179dbcd1be6988b3"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>approx_polyn_root_halley</b> (<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; p, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:a93e0bd719d5274d2179dbcd1be6988b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a root of a polynomial using Halley's method. <br /></td></tr>
<tr class="separator:a93e0bd719d5274d2179dbcd1be6988b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99090487fe31d6d400bf82ac833c3b72"><td class="memTemplParams" colspan="2"><a id="a99090487fe31d6d400bf82ac833c3b72" name="a99090487fe31d6d400bf82ac833c3b72"></a>
template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:a99090487fe31d6d400bf82ac833c3b72"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>approx_root_steffensen</b> (RealFunction f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:a99090487fe31d6d400bf82ac833c3b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a root of an arbitrary function using Steffensen's method. <br /></td></tr>
<tr class="separator:a99090487fe31d6d400bf82ac833c3b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c661fbdbe2cadaddfbcbb844d8ff011"><td class="memItemLeft" align="right" valign="top"><a id="a0c661fbdbe2cadaddfbcbb844d8ff011" name="a0c661fbdbe2cadaddfbcbb844d8ff011"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>approx_polyn_root_steffensen</b> (<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; p, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:a0c661fbdbe2cadaddfbcbb844d8ff011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a root of a polynomial using Steffensen's method. <br /></td></tr>
<tr class="separator:a0c661fbdbe2cadaddfbcbb844d8ff011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3ee18cb5d5f6e407aefe134e282ed3"><td class="memTemplParams" colspan="2"><a id="adf3ee18cb5d5f6e407aefe134e282ed3" name="adf3ee18cb5d5f6e407aefe134e282ed3"></a>
template&lt;typename RealFunction &gt; </td></tr>
<tr class="memitem:adf3ee18cb5d5f6e407aefe134e282ed3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>approx_root_chebyshev</b> (RealFunction f, RealFunction Df, RealFunction D2f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:adf3ee18cb5d5f6e407aefe134e282ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a root of an arbitrary function using Chebyshev's method. <br /></td></tr>
<tr class="separator:adf3ee18cb5d5f6e407aefe134e282ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b5bb061cace814539be47c2b389470"><td class="memItemLeft" align="right" valign="top"><a id="ac8b5bb061cace814539be47c2b389470" name="ac8b5bb061cace814539be47c2b389470"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>approx_root_chebyshev</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>(*f)(<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>), <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:ac8b5bb061cace814539be47c2b389470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a root of an arbitrary function using Chebyshev's method. <br /></td></tr>
<tr class="separator:ac8b5bb061cace814539be47c2b389470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ad6e0cf459b4fb68c41f781b0e7afc"><td class="memItemLeft" align="right" valign="top"><a id="ac1ad6e0cf459b4fb68c41f781b0e7afc" name="ac1ad6e0cf459b4fb68c41f781b0e7afc"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>approx_polyn_root_chebyshev</b> (<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; p, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:ac1ad6e0cf459b4fb68c41f781b0e7afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a root of a polynomial using Chebyshev's method. <br /></td></tr>
<tr class="separator:ac1ad6e0cf459b4fb68c41f781b0e7afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5adf7d2f3094d32dd9d4059ec86247db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a5adf7d2f3094d32dd9d4059ec86247db">gen_polyn_recurr</a> (<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; P0, <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; P1, <a class="el" href="namespacetheoretica.html#adb4ba8e2a5511c5650d331d0209013ff">polyn_recurr_formula</a> f, unsigned int n)</td></tr>
<tr class="memdesc:a5adf7d2f3094d32dd9d4059ec86247db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a polynomial basis using a recursion formula.  <a href="namespacetheoretica.html#a5adf7d2f3094d32dd9d4059ec86247db">More...</a><br /></td></tr>
<tr class="separator:a5adf7d2f3094d32dd9d4059ec86247db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed24464894a5a23896554578641576ac"><td class="memItemLeft" align="right" valign="top"><a id="aed24464894a5a23896554578641576ac" name="aed24464894a5a23896554578641576ac"></a>
<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>legendre_polyn_recurr</b> (<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; P0, <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; P1, unsigned int l)</td></tr>
<tr class="memdesc:aed24464894a5a23896554578641576ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursion formula for Legendre polynomials. <br /></td></tr>
<tr class="separator:aed24464894a5a23896554578641576ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa95392d9bfc3ddf34f3e82f4b6ae78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#acaa95392d9bfc3ddf34f3e82f4b6ae78">legendre_polynomial</a> (unsigned int n)</td></tr>
<tr class="memdesc:acaa95392d9bfc3ddf34f3e82f4b6ae78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the nth Legendre polynomial.  <a href="namespacetheoretica.html#acaa95392d9bfc3ddf34f3e82f4b6ae78">More...</a><br /></td></tr>
<tr class="separator:acaa95392d9bfc3ddf34f3e82f4b6ae78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca937d779d223cab3a43b4236876491a"><td class="memItemLeft" align="right" valign="top"><a id="aca937d779d223cab3a43b4236876491a" name="aca937d779d223cab3a43b4236876491a"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>legendre_polyn_normalization</b> (unsigned int n)</td></tr>
<tr class="memdesc:aca937d779d223cab3a43b4236876491a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalization constant for the nth Legendre polynomial. <br /></td></tr>
<tr class="separator:aca937d779d223cab3a43b4236876491a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5a48283ac42a9362f25d977d066cf3"><td class="memItemLeft" align="right" valign="top"><a id="a0b5a48283ac42a9362f25d977d066cf3" name="a0b5a48283ac42a9362f25d977d066cf3"></a>
<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>laguerre_polyn_recurr</b> (<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; L0, <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; L1, unsigned int i)</td></tr>
<tr class="memdesc:a0b5a48283ac42a9362f25d977d066cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursion formula for Laguerre polynomials. <br /></td></tr>
<tr class="separator:a0b5a48283ac42a9362f25d977d066cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62665bb64745df12234614b05c2dfb3"><td class="memItemLeft" align="right" valign="top"><a id="af62665bb64745df12234614b05c2dfb3" name="af62665bb64745df12234614b05c2dfb3"></a>
<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>laguerre_polynomial</b> (unsigned int n)</td></tr>
<tr class="memdesc:af62665bb64745df12234614b05c2dfb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the nth Laguerre polynomial. <br /></td></tr>
<tr class="separator:af62665bb64745df12234614b05c2dfb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da3a4e4195c5c77e99db62ae442fa19"><td class="memItemLeft" align="right" valign="top"><a id="a2da3a4e4195c5c77e99db62ae442fa19" name="a2da3a4e4195c5c77e99db62ae442fa19"></a>
<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>hermite_polyn_recurr</b> (<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; H0, <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; H1, unsigned int i)</td></tr>
<tr class="memdesc:a2da3a4e4195c5c77e99db62ae442fa19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursion formula for Hermite polynomials. <br /></td></tr>
<tr class="separator:a2da3a4e4195c5c77e99db62ae442fa19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd97a0d6d99915f065567958760164f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#afd97a0d6d99915f065567958760164f4">hermite_polynomial</a> (unsigned int n)</td></tr>
<tr class="memdesc:afd97a0d6d99915f065567958760164f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the nth Hermite polynomial.  <a href="namespacetheoretica.html#afd97a0d6d99915f065567958760164f4">More...</a><br /></td></tr>
<tr class="separator:afd97a0d6d99915f065567958760164f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7659e1b121c8c96e884b95bb4ae45ebc"><td class="memItemLeft" align="right" valign="top"><a id="a7659e1b121c8c96e884b95bb4ae45ebc" name="a7659e1b121c8c96e884b95bb4ae45ebc"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>hermite_polyn_normalization</b> (unsigned int n)</td></tr>
<tr class="memdesc:a7659e1b121c8c96e884b95bb4ae45ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalization constant for the nth Hermite polynomial. <br /></td></tr>
<tr class="separator:a7659e1b121c8c96e884b95bb4ae45ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e77e33cee4661bf1a52bec32fa434c"><td class="memItemLeft" align="right" valign="top"><a id="ac8e77e33cee4661bf1a52bec32fa434c" name="ac8e77e33cee4661bf1a52bec32fa434c"></a>
<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>chebyshev_polyn_recurr</b> (<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; T0, <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; T1, unsigned int i)</td></tr>
<tr class="memdesc:ac8e77e33cee4661bf1a52bec32fa434c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursion formula for Chebyshev polynomials The formula is the same for first and second kind polynomials. <br /></td></tr>
<tr class="separator:ac8e77e33cee4661bf1a52bec32fa434c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085e34f437a529b59778090e0cb122e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a085e34f437a529b59778090e0cb122e5">chebyshev1_polynomial</a> (unsigned int n)</td></tr>
<tr class="memdesc:a085e34f437a529b59778090e0cb122e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the nth Chebyshev polynomial of the first kind.  <a href="namespacetheoretica.html#a085e34f437a529b59778090e0cb122e5">More...</a><br /></td></tr>
<tr class="separator:a085e34f437a529b59778090e0cb122e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3450aa75a960635e9f33a6dabb22752b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a3450aa75a960635e9f33a6dabb22752b">chebyshev2_polynomial</a> (unsigned int n)</td></tr>
<tr class="memdesc:a3450aa75a960635e9f33a6dabb22752b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the nth Chebyshev polynomial of the second kind.  <a href="namespacetheoretica.html#a3450aa75a960635e9f33a6dabb22752b">More...</a><br /></td></tr>
<tr class="separator:a3450aa75a960635e9f33a6dabb22752b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d9d3758ff38fa704a20a69acf52fa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ab8d9d3758ff38fa704a20a69acf52fa9">integral_crude</a> (<a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g, unsigned int N=10000)</td></tr>
<tr class="memdesc:ab8d9d3758ff38fa704a20a69acf52fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate an integral by using Crude Monte Carlo integration.  <a href="namespacetheoretica.html#ab8d9d3758ff38fa704a20a69acf52fa9">More...</a><br /></td></tr>
<tr class="separator:ab8d9d3758ff38fa704a20a69acf52fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209c9b01ff5ed0f29ffc62af1f53be9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a209c9b01ff5ed0f29ffc62af1f53be9e">integral_quasi_crude</a> (<a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int N=10000)</td></tr>
<tr class="memdesc:a209c9b01ff5ed0f29ffc62af1f53be9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate an integral by using Crude Quasi-Monte Carlo integration by sampling from the Weyl sequence.  <a href="namespacetheoretica.html#a209c9b01ff5ed0f29ffc62af1f53be9e">More...</a><br /></td></tr>
<tr class="separator:a209c9b01ff5ed0f29ffc62af1f53be9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967dd449e256761db7b35e735293eced"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a967dd449e256761db7b35e735293eced">integral_hom</a> (<a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> f_max, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g, unsigned int N=10000)</td></tr>
<tr class="memdesc:a967dd449e256761db7b35e735293eced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate an integral by using Hit-or-miss Monte Carlo integration.  <a href="namespacetheoretica.html#a967dd449e256761db7b35e735293eced">More...</a><br /></td></tr>
<tr class="separator:a967dd449e256761db7b35e735293eced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74aacdc1b73b70ecb0d8a2c9890b8371"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a74aacdc1b73b70ecb0d8a2c9890b8371">integral_quasi_hom</a> (<a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> f_max, unsigned int N=10000)</td></tr>
<tr class="memdesc:a74aacdc1b73b70ecb0d8a2c9890b8371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate an integral by using Hit-or-miss Quasi-Monte Carlo integration, sampling points from the Weyl bi-dimensional sequence.  <a href="namespacetheoretica.html#a74aacdc1b73b70ecb0d8a2c9890b8371">More...</a><br /></td></tr>
<tr class="separator:a74aacdc1b73b70ecb0d8a2c9890b8371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef98fa2e06497f31c13f7377ddd6c0ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aef98fa2e06497f31c13f7377ddd6c0ce">integral_hom_2d</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*f)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>), <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> c, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> d, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> f_max, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g, unsigned int N=10000)</td></tr>
<tr class="memdesc:aef98fa2e06497f31c13f7377ddd6c0ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the Hit-or-Miss Monte Carlo method to approximate a double integral.  <a href="namespacetheoretica.html#aef98fa2e06497f31c13f7377ddd6c0ce">More...</a><br /></td></tr>
<tr class="separator:aef98fa2e06497f31c13f7377ddd6c0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1025a8b933cfe7077936c4be27971c1"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ab1025a8b933cfe7077936c4be27971c1">rand_congruential</a> (uint64_t x, uint64_t a=48271, uint64_t c=0, uint64_t m=((uint64_t) 1&lt;&lt; 31) - 1)</td></tr>
<tr class="memdesc:ab1025a8b933cfe7077936c4be27971c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Congruential pseudorandom number generation algorithm.  <a href="namespacetheoretica.html#ab1025a8b933cfe7077936c4be27971c1">More...</a><br /></td></tr>
<tr class="separator:ab1025a8b933cfe7077936c4be27971c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a41f7dda7d0ad8cc8a4559afcf2ad7"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a36a41f7dda7d0ad8cc8a4559afcf2ad7">rand_congruential</a> (uint64_t x, std::vector&lt; uint64_t &gt; &amp;state)</td></tr>
<tr class="memdesc:a36a41f7dda7d0ad8cc8a4559afcf2ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Congruential pseudorandom number generation algorithm (wrapper)  <a href="namespacetheoretica.html#a36a41f7dda7d0ad8cc8a4559afcf2ad7">More...</a><br /></td></tr>
<tr class="separator:a36a41f7dda7d0ad8cc8a4559afcf2ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6faedb3d913a589365b108f5ec304e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aed6faedb3d913a589365b108f5ec304e">rand_xoshiro</a> (uint64_t &amp;a, uint64_t &amp;b, uint64_t &amp;c, uint64_t &amp;d)</td></tr>
<tr class="memdesc:aed6faedb3d913a589365b108f5ec304e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Xoshiro256++ pseudorandom number generation algorithm.  <a href="namespacetheoretica.html#aed6faedb3d913a589365b108f5ec304e">More...</a><br /></td></tr>
<tr class="separator:aed6faedb3d913a589365b108f5ec304e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b30362a1d08c8522c5297efd6f4a47"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a13b30362a1d08c8522c5297efd6f4a47">rand_xoshiro</a> (uint64_t x, std::vector&lt; uint64_t &gt; &amp;state)</td></tr>
<tr class="memdesc:a13b30362a1d08c8522c5297efd6f4a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Xoshiro256++ pseudorandom number generation algorithm.  <a href="namespacetheoretica.html#a13b30362a1d08c8522c5297efd6f4a47">More...</a><br /></td></tr>
<tr class="separator:a13b30362a1d08c8522c5297efd6f4a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058181f973ba2744704e6c6211477a35"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a058181f973ba2744704e6c6211477a35">rand_splitmix64</a> (uint64_t x)</td></tr>
<tr class="memdesc:a058181f973ba2744704e6c6211477a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">SplitMix64 pseudorandom number generation.  <a href="namespacetheoretica.html#a058181f973ba2744704e6c6211477a35">More...</a><br /></td></tr>
<tr class="separator:a058181f973ba2744704e6c6211477a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad198dee1300488d1b3e51767d62beedf"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ad198dee1300488d1b3e51767d62beedf">rand_splitmix64</a> (uint64_t x, std::vector&lt; uint64_t &gt; &amp;p)</td></tr>
<tr class="memdesc:ad198dee1300488d1b3e51767d62beedf"><td class="mdescLeft">&#160;</td><td class="mdescRight">SplitMix64 pseudorandom number generation.  <a href="namespacetheoretica.html#ad198dee1300488d1b3e51767d62beedf">More...</a><br /></td></tr>
<tr class="separator:ad198dee1300488d1b3e51767d62beedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470e255aed45a7dba74af4af68b31d0d"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a470e255aed45a7dba74af4af68b31d0d">rand_wyrand</a> (uint64_t &amp;seed, uint64_t p1, uint64_t p2)</td></tr>
<tr class="memdesc:a470e255aed45a7dba74af4af68b31d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wyrand pseudorandom number generation.  <a href="namespacetheoretica.html#a470e255aed45a7dba74af4af68b31d0d">More...</a><br /></td></tr>
<tr class="separator:a470e255aed45a7dba74af4af68b31d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5deb3df62eb53ec187a4660d42d8d5f1"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a5deb3df62eb53ec187a4660d42d8d5f1">rand_wyrand</a> (uint64_t x, std::vector&lt; uint64_t &gt; &amp;p)</td></tr>
<tr class="memdesc:a5deb3df62eb53ec187a4660d42d8d5f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wyrand pseudorandom number generation.  <a href="namespacetheoretica.html#a5deb3df62eb53ec187a4660d42d8d5f1">More...</a><br /></td></tr>
<tr class="separator:a5deb3df62eb53ec187a4660d42d8d5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e523c1cc3621e7cbc1ac0df01913c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa7e523c1cc3621e7cbc1ac0df01913c3">qrand_weyl</a> (unsigned int n, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> alpha=<a class="el" href="namespacetheoretica.html#a6a6de16e5ee81d340ff91dbadb99edde">INVPHI</a>)</td></tr>
<tr class="memdesc:aa7e523c1cc3621e7cbc1ac0df01913c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weyl quasi-random sequence.  <a href="namespacetheoretica.html#aa7e523c1cc3621e7cbc1ac0df01913c3">More...</a><br /></td></tr>
<tr class="separator:aa7e523c1cc3621e7cbc1ac0df01913c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5001951408c716ce4e6414cc45f420"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a6c5001951408c716ce4e6414cc45f420">qrand_weyl_recurr</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> prev=0, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> alpha=<a class="el" href="namespacetheoretica.html#a6a6de16e5ee81d340ff91dbadb99edde">INVPHI</a>)</td></tr>
<tr class="memdesc:a6c5001951408c716ce4e6414cc45f420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weyl quasi-random sequence (computed with recurrence relation)  <a href="namespacetheoretica.html#a6c5001951408c716ce4e6414cc45f420">More...</a><br /></td></tr>
<tr class="separator:a6c5001951408c716ce4e6414cc45f420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab52264b77696ac2b3b8a78ed540f092d"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ab52264b77696ac2b3b8a78ed540f092d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ab52264b77696ac2b3b8a78ed540f092d">qrand_weyl_multi</a> (unsigned int n, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> alpha)</td></tr>
<tr class="memdesc:ab52264b77696ac2b3b8a78ed540f092d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weyl quasi-random sequence in N dimensions.  <a href="namespacetheoretica.html#ab52264b77696ac2b3b8a78ed540f092d">More...</a><br /></td></tr>
<tr class="separator:ab52264b77696ac2b3b8a78ed540f092d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d4be50bf77c6b368c94bb627305224"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a78450ba4db2e132788cc0566b22848b9">vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ac1d4be50bf77c6b368c94bb627305224">qrand_weyl2</a> (unsigned int n, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> alpha=0.7548776662466927)</td></tr>
<tr class="memdesc:ac1d4be50bf77c6b368c94bb627305224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weyl quasi-random sequence in 2 dimensions.  <a href="namespacetheoretica.html#ac1d4be50bf77c6b368c94bb627305224">More...</a><br /></td></tr>
<tr class="separator:ac1d4be50bf77c6b368c94bb627305224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a35e29644875a5421b3ac4d7203c28a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a6a35e29644875a5421b3ac4d7203c28a">rand_uniform</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g, uint64_t prec=<a class="el" href="namespacetheoretica.html#a0e48eab9ce5928d0c754a40ddb2d068f">RAND_REAL_PREC</a>)</td></tr>
<tr class="memdesc:a6a35e29644875a5421b3ac4d7203c28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a pseudorandom real number in [a, b] using a preexisting generator.  <a href="namespacetheoretica.html#a6a35e29644875a5421b3ac4d7203c28a">More...</a><br /></td></tr>
<tr class="separator:a6a35e29644875a5421b3ac4d7203c28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e77a1836e1b966cdbb0934d5ebbbf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ad7e77a1836e1b966cdbb0934d5ebbbf2">rand_uniform</a> (const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;theta, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:ad7e77a1836e1b966cdbb0934d5ebbbf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for rand_uniform(real, real, PRNG)  <a href="namespacetheoretica.html#ad7e77a1836e1b966cdbb0934d5ebbbf2">More...</a><br /></td></tr>
<tr class="separator:ad7e77a1836e1b966cdbb0934d5ebbbf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaab56ddec7d197600964cb78ada9a86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aeaab56ddec7d197600964cb78ada9a86">rand_dist_tac</a> (<a class="el" href="namespacetheoretica.html#a5955d73b5602813dca8d4d64bed8466d">stat_function</a> f, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;theta, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x1, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> y1, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> y2, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#a3299f783527ae72a24c832a7b1cd8ef8">MAX_TRYANDCATCH_ITER</a>)</td></tr>
<tr class="memdesc:aeaab56ddec7d197600964cb78ada9a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a pseudorandom value following any probability distribution function using the Try-and-Catch (rejection) algorithm.  <a href="namespacetheoretica.html#aeaab56ddec7d197600964cb78ada9a86">More...</a><br /></td></tr>
<tr class="separator:aeaab56ddec7d197600964cb78ada9a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bdf0dc89459fedaf6950c0f9b96df5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ac8bdf0dc89459fedaf6950c0f9b96df5">rand_gaussian_polar</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> <a class="el" href="namespacetheoretica.html#a63412fa6d4323c24f2c571dfc6b14e1d">mean</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> sigma, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:ac8bdf0dc89459fedaf6950c0f9b96df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number following a Gaussian distribution using Marsaglia's polar method.  <a href="namespacetheoretica.html#ac8bdf0dc89459fedaf6950c0f9b96df5">More...</a><br /></td></tr>
<tr class="separator:ac8bdf0dc89459fedaf6950c0f9b96df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d0c9531b268c00e759cb571422e01f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a91d0c9531b268c00e759cb571422e01f">rand_gaussian_boxmuller</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> <a class="el" href="namespacetheoretica.html#a63412fa6d4323c24f2c571dfc6b14e1d">mean</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> sigma, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a91d0c9531b268c00e759cb571422e01f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number following a Gaussian distribution using the Box-Muller method.  <a href="namespacetheoretica.html#a91d0c9531b268c00e759cb571422e01f">More...</a><br /></td></tr>
<tr class="separator:a91d0c9531b268c00e759cb571422e01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c36b22d9b1f9f2beeab1c7be35fe8b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a8c36b22d9b1f9f2beeab1c7be35fe8b3">rand_gaussian_clt</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> <a class="el" href="namespacetheoretica.html#a63412fa6d4323c24f2c571dfc6b14e1d">mean</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> sigma, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a8c36b22d9b1f9f2beeab1c7be35fe8b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number in a range following a Gaussian distribution by exploiting the Central Limit Theorem.  <a href="namespacetheoretica.html#a8c36b22d9b1f9f2beeab1c7be35fe8b3">More...</a><br /></td></tr>
<tr class="separator:a8c36b22d9b1f9f2beeab1c7be35fe8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b8d1fc98c8429d4b342e860cab6ed1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#af2b8d1fc98c8429d4b342e860cab6ed1">rand_gaussian_clt</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> <a class="el" href="namespacetheoretica.html#a63412fa6d4323c24f2c571dfc6b14e1d">mean</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> sigma, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g, unsigned int N)</td></tr>
<tr class="memdesc:af2b8d1fc98c8429d4b342e860cab6ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number in a range following a Gaussian distribution by exploiting the Central Limit Theorem.  <a href="namespacetheoretica.html#af2b8d1fc98c8429d4b342e860cab6ed1">More...</a><br /></td></tr>
<tr class="separator:af2b8d1fc98c8429d4b342e860cab6ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856e584fd661d664a36cb185c8abd6ba"><td class="memItemLeft" align="right" valign="top"><a id="a856e584fd661d664a36cb185c8abd6ba" name="a856e584fd661d664a36cb185c8abd6ba"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rand_gaussian</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> <a class="el" href="namespacetheoretica.html#a63412fa6d4323c24f2c571dfc6b14e1d">mean</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> sigma, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a856e584fd661d664a36cb185c8abd6ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number following a Gaussian distribution using the best available algorithm. <br /></td></tr>
<tr class="separator:a856e584fd661d664a36cb185c8abd6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2c1865b7a5639ed82643a069554e3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aad2c1865b7a5639ed82643a069554e3d">rand_gaussian</a> (const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;theta, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:aad2c1865b7a5639ed82643a069554e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for rand_gaussian(real, real, PRNG)  <a href="namespacetheoretica.html#aad2c1865b7a5639ed82643a069554e3d">More...</a><br /></td></tr>
<tr class="separator:aad2c1865b7a5639ed82643a069554e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fc6d88e78808dfe4a4bbb03798a754"><td class="memItemLeft" align="right" valign="top"><a id="a40fc6d88e78808dfe4a4bbb03798a754" name="a40fc6d88e78808dfe4a4bbb03798a754"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rand_exponential</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> lambda, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a40fc6d88e78808dfe4a4bbb03798a754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number following an exponential distribution using the quantile (inverse) function method. <br /></td></tr>
<tr class="separator:a40fc6d88e78808dfe4a4bbb03798a754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e6165f6c783179d1b3c2e321b3e7d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa2e6165f6c783179d1b3c2e321b3e7d4">rand_exponential</a> (const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;theta, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:aa2e6165f6c783179d1b3c2e321b3e7d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for rand_exponential(real, PRNG)  <a href="namespacetheoretica.html#aa2e6165f6c783179d1b3c2e321b3e7d4">More...</a><br /></td></tr>
<tr class="separator:aa2e6165f6c783179d1b3c2e321b3e7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c93a1f60698d75caa21a305e2ba107"><td class="memItemLeft" align="right" valign="top"><a id="a55c93a1f60698d75caa21a305e2ba107" name="a55c93a1f60698d75caa21a305e2ba107"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rand_rayleigh</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> sigma, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a55c93a1f60698d75caa21a305e2ba107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number following a Rayleigh distribution using the quantile (inverse) function method. <br /></td></tr>
<tr class="separator:a55c93a1f60698d75caa21a305e2ba107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012d14c9ef85d6f3028bf8ceb1008787"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a012d14c9ef85d6f3028bf8ceb1008787">rand_rayleigh</a> (const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;theta, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a012d14c9ef85d6f3028bf8ceb1008787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for rand_rayleigh(real, PRNG)  <a href="namespacetheoretica.html#a012d14c9ef85d6f3028bf8ceb1008787">More...</a><br /></td></tr>
<tr class="separator:a012d14c9ef85d6f3028bf8ceb1008787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34a4b6660c0287dc6dfa979a2f83002"><td class="memItemLeft" align="right" valign="top"><a id="ac34a4b6660c0287dc6dfa979a2f83002" name="ac34a4b6660c0287dc6dfa979a2f83002"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rand_cauchy</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> mu, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> alpha, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:ac34a4b6660c0287dc6dfa979a2f83002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number following a Cauchy distribution using the quantile (inverse) function method. <br /></td></tr>
<tr class="separator:ac34a4b6660c0287dc6dfa979a2f83002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473df88a9edd9ccc8dcf03665591575b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a473df88a9edd9ccc8dcf03665591575b">rand_cauchy</a> (const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;theta, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a473df88a9edd9ccc8dcf03665591575b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for rand_cauchy(real, real, PRNG)  <a href="namespacetheoretica.html#a473df88a9edd9ccc8dcf03665591575b">More...</a><br /></td></tr>
<tr class="separator:a473df88a9edd9ccc8dcf03665591575b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01522152b1ccfd9a7db77654b6d8c12a"><td class="memItemLeft" align="right" valign="top"><a id="a01522152b1ccfd9a7db77654b6d8c12a" name="a01522152b1ccfd9a7db77654b6d8c12a"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rand_laplace</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> mu, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a01522152b1ccfd9a7db77654b6d8c12a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number following a Laplace distribution using the quantile (inverse) function method. <br /></td></tr>
<tr class="separator:a01522152b1ccfd9a7db77654b6d8c12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441cea1ebea409b2deb0ba387febc626"><td class="memItemLeft" align="right" valign="top"><a id="a441cea1ebea409b2deb0ba387febc626" name="a441cea1ebea409b2deb0ba387febc626"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rand_laplace</b> (const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;theta, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a441cea1ebea409b2deb0ba387febc626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number following a Laplace distribution using the quantile (inverse) function method. <br /></td></tr>
<tr class="separator:a441cea1ebea409b2deb0ba387febc626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b34801047d52afccf3b4120c3d2d74e"><td class="memItemLeft" align="right" valign="top"><a id="a2b34801047d52afccf3b4120c3d2d74e" name="a2b34801047d52afccf3b4120c3d2d74e"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rand_pareto</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x_m, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> alpha, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a2b34801047d52afccf3b4120c3d2d74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number following a Pareto distribution using the quantile (inverse) function method. <br /></td></tr>
<tr class="separator:a2b34801047d52afccf3b4120c3d2d74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66a655f57ef0f6e436dfc03e800585b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ae66a655f57ef0f6e436dfc03e800585b">rand_pareto</a> (const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;theta, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:ae66a655f57ef0f6e436dfc03e800585b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for rand_pareto(real, real, PRNG)  <a href="namespacetheoretica.html#ae66a655f57ef0f6e436dfc03e800585b">More...</a><br /></td></tr>
<tr class="separator:ae66a655f57ef0f6e436dfc03e800585b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8a4ddbcba09177b1ba63397ead6119"><td class="memItemLeft" align="right" valign="top"><a id="a8e8a4ddbcba09177b1ba63397ead6119" name="a8e8a4ddbcba09177b1ba63397ead6119"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>likelihood</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;theta, <a class="el" href="namespacetheoretica.html#a5955d73b5602813dca8d4d64bed8466d">stat_function</a> f)</td></tr>
<tr class="memdesc:a8e8a4ddbcba09177b1ba63397ead6119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the likelihood of a distribution &lt;f&gt; with the given parameters &lt;theta&gt; and measures &lt;X&gt; <br /></td></tr>
<tr class="separator:a8e8a4ddbcba09177b1ba63397ead6119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a7d7ea9328cce28ccedceb3cbfe806"><td class="memItemLeft" align="right" valign="top"><a id="ad4a7d7ea9328cce28ccedceb3cbfe806" name="ad4a7d7ea9328cce28ccedceb3cbfe806"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>log_likelihood</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;theta, <a class="el" href="namespacetheoretica.html#a5955d73b5602813dca8d4d64bed8466d">stat_function</a> f)</td></tr>
<tr class="memdesc:ad4a7d7ea9328cce28ccedceb3cbfe806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the log likelihood of a distribution &lt;f&gt; with the given parameters &lt;theta&gt; and measures &lt;X&gt; <br /></td></tr>
<tr class="separator:ad4a7d7ea9328cce28ccedceb3cbfe806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae123cdac0d487fd0cc12a32dc06672d6"><td class="memItemLeft" align="right" valign="top"><a id="ae123cdac0d487fd0cc12a32dc06672d6" name="ae123cdac0d487fd0cc12a32dc06672d6"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>arithmetic_mean</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data)</td></tr>
<tr class="memdesc:ae123cdac0d487fd0cc12a32dc06672d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arithmetic mean of a set of values. <br /></td></tr>
<tr class="separator:ae123cdac0d487fd0cc12a32dc06672d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63412fa6d4323c24f2c571dfc6b14e1d"><td class="memItemLeft" align="right" valign="top"><a id="a63412fa6d4323c24f2c571dfc6b14e1d" name="a63412fa6d4323c24f2c571dfc6b14e1d"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mean</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data)</td></tr>
<tr class="memdesc:a63412fa6d4323c24f2c571dfc6b14e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arithmetic mean of a set of values Alias for arithmetic_mean. <br /></td></tr>
<tr class="separator:a63412fa6d4323c24f2c571dfc6b14e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417963e2cd3792705565275926c54f0c"><td class="memItemLeft" align="right" valign="top"><a id="a417963e2cd3792705565275926c54f0c" name="a417963e2cd3792705565275926c54f0c"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>harmonic_mean</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data)</td></tr>
<tr class="memdesc:a417963e2cd3792705565275926c54f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the harmonic mean of a set of values. <br /></td></tr>
<tr class="separator:a417963e2cd3792705565275926c54f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41411deb0f028d9ff90e06f9dd703b3f"><td class="memItemLeft" align="right" valign="top"><a id="a41411deb0f028d9ff90e06f9dd703b3f" name="a41411deb0f028d9ff90e06f9dd703b3f"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>geometric_mean</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data)</td></tr>
<tr class="memdesc:a41411deb0f028d9ff90e06f9dd703b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the geometric mean of a set of values as \(\sqrt[n]{\Pi_i x_i}\). <br /></td></tr>
<tr class="separator:a41411deb0f028d9ff90e06f9dd703b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301b9526d5e857f82786aa83af8f0d44"><td class="memItemLeft" align="right" valign="top"><a id="a301b9526d5e857f82786aa83af8f0d44" name="a301b9526d5e857f82786aa83af8f0d44"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>weighted_mean</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;weights)</td></tr>
<tr class="memdesc:a301b9526d5e857f82786aa83af8f0d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the weighted mean of a set of values &lt;data&gt; and &lt;weights&gt; must have the same size. <br /></td></tr>
<tr class="separator:a301b9526d5e857f82786aa83af8f0d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5247854c4b50f7ac1d71e7d23a9ef4"><td class="memItemLeft" align="right" valign="top"><a id="a9e5247854c4b50f7ac1d71e7d23a9ef4" name="a9e5247854c4b50f7ac1d71e7d23a9ef4"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>quadratic_mean</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data)</td></tr>
<tr class="memdesc:a9e5247854c4b50f7ac1d71e7d23a9ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the quadratic mean (Root Mean Square) of a set of values m_q = sqrt(x1^2 + x2^2 + ...) <br /></td></tr>
<tr class="separator:a9e5247854c4b50f7ac1d71e7d23a9ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac984b5416b7e1b86cb772f735d4cb42d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ac984b5416b7e1b86cb772f735d4cb42d">rms</a> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data)</td></tr>
<tr class="memdesc:ac984b5416b7e1b86cb772f735d4cb42d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the quadratic mean (Root Mean Square) of a set of values m_q = sqrt(x1^2 + x2^2 + ...)  <a href="namespacetheoretica.html#ac984b5416b7e1b86cb772f735d4cb42d">More...</a><br /></td></tr>
<tr class="separator:ac984b5416b7e1b86cb772f735d4cb42d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1e037e416f8f9c3ee70909e3eca4c5"><td class="memItemLeft" align="right" valign="top"><a id="a4e1e037e416f8f9c3ee70909e3eca4c5" name="a4e1e037e416f8f9c3ee70909e3eca4c5"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>range</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data)</td></tr>
<tr class="memdesc:a4e1e037e416f8f9c3ee70909e3eca4c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the range of a data set defined as x_max - x_min. <br /></td></tr>
<tr class="separator:a4e1e037e416f8f9c3ee70909e3eca4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec64d95066eeb32de65ceda8ce135b84"><td class="memItemLeft" align="right" valign="top"><a id="aec64d95066eeb32de65ceda8ce135b84" name="aec64d95066eeb32de65ceda8ce135b84"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>semidispersion</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data)</td></tr>
<tr class="memdesc:aec64d95066eeb32de65ceda8ce135b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum semidispersion of a data set defined as (x_max - x_min) / 2. <br /></td></tr>
<tr class="separator:aec64d95066eeb32de65ceda8ce135b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c42fd9cadef340b3420309453758078"><td class="memItemLeft" align="right" valign="top"><a id="a5c42fd9cadef340b3420309453758078" name="a5c42fd9cadef340b3420309453758078"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>propagate_sum</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;sigma)</td></tr>
<tr class="memdesc:a5c42fd9cadef340b3420309453758078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate error of a sum of values as sqrt(sigma_x^2 + sigma_y^2 + ...) <br /></td></tr>
<tr class="separator:a5c42fd9cadef340b3420309453758078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8729f104e3aec72c05706a8d56a1de"><td class="memItemLeft" align="right" valign="top"><a id="aad8729f104e3aec72c05706a8d56a1de" name="aad8729f104e3aec72c05706a8d56a1de"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>propagate_product</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;sigma, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;<a class="el" href="namespacetheoretica.html#a63412fa6d4323c24f2c571dfc6b14e1d">mean</a>)</td></tr>
<tr class="memdesc:aad8729f104e3aec72c05706a8d56a1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate error of a product (or quotient) of values as sqrt((sigma_x / x_mean)^2 + (sigma_y / y_mean)^2 + ...) The result is the propagated relative error. <br /></td></tr>
<tr class="separator:aad8729f104e3aec72c05706a8d56a1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0857f4b940f5790cd733317780b8ad3"><td class="memItemLeft" align="right" valign="top"><a id="ad0857f4b940f5790cd733317780b8ad3" name="ad0857f4b940f5790cd733317780b8ad3"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>total_sum_squares</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X)</td></tr>
<tr class="memdesc:ad0857f4b940f5790cd733317780b8ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total sum of squares (TSS) Computed as sum(square(x_i - x_mean)) <br /></td></tr>
<tr class="separator:ad0857f4b940f5790cd733317780b8ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3acaf39bd4f7e9c87e1fb72768de32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a2a3acaf39bd4f7e9c87e1fb72768de32">tss</a> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X)</td></tr>
<tr class="memdesc:a2a3acaf39bd4f7e9c87e1fb72768de32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total sum of squares (TSS) Computed as sum(square(x_i - x_mean))  <a href="namespacetheoretica.html#a2a3acaf39bd4f7e9c87e1fb72768de32">More...</a><br /></td></tr>
<tr class="separator:a2a3acaf39bd4f7e9c87e1fb72768de32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c4321efb6e8ba42e62eef768e30924"><td class="memItemLeft" align="right" valign="top"><a id="a17c4321efb6e8ba42e62eef768e30924" name="a17c4321efb6e8ba42e62eef768e30924"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>variance</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data)</td></tr>
<tr class="memdesc:a17c4321efb6e8ba42e62eef768e30924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the variance of a population. <br /></td></tr>
<tr class="separator:a17c4321efb6e8ba42e62eef768e30924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638369113c0be46702092755e3b3d485"><td class="memItemLeft" align="right" valign="top"><a id="a638369113c0be46702092755e3b3d485" name="a638369113c0be46702092755e3b3d485"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sample_variance</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data)</td></tr>
<tr class="memdesc:a638369113c0be46702092755e3b3d485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the variance of a sample This function uses Bessel correction. <br /></td></tr>
<tr class="separator:a638369113c0be46702092755e3b3d485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b89c11ebe910e4da6eff8e23100fb3"><td class="memItemLeft" align="right" valign="top"><a id="af9b89c11ebe910e4da6eff8e23100fb3" name="af9b89c11ebe910e4da6eff8e23100fb3"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>standard_deviation</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data)</td></tr>
<tr class="memdesc:af9b89c11ebe910e4da6eff8e23100fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the standard deviation of a population. <br /></td></tr>
<tr class="separator:af9b89c11ebe910e4da6eff8e23100fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69e38f6bd2b461c238693537f5faa24"><td class="memItemLeft" align="right" valign="top"><a id="af69e38f6bd2b461c238693537f5faa24" name="af69e38f6bd2b461c238693537f5faa24"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>stdev</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data)</td></tr>
<tr class="memdesc:af69e38f6bd2b461c238693537f5faa24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the standard deviation of a population. <br /></td></tr>
<tr class="separator:af69e38f6bd2b461c238693537f5faa24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7748584aef1c94107441ca9e921daefb"><td class="memItemLeft" align="right" valign="top"><a id="a7748584aef1c94107441ca9e921daefb" name="a7748584aef1c94107441ca9e921daefb"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sample_standard_deviation</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data)</td></tr>
<tr class="memdesc:a7748584aef1c94107441ca9e921daefb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the standard deviation of a sample. <br /></td></tr>
<tr class="separator:a7748584aef1c94107441ca9e921daefb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c956ff97660f395a7b603673eb648e4"><td class="memItemLeft" align="right" valign="top"><a id="a7c956ff97660f395a7b603673eb648e4" name="a7c956ff97660f395a7b603673eb648e4"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>smpl_stdev</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data)</td></tr>
<tr class="memdesc:a7c956ff97660f395a7b603673eb648e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the standard deviation of a sample. <br /></td></tr>
<tr class="separator:a7c956ff97660f395a7b603673eb648e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83ed7e95c4ab0b5910c30384f48b554"><td class="memItemLeft" align="right" valign="top"><a id="ad83ed7e95c4ab0b5910c30384f48b554" name="ad83ed7e95c4ab0b5910c30384f48b554"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>standard_relative_error</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X)</td></tr>
<tr class="memdesc:ad83ed7e95c4ab0b5910c30384f48b554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the relative error on a population measure using standard deviation. <br /></td></tr>
<tr class="separator:ad83ed7e95c4ab0b5910c30384f48b554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b77710d75bde23b067dfe85aa460561"><td class="memItemLeft" align="right" valign="top"><a id="a9b77710d75bde23b067dfe85aa460561" name="a9b77710d75bde23b067dfe85aa460561"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sample_standard_relative_error</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X)</td></tr>
<tr class="memdesc:a9b77710d75bde23b067dfe85aa460561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the relative error on a sample measure using standard deviation. <br /></td></tr>
<tr class="separator:a9b77710d75bde23b067dfe85aa460561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac12b99fe1e96268796f1d2100f7649"><td class="memItemLeft" align="right" valign="top"><a id="a3ac12b99fe1e96268796f1d2100f7649" name="a3ac12b99fe1e96268796f1d2100f7649"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mean_standard_deviation</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data)</td></tr>
<tr class="memdesc:a3ac12b99fe1e96268796f1d2100f7649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the standard deviation on the mean of a set of values. <br /></td></tr>
<tr class="separator:a3ac12b99fe1e96268796f1d2100f7649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea2bd4390f09c4a28c18f12c67383c3"><td class="memItemLeft" align="right" valign="top"><a id="a1ea2bd4390f09c4a28c18f12c67383c3" name="a1ea2bd4390f09c4a28c18f12c67383c3"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>stdom</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data)</td></tr>
<tr class="memdesc:a1ea2bd4390f09c4a28c18f12c67383c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the standard deviation on the mean of a set of values. <br /></td></tr>
<tr class="separator:a1ea2bd4390f09c4a28c18f12c67383c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5783be076823764d2c2dbb91b365a4b"><td class="memItemLeft" align="right" valign="top"><a id="ab5783be076823764d2c2dbb91b365a4b" name="ab5783be076823764d2c2dbb91b365a4b"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sample_mean_standard_deviation</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data)</td></tr>
<tr class="memdesc:ab5783be076823764d2c2dbb91b365a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the standard deviation on the mean of a set of measures Bessel correction is used in the calculation of the variance. <br /></td></tr>
<tr class="separator:ab5783be076823764d2c2dbb91b365a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533d837210e486032eaffee74aabc909"><td class="memItemLeft" align="right" valign="top"><a id="a533d837210e486032eaffee74aabc909" name="a533d837210e486032eaffee74aabc909"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>smpl_stdom</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data)</td></tr>
<tr class="memdesc:a533d837210e486032eaffee74aabc909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the standard deviation on the mean of a set of measures Bessel correction is used in the calculation of the variance. <br /></td></tr>
<tr class="separator:a533d837210e486032eaffee74aabc909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866cc382ff78470c179bebec73ffd7a9"><td class="memItemLeft" align="right" valign="top"><a id="a866cc382ff78470c179bebec73ffd7a9" name="a866cc382ff78470c179bebec73ffd7a9"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>covariance</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y)</td></tr>
<tr class="memdesc:a866cc382ff78470c179bebec73ffd7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the covariance of two sets of measures. <br /></td></tr>
<tr class="separator:a866cc382ff78470c179bebec73ffd7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd67e52123a8b943d41216102e3248c"><td class="memItemLeft" align="right" valign="top"><a id="a9fd67e52123a8b943d41216102e3248c" name="a9fd67e52123a8b943d41216102e3248c"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sample_covariance</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y)</td></tr>
<tr class="memdesc:a9fd67e52123a8b943d41216102e3248c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the covariance between two sets of sample measures This function uses Bessel correction. <br /></td></tr>
<tr class="separator:a9fd67e52123a8b943d41216102e3248c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443605539362b54c90d073de610a5ee8"><td class="memItemLeft" align="right" valign="top"><a id="a443605539362b54c90d073de610a5ee8" name="a443605539362b54c90d073de610a5ee8"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>correlation_coefficient</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y)</td></tr>
<tr class="memdesc:a443605539362b54c90d073de610a5ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pearson's correlation coefficient R for a population. <br /></td></tr>
<tr class="separator:a443605539362b54c90d073de610a5ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d59f457c7baf9e58eb44e990d79c149"><td class="memItemLeft" align="right" valign="top"><a id="a6d59f457c7baf9e58eb44e990d79c149" name="a6d59f457c7baf9e58eb44e990d79c149"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sample_correlation_coefficient</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y)</td></tr>
<tr class="memdesc:a6d59f457c7baf9e58eb44e990d79c149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pearson's correlation coefficient r for a sample. <br /></td></tr>
<tr class="separator:a6d59f457c7baf9e58eb44e990d79c149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9086f2656a6856685b31c6c54a7095"><td class="memItemLeft" align="right" valign="top"><a id="aec9086f2656a6856685b31c6c54a7095" name="aec9086f2656a6856685b31c6c54a7095"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>autocorrelation</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X)</td></tr>
<tr class="memdesc:aec9086f2656a6856685b31c6c54a7095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lag-1 autocorrelation of a dataset. <br /></td></tr>
<tr class="separator:aec9086f2656a6856685b31c6c54a7095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d63025aa79b7ae116ef3f784f3605e"><td class="memItemLeft" align="right" valign="top"><a id="ab5d63025aa79b7ae116ef3f784f3605e" name="ab5d63025aa79b7ae116ef3f784f3605e"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>absolute_deviation</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X)</td></tr>
<tr class="memdesc:ab5d63025aa79b7ae116ef3f784f3605e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute deviation from the mean. <br /></td></tr>
<tr class="separator:ab5d63025aa79b7ae116ef3f784f3605e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5de8338299e4c2fd63178fa3125eb8"><td class="memItemLeft" align="right" valign="top"><a id="a8d5de8338299e4c2fd63178fa3125eb8" name="a8d5de8338299e4c2fd63178fa3125eb8"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>absdev</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X)</td></tr>
<tr class="memdesc:a8d5de8338299e4c2fd63178fa3125eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute deviation from the mean. <br /></td></tr>
<tr class="separator:a8d5de8338299e4c2fd63178fa3125eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2afc6c53096ccbd9f04e58824d83b7d"><td class="memItemLeft" align="right" valign="top"><a id="ac2afc6c53096ccbd9f04e58824d83b7d" name="ac2afc6c53096ccbd9f04e58824d83b7d"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>skewness</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X)</td></tr>
<tr class="memdesc:ac2afc6c53096ccbd9f04e58824d83b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skewness of a dataset. <br /></td></tr>
<tr class="separator:ac2afc6c53096ccbd9f04e58824d83b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e8a178bb127d3a97a237d58dbd153f"><td class="memItemLeft" align="right" valign="top"><a id="a39e8a178bb127d3a97a237d58dbd153f" name="a39e8a178bb127d3a97a237d58dbd153f"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>kurtosis</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X)</td></tr>
<tr class="memdesc:a39e8a178bb127d3a97a237d58dbd153f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalized Kurtosis of a dataset. <br /></td></tr>
<tr class="separator:a39e8a178bb127d3a97a237d58dbd153f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaeefec30503e31f02b0903ff766d757"><td class="memItemLeft" align="right" valign="top"><a id="aaaeefec30503e31f02b0903ff766d757" name="aaaeefec30503e31f02b0903ff766d757"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>chi_square_sigma</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X)</td></tr>
<tr class="memdesc:aaaeefec30503e31f02b0903ff766d757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normal distribution chi-square with 4 intervals calculated on a sample of measures. <br /></td></tr>
<tr class="separator:aaaeefec30503e31f02b0903ff766d757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84617261decc110caf3052d68f06d7d4"><td class="memItemLeft" align="right" valign="top"><a id="a84617261decc110caf3052d68f06d7d4" name="a84617261decc110caf3052d68f06d7d4"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>least_squares_linear_intercept</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y)</td></tr>
<tr class="memdesc:a84617261decc110caf3052d68f06d7d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the intercept of the minimum squares linearization of X and Y. <br /></td></tr>
<tr class="separator:a84617261decc110caf3052d68f06d7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6955f75727be37a27e0927224e5876"><td class="memItemLeft" align="right" valign="top"><a id="a0f6955f75727be37a27e0927224e5876" name="a0f6955f75727be37a27e0927224e5876"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lst_sqrs_lin_intercept</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y)</td></tr>
<tr class="memdesc:a0f6955f75727be37a27e0927224e5876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the intercept of the minimum squares linearization of X and Y. <br /></td></tr>
<tr class="separator:a0f6955f75727be37a27e0927224e5876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada975e288bf5570bca3945af38a51220"><td class="memItemLeft" align="right" valign="top"><a id="ada975e288bf5570bca3945af38a51220" name="ada975e288bf5570bca3945af38a51220"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>least_squares_linear_sigma_A</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> sigma_y)</td></tr>
<tr class="memdesc:ada975e288bf5570bca3945af38a51220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the error on the intercept (A) <br /></td></tr>
<tr class="separator:ada975e288bf5570bca3945af38a51220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6bb7752cf25bc4154c3487384eb0841"><td class="memItemLeft" align="right" valign="top"><a id="ab6bb7752cf25bc4154c3487384eb0841" name="ab6bb7752cf25bc4154c3487384eb0841"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>least_squares_linear_slope</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y)</td></tr>
<tr class="memdesc:ab6bb7752cf25bc4154c3487384eb0841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the slope of the minimum squares linearization of X and Y. <br /></td></tr>
<tr class="separator:ab6bb7752cf25bc4154c3487384eb0841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8eefa3fdd67863bd14365f6332935ed"><td class="memItemLeft" align="right" valign="top"><a id="ac8eefa3fdd67863bd14365f6332935ed" name="ac8eefa3fdd67863bd14365f6332935ed"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lst_sqrs_lin_slope</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y)</td></tr>
<tr class="memdesc:ac8eefa3fdd67863bd14365f6332935ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the slope of the minimum squares linearization of X and Y. <br /></td></tr>
<tr class="separator:ac8eefa3fdd67863bd14365f6332935ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa5671fbee3d70db0b7b71f7afe7d78"><td class="memItemLeft" align="right" valign="top"><a id="acfa5671fbee3d70db0b7b71f7afe7d78" name="acfa5671fbee3d70db0b7b71f7afe7d78"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>least_squares_linear_sigma_B</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> sigma_y)</td></tr>
<tr class="memdesc:acfa5671fbee3d70db0b7b71f7afe7d78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the error on the slope coefficient (B) <br /></td></tr>
<tr class="separator:acfa5671fbee3d70db0b7b71f7afe7d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c799e8666d59de6de60326dcc09294e"><td class="memItemLeft" align="right" valign="top"><a id="a3c799e8666d59de6de60326dcc09294e" name="a3c799e8666d59de6de60326dcc09294e"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>least_squares_linear_error</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> intercept, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> slope)</td></tr>
<tr class="memdesc:a3c799e8666d59de6de60326dcc09294e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the error of the minimum squares linearization of a sample. <br /></td></tr>
<tr class="separator:a3c799e8666d59de6de60326dcc09294e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543e7d1f53e6e88371ae148abcd3bbc3"><td class="memItemLeft" align="right" valign="top"><a id="a543e7d1f53e6e88371ae148abcd3bbc3" name="a543e7d1f53e6e88371ae148abcd3bbc3"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lst_sqrs_lin_error</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> intercept, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> slope)</td></tr>
<tr class="memdesc:a543e7d1f53e6e88371ae148abcd3bbc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the error of the minimum squares linearization of a sample. <br /></td></tr>
<tr class="separator:a543e7d1f53e6e88371ae148abcd3bbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad04a75aef8d4652b07e330779fb3ea3"><td class="memItemLeft" align="right" valign="top"><a id="aad04a75aef8d4652b07e330779fb3ea3" name="aad04a75aef8d4652b07e330779fb3ea3"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>chi_square_linearization</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;sigma, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> intercept, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> slope)</td></tr>
<tr class="memdesc:aad04a75aef8d4652b07e330779fb3ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the chi-square on a linearization. <br /></td></tr>
<tr class="separator:aad04a75aef8d4652b07e330779fb3ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba036e24bb6cda4b1f7dc901387f88ad"><td class="memItemLeft" align="right" valign="top"><a id="aba036e24bb6cda4b1f7dc901387f88ad" name="aba036e24bb6cda4b1f7dc901387f88ad"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>reduced_chi_square_linearization</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;sigma, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> intercept, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> slope)</td></tr>
<tr class="memdesc:aba036e24bb6cda4b1f7dc901387f88ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the reduced chi-squared on a linearization. <br /></td></tr>
<tr class="separator:aba036e24bb6cda4b1f7dc901387f88ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b76d028b67c36167f9b7b2b9ecc368"><td class="memItemLeft" align="right" valign="top"><a id="a38b76d028b67c36167f9b7b2b9ecc368" name="a38b76d028b67c36167f9b7b2b9ecc368"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>least_squares_weighted_linear_intercept</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;W)</td></tr>
<tr class="memdesc:a38b76d028b67c36167f9b7b2b9ecc368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the intercept of the weighted minimum squares linearization of X and Y. <br /></td></tr>
<tr class="separator:a38b76d028b67c36167f9b7b2b9ecc368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7787cd3050ea6b521f585061c8d8e024"><td class="memItemLeft" align="right" valign="top"><a id="a7787cd3050ea6b521f585061c8d8e024" name="a7787cd3050ea6b521f585061c8d8e024"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lst_sqrs_weight_lin_intercept</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;W)</td></tr>
<tr class="memdesc:a7787cd3050ea6b521f585061c8d8e024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the intercept of the weighted minimum squares linearization of X and Y. <br /></td></tr>
<tr class="separator:a7787cd3050ea6b521f585061c8d8e024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac738af92a679b937956c3aaba943363b"><td class="memItemLeft" align="right" valign="top"><a id="ac738af92a679b937956c3aaba943363b" name="ac738af92a679b937956c3aaba943363b"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>least_squares_weighted_linear_slope</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;W)</td></tr>
<tr class="memdesc:ac738af92a679b937956c3aaba943363b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the slope of the weighted minimum squares linearization of X and Y. <br /></td></tr>
<tr class="separator:ac738af92a679b937956c3aaba943363b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad340e45331b7332ee2fb72e6978d82a0"><td class="memItemLeft" align="right" valign="top"><a id="ad340e45331b7332ee2fb72e6978d82a0" name="ad340e45331b7332ee2fb72e6978d82a0"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lst_sqrs_weight_lin_slope</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;W)</td></tr>
<tr class="memdesc:ad340e45331b7332ee2fb72e6978d82a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the slope of the weighted minimum squares linearization of X and Y. <br /></td></tr>
<tr class="separator:ad340e45331b7332ee2fb72e6978d82a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962794bf044750e6e12f9f6f4a468573"><td class="memItemLeft" align="right" valign="top"><a id="a962794bf044750e6e12f9f6f4a468573" name="a962794bf044750e6e12f9f6f4a468573"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>insert_data</b> (<a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data, std::string terminator=&quot;&quot;)</td></tr>
<tr class="memdesc:a962794bf044750e6e12f9f6f4a468573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a <code>vec_buff</code> data set from standard input. <br /></td></tr>
<tr class="separator:a962794bf044750e6e12f9f6f4a468573"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa34d8798921a9b3b78e885a455ff4211"><td class="memItemLeft" align="right" valign="top"><a id="aa34d8798921a9b3b78e885a455ff4211" name="aa34d8798921a9b3b78e885a455ff4211"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MACH_EPSILON</b> = std::numeric_limits&lt;<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&gt;::epsilon()</td></tr>
<tr class="memdesc:aa34d8798921a9b3b78e885a455ff4211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Machine epsilon for the real type. <br /></td></tr>
<tr class="separator:aa34d8798921a9b3b78e885a455ff4211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8245ba56baa7620ff9d0d9ccfbc53f"><td class="memItemLeft" align="right" valign="top"><a id="ace8245ba56baa7620ff9d0d9ccfbc53f" name="ace8245ba56baa7620ff9d0d9ccfbc53f"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PHI</b> = 1.6180339887498948482045868</td></tr>
<tr class="memdesc:ace8245ba56baa7620ff9d0d9ccfbc53f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Phi (Golden Section) mathematical constant. <br /></td></tr>
<tr class="separator:ace8245ba56baa7620ff9d0d9ccfbc53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6de16e5ee81d340ff91dbadb99edde"><td class="memItemLeft" align="right" valign="top"><a id="a6a6de16e5ee81d340ff91dbadb99edde" name="a6a6de16e5ee81d340ff91dbadb99edde"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>INVPHI</b> = 0.6180339887498948482045868</td></tr>
<tr class="memdesc:a6a6de16e5ee81d340ff91dbadb99edde"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse of the Golden Section mathematical constant. <br /></td></tr>
<tr class="separator:a6a6de16e5ee81d340ff91dbadb99edde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93349020a59cf77efcca5bb77c0e7f9"><td class="memItemLeft" align="right" valign="top"><a id="ae93349020a59cf77efcca5bb77c0e7f9" name="ae93349020a59cf77efcca5bb77c0e7f9"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PI</b> = 3.141592653589793238462643</td></tr>
<tr class="memdesc:ae93349020a59cf77efcca5bb77c0e7f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Pi mathematical constant. <br /></td></tr>
<tr class="separator:ae93349020a59cf77efcca5bb77c0e7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b5dac597409564afdc448fbef23eae"><td class="memItemLeft" align="right" valign="top"><a id="a27b5dac597409564afdc448fbef23eae" name="a27b5dac597409564afdc448fbef23eae"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PI2</b> = <a class="el" href="namespacetheoretica.html#ae93349020a59cf77efcca5bb77c0e7f9">PI</a> / 2.0</td></tr>
<tr class="memdesc:a27b5dac597409564afdc448fbef23eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Half of Pi. <br /></td></tr>
<tr class="separator:a27b5dac597409564afdc448fbef23eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f9025deb90bc4fd64fb9260340e3f2"><td class="memItemLeft" align="right" valign="top"><a id="ac7f9025deb90bc4fd64fb9260340e3f2" name="ac7f9025deb90bc4fd64fb9260340e3f2"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PI4</b> = <a class="el" href="namespacetheoretica.html#ae93349020a59cf77efcca5bb77c0e7f9">PI</a> / 4.0</td></tr>
<tr class="memdesc:ac7f9025deb90bc4fd64fb9260340e3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A quarter of Pi. <br /></td></tr>
<tr class="separator:ac7f9025deb90bc4fd64fb9260340e3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974f2fd34520034645cb5c96487c6ed4"><td class="memItemLeft" align="right" valign="top"><a id="a974f2fd34520034645cb5c96487c6ed4" name="a974f2fd34520034645cb5c96487c6ed4"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PIDOUBLE</b> = <a class="el" href="namespacetheoretica.html#ae93349020a59cf77efcca5bb77c0e7f9">PI</a> * 2</td></tr>
<tr class="memdesc:a974f2fd34520034645cb5c96487c6ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pi multiplied by 2. <br /></td></tr>
<tr class="separator:a974f2fd34520034645cb5c96487c6ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6a742ab030fe585063215a644f60df"><td class="memItemLeft" align="right" valign="top"><a id="aeb6a742ab030fe585063215a644f60df" name="aeb6a742ab030fe585063215a644f60df"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>TAU</b> = <a class="el" href="namespacetheoretica.html#ae93349020a59cf77efcca5bb77c0e7f9">PI</a> * 2</td></tr>
<tr class="memdesc:aeb6a742ab030fe585063215a644f60df"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Tau mathematical constant (Pi times 2) <br /></td></tr>
<tr class="separator:aeb6a742ab030fe585063215a644f60df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6916417c8d2b817cfc48b8e2a1abb5"><td class="memItemLeft" align="right" valign="top"><a id="a4d6916417c8d2b817cfc48b8e2a1abb5" name="a4d6916417c8d2b817cfc48b8e2a1abb5"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>INVPI</b> = 1.0 / <a class="el" href="namespacetheoretica.html#ae93349020a59cf77efcca5bb77c0e7f9">PI</a></td></tr>
<tr class="memdesc:a4d6916417c8d2b817cfc48b8e2a1abb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse of Pi. <br /></td></tr>
<tr class="separator:a4d6916417c8d2b817cfc48b8e2a1abb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37fb7f2271fa0e9cd55b47cf4641ca45"><td class="memItemLeft" align="right" valign="top"><a id="a37fb7f2271fa0e9cd55b47cf4641ca45" name="a37fb7f2271fa0e9cd55b47cf4641ca45"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SQRTPI</b> = 1.772454</td></tr>
<tr class="memdesc:a37fb7f2271fa0e9cd55b47cf4641ca45"><td class="mdescLeft">&#160;</td><td class="mdescRight">The square root of Pi. <br /></td></tr>
<tr class="separator:a37fb7f2271fa0e9cd55b47cf4641ca45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c0a5082e6b4428b15b7b02d16eafc7"><td class="memItemLeft" align="right" valign="top"><a id="aa3c0a5082e6b4428b15b7b02d16eafc7" name="aa3c0a5082e6b4428b15b7b02d16eafc7"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>E</b> = 2.718281828459045235360287</td></tr>
<tr class="memdesc:aa3c0a5082e6b4428b15b7b02d16eafc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Euler mathematical constant (e) <br /></td></tr>
<tr class="separator:aa3c0a5082e6b4428b15b7b02d16eafc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771e19568e0562e2fcccd740ec90dae4"><td class="memItemLeft" align="right" valign="top"><a id="a771e19568e0562e2fcccd740ec90dae4" name="a771e19568e0562e2fcccd740ec90dae4"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LOG2E</b> = 1.44269504088896338700465094</td></tr>
<tr class="memdesc:a771e19568e0562e2fcccd740ec90dae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The binary logarithm of e. <br /></td></tr>
<tr class="separator:a771e19568e0562e2fcccd740ec90dae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4145093692043269fa4c1ebef8b4890f"><td class="memItemLeft" align="right" valign="top"><a id="a4145093692043269fa4c1ebef8b4890f" name="a4145093692043269fa4c1ebef8b4890f"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LOG210</b> = 3.32192809488736218170856773213</td></tr>
<tr class="memdesc:a4145093692043269fa4c1ebef8b4890f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The binary logarithm of 10. <br /></td></tr>
<tr class="separator:a4145093692043269fa4c1ebef8b4890f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612238583a4ec50cebd32b4694d5cb9a"><td class="memItemLeft" align="right" valign="top"><a id="a612238583a4ec50cebd32b4694d5cb9a" name="a612238583a4ec50cebd32b4694d5cb9a"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LOG10E</b> = 0.434294481903</td></tr>
<tr class="memdesc:a612238583a4ec50cebd32b4694d5cb9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base-10 logarithm of e. <br /></td></tr>
<tr class="separator:a612238583a4ec50cebd32b4694d5cb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7021b7b588c9ea63d46679aaa1f7c6c4"><td class="memItemLeft" align="right" valign="top"><a id="a7021b7b588c9ea63d46679aaa1f7c6c4" name="a7021b7b588c9ea63d46679aaa1f7c6c4"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LN2</b> = 0.69314718056</td></tr>
<tr class="memdesc:a7021b7b588c9ea63d46679aaa1f7c6c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of 2. <br /></td></tr>
<tr class="separator:a7021b7b588c9ea63d46679aaa1f7c6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc384f25a1d4c7c19169a5ce6c51710"><td class="memItemLeft" align="right" valign="top"><a id="a3bc384f25a1d4c7c19169a5ce6c51710" name="a3bc384f25a1d4c7c19169a5ce6c51710"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LN10</b> = 2.30258509299</td></tr>
<tr class="memdesc:a3bc384f25a1d4c7c19169a5ce6c51710"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of 10. <br /></td></tr>
<tr class="separator:a3bc384f25a1d4c7c19169a5ce6c51710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0afb9f871b425c7454c388eb41a3c19"><td class="memItemLeft" align="right" valign="top"><a id="ae0afb9f871b425c7454c388eb41a3c19" name="ae0afb9f871b425c7454c388eb41a3c19"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DEG2RAD</b> = 0.017453292519943295474371680598</td></tr>
<tr class="memdesc:ae0afb9f871b425c7454c388eb41a3c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">The scalar conversion factor from degrees to radians. <br /></td></tr>
<tr class="separator:ae0afb9f871b425c7454c388eb41a3c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75cd5d78670f968bac3fbcfee6660b0"><td class="memItemLeft" align="right" valign="top"><a id="ae75cd5d78670f968bac3fbcfee6660b0" name="ae75cd5d78670f968bac3fbcfee6660b0"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RAD2DEG</b> = 57.2957795130823228646477218717</td></tr>
<tr class="memdesc:ae75cd5d78670f968bac3fbcfee6660b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The scalar conversion factor from radians to degrees. <br /></td></tr>
<tr class="separator:ae75cd5d78670f968bac3fbcfee6660b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3be7f003670e91509c8f2fac523fab8"><td class="memItemLeft" align="right" valign="top"><a id="ae3be7f003670e91509c8f2fac523fab8" name="ae3be7f003670e91509c8f2fac523fab8"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SQRT2</b> = 1.414213562373095</td></tr>
<tr class="memdesc:ae3be7f003670e91509c8f2fac523fab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The square root of 2. <br /></td></tr>
<tr class="separator:ae3be7f003670e91509c8f2fac523fab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c1ffb22a0191558cafdaec71c3b81d"><td class="memItemLeft" align="right" valign="top"><a id="a42c1ffb22a0191558cafdaec71c3b81d" name="a42c1ffb22a0191558cafdaec71c3b81d"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>INVSQR2</b> = 0.7071067811865475</td></tr>
<tr class="memdesc:a42c1ffb22a0191558cafdaec71c3b81d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse of the square root of 2. <br /></td></tr>
<tr class="separator:a42c1ffb22a0191558cafdaec71c3b81d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3b1fe5337a2dcbdbbeb278cfd7c71d"><td class="memItemLeft" align="right" valign="top"><a id="adb3b1fe5337a2dcbdbbeb278cfd7c71d" name="adb3b1fe5337a2dcbdbbeb278cfd7c71d"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SQRT3</b> = 1.732050807568877</td></tr>
<tr class="memdesc:adb3b1fe5337a2dcbdbbeb278cfd7c71d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The square root of 3. <br /></td></tr>
<tr class="separator:adb3b1fe5337a2dcbdbbeb278cfd7c71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b4341ceb440f57a5cae39fa7b5495c"><td class="memItemLeft" align="right" valign="top"><a id="ad6b4341ceb440f57a5cae39fa7b5495c" name="ad6b4341ceb440f57a5cae39fa7b5495c"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>TAYLOR_ORDER</b> = <a class="el" href="constants_8h.html#ad693d152d21cfd12f2d4c8bc8b1122e6">THEORETICA_TAYLOR_ORDER</a></td></tr>
<tr class="memdesc:ad6b4341ceb440f57a5cae39fa7b5495c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Order of Taylor series approximations. <br /></td></tr>
<tr class="separator:ad6b4341ceb440f57a5cae39fa7b5495c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f0e3448f94ada54d171499c0c95ae4"><td class="memItemLeft" align="right" valign="top"><a id="aa1f0e3448f94ada54d171499c0c95ae4" name="aa1f0e3448f94ada54d171499c0c95ae4"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>INTEGRATION_STEPS</b> = <a class="el" href="constants_8h.html#a95c498965a897914547a05283f79c804">THEORETICA_INTEGRATION_STEPS</a></td></tr>
<tr class="memdesc:aa1f0e3448f94ada54d171499c0c95ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default number of steps for integral approximation. <br /></td></tr>
<tr class="separator:aa1f0e3448f94ada54d171499c0c95ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbb4c38fc6708107926a7f3486036bc"><td class="memItemLeft" align="right" valign="top"><a id="a9dbb4c38fc6708107926a7f3486036bc" name="a9dbb4c38fc6708107926a7f3486036bc"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DERIV_PREC</b> = <a class="el" href="constants_8h.html#a6ff116b859afb29842f6366839e88cfd">THEORETICA_DERIV_PREC</a></td></tr>
<tr class="memdesc:a9dbb4c38fc6708107926a7f3486036bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relative precision for derivative approximation. <br /></td></tr>
<tr class="separator:a9dbb4c38fc6708107926a7f3486036bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c4976fd2f3c3dfdf02bffe927c4dd2"><td class="memItemLeft" align="right" valign="top"><a id="af0c4976fd2f3c3dfdf02bffe927c4dd2" name="af0c4976fd2f3c3dfdf02bffe927c4dd2"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>POWF_POWER_TOLERANCE</b> = <a class="el" href="constants_8h.html#a694c73eb196485f1bec84c5075600f89">THEORETICA_POWF_APPROX_TOL</a></td></tr>
<tr class="memdesc:af0c4976fd2f3c3dfdf02bffe927c4dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Biggest fractional part to ignore in powf computation. <br /></td></tr>
<tr class="separator:af0c4976fd2f3c3dfdf02bffe927c4dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4aa38ca4a41e22c4eeac0970da9b195"><td class="memItemLeft" align="right" valign="top"><a id="aa4aa38ca4a41e22c4eeac0970da9b195" name="aa4aa38ca4a41e22c4eeac0970da9b195"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ROOT_APPROX_TOL</b> = <a class="el" href="constants_8h.html#a021c58c225740fa33459a6378975e759">THEORETICA_ROOT_APPROX_TOL</a></td></tr>
<tr class="memdesc:aa4aa38ca4a41e22c4eeac0970da9b195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximation tolerance for root finding. <br /></td></tr>
<tr class="separator:aa4aa38ca4a41e22c4eeac0970da9b195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28fc38a93f999c3c98056f3dac665f42"><td class="memItemLeft" align="right" valign="top"><a id="a28fc38a93f999c3c98056f3dac665f42" name="a28fc38a93f999c3c98056f3dac665f42"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BISECTION_APPROX_TOL</b> = <a class="el" href="constants_8h.html#ae07bf3e063a76a489cc291c1684d2dda">THEORETICA_BISECTION_APPROX_TOL</a></td></tr>
<tr class="memdesc:a28fc38a93f999c3c98056f3dac665f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximation tolerance for the bisection algorithm. <br /></td></tr>
<tr class="separator:a28fc38a93f999c3c98056f3dac665f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a871a5ce0e15ea45205f3e15eec423"><td class="memItemLeft" align="right" valign="top"><a id="ae3a871a5ce0e15ea45205f3e15eec423" name="ae3a871a5ce0e15ea45205f3e15eec423"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NEWTON_RAPHSON_TOL</b> = <a class="el" href="constants_8h.html#a961e7eb071044645d790bcf11974fa67">THEORETICA_NEWTON_RAPHSON_TOL</a></td></tr>
<tr class="memdesc:ae3a871a5ce0e15ea45205f3e15eec423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximation tolerance for the Newton-Raphson algorithm. <br /></td></tr>
<tr class="separator:ae3a871a5ce0e15ea45205f3e15eec423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0df4d0b21cc7dbcfaf869e88da40af"><td class="memItemLeft" align="right" valign="top"><a id="acf0df4d0b21cc7dbcfaf869e88da40af" name="acf0df4d0b21cc7dbcfaf869e88da40af"></a>
constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_BISECTION_ITER</b> = <a class="el" href="constants_8h.html#a81ceb9b6876df9fab0812a43d92a3c22">THEORETICA_MAX_BISECTION_ITER</a></td></tr>
<tr class="memdesc:acf0df4d0b21cc7dbcfaf869e88da40af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations for the bisection algorithm. <br /></td></tr>
<tr class="separator:acf0df4d0b21cc7dbcfaf869e88da40af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71451b0e74e1fe8a28d1c41bc954804"><td class="memItemLeft" align="right" valign="top"><a id="ac71451b0e74e1fe8a28d1c41bc954804" name="ac71451b0e74e1fe8a28d1c41bc954804"></a>
constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_GOLDENSECTION_ITER</b> = <a class="el" href="constants_8h.html#afeac310b6adedfb265330e760a147a80">THEORETICA_MAX_GOLDENSECTION_ITER</a></td></tr>
<tr class="memdesc:ac71451b0e74e1fe8a28d1c41bc954804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations for the golden section search algorithm. <br /></td></tr>
<tr class="separator:ac71451b0e74e1fe8a28d1c41bc954804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b14b1cb08bd3c634410570abf8258e"><td class="memItemLeft" align="right" valign="top"><a id="a10b14b1cb08bd3c634410570abf8258e" name="a10b14b1cb08bd3c634410570abf8258e"></a>
constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_HALLEY_ITER</b> = <a class="el" href="constants_8h.html#ab139026298fae1aafae59ac99dbcc2d6">THEORETICA_MAX_HALLEY_ITER</a></td></tr>
<tr class="memdesc:a10b14b1cb08bd3c634410570abf8258e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations for Halley's method. <br /></td></tr>
<tr class="separator:a10b14b1cb08bd3c634410570abf8258e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09bde3716d7598748a55fa65c9abb6e3"><td class="memItemLeft" align="right" valign="top"><a id="a09bde3716d7598748a55fa65c9abb6e3" name="a09bde3716d7598748a55fa65c9abb6e3"></a>
constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_NEWTON_ITER</b> = <a class="el" href="constants_8h.html#a7f8e8f98bdd6e74a743d5487d4b976aa">THEORETICA_MAX_NEWTON_ITER</a></td></tr>
<tr class="memdesc:a09bde3716d7598748a55fa65c9abb6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations for the Newton-Raphson algorithm. <br /></td></tr>
<tr class="separator:a09bde3716d7598748a55fa65c9abb6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3016878f7fd372f0c459c4776e8059"><td class="memItemLeft" align="right" valign="top"><a id="abe3016878f7fd372f0c459c4776e8059" name="abe3016878f7fd372f0c459c4776e8059"></a>
constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_STEFFENSEN_ITER</b> = <a class="el" href="constants_8h.html#a079d3def41600f49deb005b75b524adc">THEORETICA_MAX_STEFFENSEN_ITER</a></td></tr>
<tr class="memdesc:abe3016878f7fd372f0c459c4776e8059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations for the Steffensen algorithm. <br /></td></tr>
<tr class="separator:abe3016878f7fd372f0c459c4776e8059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f2aa11982032c3035e8458f17d9a43"><td class="memItemLeft" align="right" valign="top"><a id="a91f2aa11982032c3035e8458f17d9a43" name="a91f2aa11982032c3035e8458f17d9a43"></a>
constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_CHEBYSHEV_ITER</b> = <a class="el" href="constants_8h.html#a70db1d134cdacb5b4c1bc8ffac852a7b">THEORETICA_MAX_CHEBYSHEV_ITER</a></td></tr>
<tr class="memdesc:a91f2aa11982032c3035e8458f17d9a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations for the Chebyshev algorithm. <br /></td></tr>
<tr class="separator:a91f2aa11982032c3035e8458f17d9a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3299f783527ae72a24c832a7b1cd8ef8"><td class="memItemLeft" align="right" valign="top"><a id="a3299f783527ae72a24c832a7b1cd8ef8" name="a3299f783527ae72a24c832a7b1cd8ef8"></a>
constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_TRYANDCATCH_ITER</b> = <a class="el" href="constants_8h.html#a9185ccd5fcdd822ae6b8b06eb1437674">THEORETICA_MAX_TRYANDCATCH_ITER</a></td></tr>
<tr class="memdesc:a3299f783527ae72a24c832a7b1cd8ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of failed iterations for the Try-and-Catch algorithm. <br /></td></tr>
<tr class="separator:a3299f783527ae72a24c832a7b1cd8ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72dfe63d1cce5e9c204cba3493a4e598"><td class="memItemLeft" align="right" valign="top"><a id="a72dfe63d1cce5e9c204cba3493a4e598" name="a72dfe63d1cce5e9c204cba3493a4e598"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DERIV_STEPSIZE</b> = <a class="el" href="constants_8h.html#ace3fe91b8a7122e757c127367663dc0f">THEORETICA_DERIV_STEPSIZE</a></td></tr>
<tr class="memdesc:a72dfe63d1cce5e9c204cba3493a4e598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default variation for derivative approximation. <br /></td></tr>
<tr class="separator:a72dfe63d1cce5e9c204cba3493a4e598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33f363492da480d62e2e0b5ad2c4ee9"><td class="memItemLeft" align="right" valign="top"><a id="ab33f363492da480d62e2e0b5ad2c4ee9" name="ab33f363492da480d62e2e0b5ad2c4ee9"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MINGRAD_GAMMA</b> = <a class="el" href="constants_8h.html#aac8e3eb0953959ada47984923ba5ca8e">THEORETICA_MINGRAD_GAMMA</a></td></tr>
<tr class="memdesc:ab33f363492da480d62e2e0b5ad2c4ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default step size for gradient descent minimization. <br /></td></tr>
<tr class="separator:ab33f363492da480d62e2e0b5ad2c4ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ebee50e5a5a80baaa6532a736ce7d55"><td class="memItemLeft" align="right" valign="top"><a id="a5ebee50e5a5a80baaa6532a736ce7d55" name="a5ebee50e5a5a80baaa6532a736ce7d55"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MINGRAD_TOLERANCE</b> = <a class="el" href="constants_8h.html#ab1f00908cc1227294e6c5be8de0e1423">THEORETICA_MINGRAD_TOLERANCE</a></td></tr>
<tr class="memdesc:a5ebee50e5a5a80baaa6532a736ce7d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default tolerance for gradient descent minimization. <br /></td></tr>
<tr class="separator:a5ebee50e5a5a80baaa6532a736ce7d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4ef8ed777e402e2ae0c7f736ba20cb"><td class="memItemLeft" align="right" valign="top"><a id="acd4ef8ed777e402e2ae0c7f736ba20cb" name="acd4ef8ed777e402e2ae0c7f736ba20cb"></a>
constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>MINGRAD_MAX_ITER</b> = <a class="el" href="constants_8h.html#ac7c192f4ff34c26e248e6d218a944027">THEORETICA_MINGRAD_MAX_ITER</a></td></tr>
<tr class="memdesc:acd4ef8ed777e402e2ae0c7f736ba20cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations for gradient descent minimization. <br /></td></tr>
<tr class="separator:acd4ef8ed777e402e2ae0c7f736ba20cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e48eab9ce5928d0c754a40ddb2d068f"><td class="memItemLeft" align="right" valign="top"><a id="a0e48eab9ce5928d0c754a40ddb2d068f" name="a0e48eab9ce5928d0c754a40ddb2d068f"></a>
constexpr uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>RAND_REAL_PREC</b> = <a class="el" href="constants_8h.html#ac13dd04d659ae36e514a06cd075f0e0e">THEORETICA_RAND_REAL_PREC</a></td></tr>
<tr class="memdesc:a0e48eab9ce5928d0c754a40ddb2d068f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default precision for random number generation using <a class="el" href="namespacetheoretica.html#a6a35e29644875a5421b3ac4d7203c28a" title="Generate a pseudorandom real number in [a, b] using a preexisting generator.">rand_uniform()</a> <br /></td></tr>
<tr class="separator:a0e48eab9ce5928d0c754a40ddb2d068f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Main namespace of the library which contains all functions and objects. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a049966946220f1f7e5eae57293703066" name="a049966946220f1f7e5eae57293703066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a049966946220f1f7e5eae57293703066">&#9670;&nbsp;</a></span>real</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">theoretica::real</a> = typedef double</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A real number, defined as a floating point type. </p>
<p >The underlying type is determined by the defined macros: By default, <code>real</code> will be defined as the <code>double</code> type. If <code>THEORETICA_FLOAT_PREC</code> is defined, <code>real</code> will be defined as a <code>float</code>, if <code>THEORETICA_LONG_DOUBLE_PREC</code> is defined, <code>real</code> will be defined as a <code>long double</code> </p><dl class="section note"><dt>Note</dt><dd>The <code>THEORETICA_ARBITRARY_PREC</code> option is currently unsupported </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a0f49fa3c3999e2a64956c3cb44bf596c" name="a0f49fa3c3999e2a64956c3cb44bf596c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f49fa3c3999e2a64956c3cb44bf596c">&#9670;&nbsp;</a></span>abs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the modulus of a complex number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5177ff64d981840e149d1e282f1b27e" name="aa5177ff64d981840e149d1e282f1b27e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5177ff64d981840e149d1e282f1b27e">&#9670;&nbsp;</a></span>abs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the absolute value of a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The absolute value of x</dd></dl>
<p>On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fabs</code> instruction will be used. </p>

</div>
</div>
<a id="a8a281d198a95a4d2f0f85ccd003948f6" name="a8a281d198a95a4d2f0f85ccd003948f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a281d198a95a4d2f0f85ccd003948f6">&#9670;&nbsp;</a></span>acos() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a> theoretica::acos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the complex arccosine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f2d69e3a3387958a27d4a03ed478a99" name="a7f2d69e3a3387958a27d4a03ed478a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f2d69e3a3387958a27d4a03ed478a99">&#9670;&nbsp;</a></span>acos() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::acos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the arccosine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The arccosine of x</dd></dl>
<p>Domain: [-1, 1]. The identities \(acos(x) = atan(\frac{sqrt{1 - x^2}}{x})\) and \(acos(x) = atan(\frac{\sqrt{1 - x^2}}{x}) + \pi\) are used. </p>

</div>
</div>
<a id="ab6c4590079678ebac8a917eeda049bf4" name="ab6c4590079678ebac8a917eeda049bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c4590079678ebac8a917eeda049bf4">&#9670;&nbsp;</a></span>asin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a> theoretica::asin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the complex arcsine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79b06e5bf997c4447c10f2fa96649347" name="a79b06e5bf997c4447c10f2fa96649347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b06e5bf997c4447c10f2fa96649347">&#9670;&nbsp;</a></span>asin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::asin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the arcsine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The arcsine of x</dd></dl>
<p>Domain: [-1, 1]. The identity \(asin(x) = atan(\frac{x}{\sqrt{1 - x^2}})\) is used. </p>

</div>
</div>
<a id="a423991094f40604ba94e6ae9275d5ea8" name="a423991094f40604ba94e6ae9275d5ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a423991094f40604ba94e6ae9275d5ea8">&#9670;&nbsp;</a></span>atan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a> theoretica::atan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the complex arctangent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a426b70abe4783e75806e1ae8c9e9e2bd" name="a426b70abe4783e75806e1ae8c9e9e2bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a426b70abe4783e75806e1ae8c9e9e2bd">&#9670;&nbsp;</a></span>atan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::atan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the arctangent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>An angle in <b>radians</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The arctangent of x</dd></dl>
<p>A degree 9 interpolating polynomial through Chebyshev nodes is used to approximate \(atan(x)\). Domain reduction to [-1, 1] is performed. </p>

</div>
</div>
<a id="a6ae6ab14a39d6132b6858934dadaaf3e" name="a6ae6ab14a39d6132b6858934dadaaf3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae6ab14a39d6132b6858934dadaaf3e">&#9670;&nbsp;</a></span>atan2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::atan2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the 2 argument arctangent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>The y coordinate in cartesian space </td></tr>
    <tr><td class="paramname">x</td><td>The x coordinate in cartesian space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The counterclockwise angle between the vector described by x and y and the x axis.</dd></dl>
<p>Computed using identities on atan(x). </p>

</div>
</div>
<a id="aeaac9bb0b5b83e96e4312cef9d99af68" name="aeaac9bb0b5b83e96e4312cef9d99af68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaac9bb0b5b83e96e4312cef9d99af68">&#9670;&nbsp;</a></span>bezier()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; theoretica::bezier </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; &gt;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic Bezier curve in N dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>The control points </td></tr>
    <tr><td class="paramname">t</td><td>The curve parameter between 0 and 1</td></tr>
  </table>
  </dd>
</dl>
<p>The generic Bezier curve is computed by successive linear interpolations. For cubic and quadratic Bezier curves the related functions should be preferred. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetheoretica.html#a69213a79c487ca5266077e64f7624fb3" title="Quadratic Bezier curve.">quadratic_bezier</a> </dd>
<dd>
<a class="el" href="namespacetheoretica.html#a2b261d224ea1a2878b802013eae0fbaf" title="Cubic Bezier curve.">cubic_bezier</a> </dd></dl>

</div>
</div>
<a id="a129bf1f1085a76b92999e0faeb30e831" name="a129bf1f1085a76b92999e0faeb30e831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129bf1f1085a76b92999e0faeb30e831">&#9670;&nbsp;</a></span>binomial_coeff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType  = unsigned long long int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> IntType theoretica::binomial_coeff </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the binomial coefficient. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A natural number </td></tr>
    <tr><td class="paramname">m</td><td>A natural number smaller than n </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binomial coefficient computed on (n, m) as \(\frac{n!}{m!(n - m)!}\) </dd></dl>

</div>
</div>
<a id="a249d8d6497120d311e2abbfc11c5f54d" name="a249d8d6497120d311e2abbfc11c5f54d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a249d8d6497120d311e2abbfc11c5f54d">&#9670;&nbsp;</a></span>bit_rotate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ShiftableType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ShiftableType theoretica::bit_rotate </td>
          <td>(</td>
          <td class="paramtype">ShiftableType&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bit rotation using shifting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The variable to rotate the bits of </td></tr>
    <tr><td class="paramname">i</td><td>The index of the rotated bits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61c3b797f94ec5bc22b4c22f85417c93" name="a61c3b797f94ec5bc22b4c22f85417c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c3b797f94ec5bc22b4c22f85417c93">&#9670;&nbsp;</a></span>cbrt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::cbrt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cubic root of x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cubic root of x</dd></dl>
<p>Domain: [-inf, +inf] <br  />
The Newton-Raphson algorithm, optimized for the cubic root and limited by the <code>THEORETICA_MAX_NEWTON_ITER</code> macro constant, is used. Domain reduction to [0, 1] is applied to ensure convergence of the algorithm. </p>

</div>
</div>
<a id="a085e34f437a529b59778090e0cb122e5" name="a085e34f437a529b59778090e0cb122e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a085e34f437a529b59778090e0cb122e5">&#9670;&nbsp;</a></span>chebyshev1_polynomial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; theoretica::chebyshev1_polynomial </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the nth Chebyshev polynomial of the first kind. </p>
<dl class="section note"><dt>Note</dt><dd>The result is not normalized </dd></dl>

</div>
</div>
<a id="a3450aa75a960635e9f33a6dabb22752b" name="a3450aa75a960635e9f33a6dabb22752b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3450aa75a960635e9f33a6dabb22752b">&#9670;&nbsp;</a></span>chebyshev2_polynomial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; theoretica::chebyshev2_polynomial </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the nth Chebyshev polynomial of the second kind. </p>
<dl class="section note"><dt>Note</dt><dd>The result is not normalized </dd></dl>

</div>
</div>
<a id="af77c5c6195e30df1e423b0922cc0776e" name="af77c5c6195e30df1e423b0922cc0776e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af77c5c6195e30df1e423b0922cc0776e">&#9670;&nbsp;</a></span>chebyshev_nodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> theoretica::chebyshev_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the n Chebyshev nodes on a given interval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The lower bound of the interval </td></tr>
    <tr><td class="paramname">b</td><td>The upper bound of the interval </td></tr>
    <tr><td class="paramname">n</td><td>The number of points to evaluate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1a4ad4c5446986fe2d255a03be337a1" name="af1a4ad4c5446986fe2d255a03be337a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1a4ad4c5446986fe2d255a03be337a1">&#9670;&nbsp;</a></span>clamp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::clamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clamp x between a and b. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The real number to clamp </td></tr>
    <tr><td class="paramname">a</td><td>The lower bound </td></tr>
    <tr><td class="paramname">b</td><td>The upper bound </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns x if x is between a and b, a if x is less than a, b if x is bigger than b </dd></dl>

</div>
</div>
<a id="acdf4d125306e3fffc7287aa42f9005a1" name="acdf4d125306e3fffc7287aa42f9005a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf4d125306e3fffc7287aa42f9005a1">&#9670;&nbsp;</a></span>clamp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T theoretica::clamp </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clamp a value between two other values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to clamp </td></tr>
    <tr><td class="paramname">a</td><td>The lower bound </td></tr>
    <tr><td class="paramname">b</td><td>The upper bound </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns x if x is between a and b, a if x is less than a, b if x is bigger than b</dd></dl>
<p>The templated T type must have comparison operators. </p>

</div>
</div>
<a id="a4fa9e6cd9857b4f64165ebebfd58ec3b" name="a4fa9e6cd9857b4f64165ebebfd58ec3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fa9e6cd9857b4f64165ebebfd58ec3b">&#9670;&nbsp;</a></span>conjugate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a> theoretica::conjugate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the conjugate of a complex number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32015dfa47fc795e0fefcf26b5c0375d" name="a32015dfa47fc795e0fefcf26b5c0375d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32015dfa47fc795e0fefcf26b5c0375d">&#9670;&nbsp;</a></span>cos() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a> theoretica::cos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the complex cosine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af684d7159e22012dc5229c31eb66fceb" name="af684d7159e22012dc5229c31eb66fceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af684d7159e22012dc5229c31eb66fceb">&#9670;&nbsp;</a></span>cos() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::cos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cosine of a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>An angle in <b>radians</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cosine of x</dd></dl>
<p>On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fcos</code> instruction will be used. </p>

</div>
</div>
<a id="a12fc03cbb1de8180e51183bb82c0bb28" name="a12fc03cbb1de8180e51183bb82c0bb28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12fc03cbb1de8180e51183bb82c0bb28">&#9670;&nbsp;</a></span>cosh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::cosh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the hyperbolic cosine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic cosine of x</dd></dl>
<p>\(cosh = \frac{e^x + e^{-x}}{2}\) </p>

</div>
</div>
<a id="aec6f43e74456bea35fb757f17db47da8" name="aec6f43e74456bea35fb757f17db47da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6f43e74456bea35fb757f17db47da8">&#9670;&nbsp;</a></span>cot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::cot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cotangent of x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>An angle in <b>radians</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cotangent of x</dd></dl>
<p>On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fsincos</code> instruction will be used. </p>

</div>
</div>
<a id="a96f957ad9b2354268f56ab1ca3843080" name="a96f957ad9b2354268f56ab1ca3843080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f957ad9b2354268f56ab1ca3843080">&#9670;&nbsp;</a></span>coth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::coth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the hyperbolic cotangent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic cotangent of x </dd></dl>

</div>
</div>
<a id="a12940c0bd43e6edcabb9064ccfd6cc5a" name="a12940c0bd43e6edcabb9064ccfd6cc5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12940c0bd43e6edcabb9064ccfd6cc5a">&#9670;&nbsp;</a></span>cross()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; 3, T &gt; theoretica::cross </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; 3, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; 3, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cross product of two vectors. </p>
<p >The vectors have to be 3-dimensional </p>

</div>
</div>
<a id="aa8a0b9841198983905b57496cad4869e" name="aa8a0b9841198983905b57496cad4869e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a0b9841198983905b57496cad4869e">&#9670;&nbsp;</a></span>cube() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a> theoretica::cube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cube of a complex number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6bfa8d12242c241b6f56cebc9cdc60ed" name="a6bfa8d12242c241b6f56cebc9cdc60ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bfa8d12242c241b6f56cebc9cdc60ed">&#9670;&nbsp;</a></span>cube() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::cube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cube of a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cube of x</dd></dl>
<p>Domain: [-inf, +inf] </p>

</div>
</div>
<a id="a840b8c27d0a8398f33858b1f8d55732d" name="a840b8c27d0a8398f33858b1f8d55732d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a840b8c27d0a8398f33858b1f8d55732d">&#9670;&nbsp;</a></span>degrees()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::degrees </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>radians</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert radians to degrees. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radians</td><td>An angle in radians </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted angle in degrees</dd></dl>
<p>The <code>RAD2DEG</code> scalar factor is used. </p>

</div>
</div>
<a id="af13c23d95e0130b1e29ac617f313f27d" name="af13c23d95e0130b1e29ac617f313f27d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af13c23d95e0130b1e29ac617f313f27d">&#9670;&nbsp;</a></span>deriv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::deriv </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="namespacetheoretica.html#a72dfe63d1cce5e9c204cba3493a4e598">DERIV_STEPSIZE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use the best available algorithm to approximate the derivative of a real function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to approximate the derivative of </td></tr>
    <tr><td class="paramname">x</td><td>The real value to approximate at </td></tr>
    <tr><td class="paramname">h</td><td>The stepsize to use in the finite differences method </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The approximated value of the derivative </dd></dl>

</div>
</div>
<a id="ad376dcd3be0e15133bbedf6ad1160587" name="ad376dcd3be0e15133bbedf6ad1160587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad376dcd3be0e15133bbedf6ad1160587">&#9670;&nbsp;</a></span>deriv2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::deriv2 </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="namespacetheoretica.html#a72dfe63d1cce5e9c204cba3493a4e598">DERIV_STEPSIZE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use the best available algorithm to approximate the second derivative of a real function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to approximate the second derivative of </td></tr>
    <tr><td class="paramname">x</td><td>The real value to approximate at </td></tr>
    <tr><td class="paramname">h</td><td>The stepsize to use in the finite differences method </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The approximated value of the second derivative </dd></dl>

</div>
</div>
<a id="a0fda7d7c90a088c8bdbf28b0908c71e8" name="a0fda7d7c90a088c8bdbf28b0908c71e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fda7d7c90a088c8bdbf28b0908c71e8">&#9670;&nbsp;</a></span>deriv_backward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::deriv_backward </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="namespacetheoretica.html#a72dfe63d1cce5e9c204cba3493a4e598">DERIV_STEPSIZE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derivative approximation using the backward method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to approximate the derivative of </td></tr>
    <tr><td class="paramname">x</td><td>The real value to approximate at </td></tr>
    <tr><td class="paramname">h</td><td>The stepsize to use in the finite differences method </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The approximated value of the derivative </dd></dl>

</div>
</div>
<a id="a5bbf1baa785f514b3e3a74f80fbd9546" name="a5bbf1baa785f514b3e3a74f80fbd9546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bbf1baa785f514b3e3a74f80fbd9546">&#9670;&nbsp;</a></span>deriv_central()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::deriv_central </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="namespacetheoretica.html#a72dfe63d1cce5e9c204cba3493a4e598">DERIV_STEPSIZE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derivative approximation using the central method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to approximate the derivative of </td></tr>
    <tr><td class="paramname">x</td><td>The real value to approximate at </td></tr>
    <tr><td class="paramname">h</td><td>The stepsize to use in the finite differences method </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The approximated value of the derivative </dd></dl>

</div>
</div>
<a id="a936dad7b99b64c874223aa537c3ad84f" name="a936dad7b99b64c874223aa537c3ad84f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a936dad7b99b64c874223aa537c3ad84f">&#9670;&nbsp;</a></span>deriv_forward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::deriv_forward </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="namespacetheoretica.html#a72dfe63d1cce5e9c204cba3493a4e598">DERIV_STEPSIZE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derivative approximation using the forward method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to approximate the derivative of </td></tr>
    <tr><td class="paramname">x</td><td>The real value to approximate at </td></tr>
    <tr><td class="paramname">h</td><td>The stepsize to use in the finite differences method </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The approximated value of the derivative </dd></dl>

</div>
</div>
<a id="a3db068fdfc750be0e45e3fcaa77fc458" name="a3db068fdfc750be0e45e3fcaa77fc458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db068fdfc750be0e45e3fcaa77fc458">&#9670;&nbsp;</a></span>deriv_polynomial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = real&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; T &gt; theoretica::deriv_polynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the derivative of a polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The polynomial to differentiate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The derivative polynomial </dd></dl>

</div>
</div>
<a id="a08c5277448360f087fa63323020675c6" name="a08c5277448360f087fa63323020675c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08c5277448360f087fa63323020675c6">&#9670;&nbsp;</a></span>deriv_ridders()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::deriv_ridders </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code>0.01</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>degree</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ridder's derivative approximation of arbitrary degree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to approximate the derivative of </td></tr>
    <tr><td class="paramname">x</td><td>The real value to approximate at </td></tr>
    <tr><td class="paramname">degree</td><td>The degree of the algorithm </td></tr>
    <tr><td class="paramname">h</td><td>The stepsize to use in the finite differences method </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The approximated value of the derivative </dd></dl>

</div>
</div>
<a id="a93f963a737accf2110a8ed71a5064320" name="a93f963a737accf2110a8ed71a5064320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f963a737accf2110a8ed71a5064320">&#9670;&nbsp;</a></span>deriv_ridders2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::deriv_ridders2 </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="namespacetheoretica.html#a72dfe63d1cce5e9c204cba3493a4e598">DERIV_STEPSIZE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ridder's derivative approximation of second degree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to approximate the derivative of </td></tr>
    <tr><td class="paramname">x</td><td>The real value to approximate at </td></tr>
    <tr><td class="paramname">h</td><td>The stepsize to use in the finite differences method </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The approximated value of the derivative </dd></dl>

</div>
</div>
<a id="a4f2b544ce53ec2f8e548afadd59a52d5" name="a4f2b544ce53ec2f8e548afadd59a52d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f2b544ce53ec2f8e548afadd59a52d5">&#9670;&nbsp;</a></span>directional_derivative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;)&gt; theoretica::directional_derivative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a function which computes the directional derivative of a generic function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to partially differentiate </td></tr>
    <tr><td class="paramname">x</td><td>The point to compute the derivative at </td></tr>
    <tr><td class="paramname">v</td><td>The direction to compute the derivative on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In most applications, the vector v should be a unit vector, but the function does not control whether the vector has unit length or not. </dd></dl>

</div>
</div>
<a id="aed789cb9f8123584b3e1f1f9a334f47d" name="aed789cb9f8123584b3e1f1f9a334f47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed789cb9f8123584b3e1f1f9a334f47d">&#9670;&nbsp;</a></span>directional_derivative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; theoretica::directional_derivative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the directional derivative of a generic function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to partially differentiate </td></tr>
    <tr><td class="paramname">x</td><td>The point to compute the derivative at </td></tr>
    <tr><td class="paramname">v</td><td>The direction to compute the derivative on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In most applications, the vector v should be a unit vector, but the function does not control whether the vector has unit length or not. </dd></dl>

</div>
</div>
<a id="a01412973394e4d319502a0fed1f8a9da" name="a01412973394e4d319502a0fed1f8a9da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01412973394e4d319502a0fed1f8a9da">&#9670;&nbsp;</a></span>divergence_mono()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::divergence_mono </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1dual.html">dual</a>(*)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1dual.html">dual</a> &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the divergence for a given \(\vec x\) of a function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\) using automatic differentiation. </p>
<dl class="section note"><dt>Note</dt><dd>The multidual implementation is more efficient as it does not need to compute the function value N times and should be preferred.</dd></dl>
<p>The <code>mono</code> suffix is used to emphasize the difference between simple dual numbers and multidual numbers and to avoid differentiation between overloads on the user's side. </p>

</div>
</div>
<a id="ad1e24ba47041f2f97e910ae3ee472992" name="ad1e24ba47041f2f97e910ae3ee472992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e24ba47041f2f97e910ae3ee472992">&#9670;&nbsp;</a></span>euclidean_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::euclidean_distance </td>
          <td>(</td>
          <td class="paramtype">Vector&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Distances. </p>
<p >Compute the Euclidean distance between two vectors </p>

</div>
</div>
<a id="a463ef7c6f8731bab9581d4021e92a60b" name="a463ef7c6f8731bab9581d4021e92a60b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463ef7c6f8731bab9581d4021e92a60b">&#9670;&nbsp;</a></span>exp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a> theoretica::exp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the complex exponential. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac61f8810fcedeaa35f54c834e934828e" name="ac61f8810fcedeaa35f54c834e934828e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac61f8810fcedeaa35f54c834e934828e">&#9670;&nbsp;</a></span>exp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::exp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute \(e^x\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exponential of x</dd></dl>
<p>The exponential is computed as \(e^{floor(x)} e^{fract(x)}\), where \(e^{floor(x)} = pow(e, floor(x))\) and \(e^{fract(x)}\) is either approximated using Taylor series on [0, 0.5] or, if <code>THEORETICA_X86</code> is defined, using the <code>f2xm1</code> x86 assembly instruction. </p>

</div>
</div>
<a id="afad5c92586d6a0f841bfcd3759eff317" name="afad5c92586d6a0f841bfcd3759eff317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad5c92586d6a0f841bfcd3759eff317">&#9670;&nbsp;</a></span>floor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> int theoretica::floor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the floor of x Computes the maximum integer number that is smaller than x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The floor of x</dd></dl>
<p>e.g. floor(1.6) = 1 e.g. floor(-0.3) = -1 </p>

</div>
</div>
<a id="a85d079c3d95f2bc80c4619d13ff7263a" name="a85d079c3d95f2bc80c4619d13ff7263a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d079c3d95f2bc80c4619d13ff7263a">&#9670;&nbsp;</a></span>fract()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::fract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the fractional part of a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The fractional part of x</dd></dl>
<p>e.g. fract(2.5) = 0.5 e.g. fract(-0.2) = 0.2 </p>

</div>
</div>
<a id="a5adf7d2f3094d32dd9d4059ec86247db" name="a5adf7d2f3094d32dd9d4059ec86247db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5adf7d2f3094d32dd9d4059ec86247db">&#9670;&nbsp;</a></span>gen_polyn_recurr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; theoretica::gen_polyn_recurr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td>
          <td class="paramname"><em>P0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#adb4ba8e2a5511c5650d331d0209013ff">polyn_recurr_formula</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a polynomial basis using a recursion formula. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P0</td><td>First polynomial of the sequence </td></tr>
    <tr><td class="paramname">P1</td><td>Second polynomial of the sequence </td></tr>
    <tr><td class="paramname">f</td><td>Recursion formula </td></tr>
    <tr><td class="paramname">&lt;br&gt;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7945a9959534ed6da94246f568393cd2" name="a7945a9959534ed6da94246f568393cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7945a9959534ed6da94246f568393cd2">&#9670;&nbsp;</a></span>gradient_mono()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; theoretica::gradient_mono </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1dual.html">dual</a>(*)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1dual.html">dual</a> &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the gradient for a given \(\vec x\) of a function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\) using automatic differentiation. </p>
<dl class="section note"><dt>Note</dt><dd>The multidual implementation is more efficient as it does not need to compute the function value N times and should be preferred.</dd></dl>
<p>The <code>mono</code> suffix is used to emphasize the difference between simple dual numbers and multidual numbers and to avoid differentiation between overloads on the user's side. </p>

</div>
</div>
<a id="a024554cae44fb42700e8f68d235f0f15" name="a024554cae44fb42700e8f68d235f0f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a024554cae44fb42700e8f68d235f0f15">&#9670;&nbsp;</a></span>heaviside()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::heaviside </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the heaviside function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The heaviside function for x, equal to 1 if x &gt; 0, 0 if x &lt; 0 and 1/2 if x = 0 </dd></dl>

</div>
</div>
<a id="afd97a0d6d99915f065567958760164f4" name="afd97a0d6d99915f065567958760164f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd97a0d6d99915f065567958760164f4">&#9670;&nbsp;</a></span>hermite_polynomial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; theoretica::hermite_polynomial </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the nth Hermite polynomial. </p>
<dl class="section note"><dt>Note</dt><dd>The result is not normalized </dd></dl>

</div>
</div>
<a id="ad830de3729f8f2bea38d60ef706cf968" name="ad830de3729f8f2bea38d60ef706cf968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad830de3729f8f2bea38d60ef706cf968">&#9670;&nbsp;</a></span>icbrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnsignedIntType  = uint64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UnsignedIntType theoretica::icbrt </td>
          <td>(</td>
          <td class="paramtype">UnsignedIntType&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the integer cubic root of a positive integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A positive integer number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rounded down cubic root of n A binary search algorithm is used. </dd></dl>

</div>
</div>
<a id="a90fa837617e2c026520db02b8b616009" name="a90fa837617e2c026520db02b8b616009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90fa837617e2c026520db02b8b616009">&#9670;&nbsp;</a></span>identity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a> theoretica::identity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Complex identity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae095e7eee4b03eddc3b035b2bde14a7e" name="ae095e7eee4b03eddc3b035b2bde14a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae095e7eee4b03eddc3b035b2bde14a7e">&#9670;&nbsp;</a></span>integral()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use the best available algorithm to approximate the definite integral of a real function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An approximation of the integral of f </dd></dl>

</div>
</div>
<a id="ab8d9d3758ff38fa704a20a69acf52fa9" name="ab8d9d3758ff38fa704a20a69acf52fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d9d3758ff38fa704a20a69acf52fa9">&#9670;&nbsp;</a></span>integral_crude()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_crude </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em> = <code>10000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate an integral by using Crude Monte Carlo integration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
    <tr><td class="paramname">N</td><td>The number of points to generate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a967dd449e256761db7b35e735293eced" name="a967dd449e256761db7b35e735293eced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a967dd449e256761db7b35e735293eced">&#9670;&nbsp;</a></span>integral_hom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_hom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>f_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em> = <code>10000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate an integral by using Hit-or-miss Monte Carlo integration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">f_max</td><td>The function maximum in the [a, b] interval </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
    <tr><td class="paramname">N</td><td>The number of points to generate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef98fa2e06497f31c13f7377ddd6c0ce" name="aef98fa2e06497f31c13f7377ddd6c0ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef98fa2e06497f31c13f7377ddd6c0ce">&#9670;&nbsp;</a></span>integral_hom_2d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_hom_2d </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>f_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em> = <code>10000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use the Hit-or-Miss Monte Carlo method to approximate a double integral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The multivariate function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration on x </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration on x </td></tr>
    <tr><td class="paramname">c</td><td>The lower extreme of integration on y </td></tr>
    <tr><td class="paramname">d</td><td>The upper extreme of integration on y </td></tr>
    <tr><td class="paramname">f_max</td><td>The function maximum in the [a, b]x[c, d] interval </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
    <tr><td class="paramname">N</td><td>The number of points to generate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a48a7bb7296e78f5c1b0c5f5bcf4d93" name="a1a48a7bb7296e78f5c1b0c5f5bcf4d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a48a7bb7296e78f5c1b0c5f5bcf4d93">&#9670;&nbsp;</a></span>integral_midpoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_midpoint </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>steps</em> = <code><a class="el" href="namespacetheoretica.html#aa1f0e3448f94ada54d171499c0c95ae4">INTEGRATION_STEPS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate the definite integral of an arbitrary function using the midpoint method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">steps</td><td>The number of steps </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An approximation of the integral of f </dd></dl>

</div>
</div>
<a id="a209c9b01ff5ed0f29ffc62af1f53be9e" name="a209c9b01ff5ed0f29ffc62af1f53be9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a209c9b01ff5ed0f29ffc62af1f53be9e">&#9670;&nbsp;</a></span>integral_quasi_crude()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_quasi_crude </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em> = <code>10000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate an integral by using Crude Quasi-Monte Carlo integration by sampling from the Weyl sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">N</td><td>The number of points to generate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74aacdc1b73b70ecb0d8a2c9890b8371" name="a74aacdc1b73b70ecb0d8a2c9890b8371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74aacdc1b73b70ecb0d8a2c9890b8371">&#9670;&nbsp;</a></span>integral_quasi_hom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_quasi_hom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>f_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em> = <code>10000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate an integral by using Hit-or-miss Quasi-Monte Carlo integration, sampling points from the Weyl bi-dimensional sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">f_max</td><td>The function maximum in the [a, b] interval </td></tr>
    <tr><td class="paramname">N</td><td>The number of points to generate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a710ca6ff97e6d14f5f42bab6462d9fa2" name="a710ca6ff97e6d14f5f42bab6462d9fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710ca6ff97e6d14f5f42bab6462d9fa2">&#9670;&nbsp;</a></span>integral_romberg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_romberg </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>order</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate the definite integral of an arbitrary function using Romberg's method accurate to the given order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">order</td><td>The order of accuracy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An approximation of the integral of f </dd></dl>

</div>
</div>
<a id="ad5f3d75e6a0c23d23a5e685145437ff5" name="ad5f3d75e6a0c23d23a5e685145437ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f3d75e6a0c23d23a5e685145437ff5">&#9670;&nbsp;</a></span>integral_simpson()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_simpson </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>steps</em> = <code><a class="el" href="namespacetheoretica.html#aa1f0e3448f94ada54d171499c0c95ae4">INTEGRATION_STEPS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate the definite integral of an arbitrary function using Simpson's method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">steps</td><td>The number of steps </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An approximation of the integral of f </dd></dl>

</div>
</div>
<a id="a4cbfca610e297e184c272140d991e987" name="a4cbfca610e297e184c272140d991e987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cbfca610e297e184c272140d991e987">&#9670;&nbsp;</a></span>integral_trapezoid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::integral_trapezoid </td>
          <td>(</td>
          <td class="paramtype">RealFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>steps</em> = <code><a class="el" href="namespacetheoretica.html#aa1f0e3448f94ada54d171499c0c95ae4">INTEGRATION_STEPS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate the definite integral of an arbitrary function using the trapezoid method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">steps</td><td>The number of steps </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An approximation of the integral of f </dd></dl>

</div>
</div>
<a id="ae33677028b95163d88cfe6343d84ce31" name="ae33677028b95163d88cfe6343d84ce31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae33677028b95163d88cfe6343d84ce31">&#9670;&nbsp;</a></span>integrate_ode_euler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt; theoretica::integrate_ode_euler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integrate numerically a differential equation in one unknown using Euler's method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function which computes the derivative of the state </td></tr>
    <tr><td class="paramname">s</td><td>The current state of the ODE </td></tr>
    <tr><td class="paramname">h</td><td>The real step size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab472cc6c088fd942b4a9203eb6b75add" name="ab472cc6c088fd942b4a9203eb6b75add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab472cc6c088fd942b4a9203eb6b75add">&#9670;&nbsp;</a></span>integrate_ode_euler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt; theoretica::integrate_ode_euler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;(*)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integrate numerically a differential equation in N unknowns using Euler's method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function which computes the derivative of the state </td></tr>
    <tr><td class="paramname">s</td><td>The current state of the ODE </td></tr>
    <tr><td class="paramname">h</td><td>The real step size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92b75bb553d0ae78a096c11498d6118d" name="a92b75bb553d0ae78a096c11498d6118d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b75bb553d0ae78a096c11498d6118d">&#9670;&nbsp;</a></span>integrate_ode_heun() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt; theoretica::integrate_ode_heun </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integrate numerically a differential equation in one unknown using Heun's method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function which computes the derivative of the state </td></tr>
    <tr><td class="paramname">s</td><td>The current state of the ODE </td></tr>
    <tr><td class="paramname">h</td><td>The real step size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa33e3c75bb18df5b0130a2d13db00576" name="aa33e3c75bb18df5b0130a2d13db00576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa33e3c75bb18df5b0130a2d13db00576">&#9670;&nbsp;</a></span>integrate_ode_heun() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt; theoretica::integrate_ode_heun </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;(*)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integrate numerically a differential equation in N unknowns using Heun's method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function which computes the derivative of the state </td></tr>
    <tr><td class="paramname">s</td><td>The current state of the ODE </td></tr>
    <tr><td class="paramname">h</td><td>The real step size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9b8a7c7bae8e200528ade408f85dc87" name="aa9b8a7c7bae8e200528ade408f85dc87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b8a7c7bae8e200528ade408f85dc87">&#9670;&nbsp;</a></span>integrate_ode_k38() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt; theoretica::integrate_ode_k38 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integrate numerically a differential equation in one unknown using Kutta's 3/8 rule method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function which computes the derivative of the state </td></tr>
    <tr><td class="paramname">s</td><td>The current state of the ODE </td></tr>
    <tr><td class="paramname">h</td><td>The real step size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a586d26495e48bc20c35c8afac60a580c" name="a586d26495e48bc20c35c8afac60a580c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a586d26495e48bc20c35c8afac60a580c">&#9670;&nbsp;</a></span>integrate_ode_k38() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt; theoretica::integrate_ode_k38 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;(*)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integrate numerically a differential equation in N unknowns using Kutta's 3/8 rule method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function which computes the derivative of the state </td></tr>
    <tr><td class="paramname">s</td><td>The current state of the ODE </td></tr>
    <tr><td class="paramname">h</td><td>The real step size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a599ac0edf98cb7ed53f9554c29b74da9" name="a599ac0edf98cb7ed53f9554c29b74da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a599ac0edf98cb7ed53f9554c29b74da9">&#9670;&nbsp;</a></span>integrate_ode_midpoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt; theoretica::integrate_ode_midpoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integrate numerically a differential equation in one unknown using the midpoint method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function which computes the derivative of the state </td></tr>
    <tr><td class="paramname">s</td><td>The current state of the ODE </td></tr>
    <tr><td class="paramname">h</td><td>The real step size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74bcfb58dfec609f28f1fa45064fc827" name="a74bcfb58dfec609f28f1fa45064fc827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74bcfb58dfec609f28f1fa45064fc827">&#9670;&nbsp;</a></span>integrate_ode_midpoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt; theoretica::integrate_ode_midpoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;(*)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integrate numerically a differential equation in N unknowns using the midpoint method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function which computes the derivative of the state </td></tr>
    <tr><td class="paramname">s</td><td>The current state of the ODE </td></tr>
    <tr><td class="paramname">h</td><td>The real step size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adcd5fd5128198f53ec484aed09b99542" name="adcd5fd5128198f53ec484aed09b99542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd5fd5128198f53ec484aed09b99542">&#9670;&nbsp;</a></span>integrate_ode_rk4() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt; theoretica::integrate_ode_rk4 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integrate numerically a differential equation in one unknown using Runge-Kutta's method of fourth order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function which computes the derivative of the state </td></tr>
    <tr><td class="paramname">s</td><td>The current state of the ODE </td></tr>
    <tr><td class="paramname">h</td><td>The real step size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a016fb5701cea5c9b53c7aaefd7fc6d00" name="a016fb5701cea5c9b53c7aaefd7fc6d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a016fb5701cea5c9b53c7aaefd7fc6d00">&#9670;&nbsp;</a></span>integrate_ode_rk4() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt; theoretica::integrate_ode_rk4 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;(*)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtheoretica_1_1ode__state.html">ode_state</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integrate numerically a differential equation in N unknowns using Runge-Kutta's method of fourth order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function which computes the derivative of the state </td></tr>
    <tr><td class="paramname">s</td><td>The current state of the ODE </td></tr>
    <tr><td class="paramname">h</td><td>The real step size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad30054ccf81cf93e466c08361e4ff9fb" name="ad30054ccf81cf93e466c08361e4ff9fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad30054ccf81cf93e466c08361e4ff9fb">&#9670;&nbsp;</a></span>integrate_polynomial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = real&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; T &gt; theoretica::integrate_polynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the indefinite integral of a polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The polynomial to integrate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The indefinite polynomial integral </dd></dl>

</div>
</div>
<a id="a88f9a26f1ee40dea3fced3ee7e0c9aa9" name="a88f9a26f1ee40dea3fced3ee7e0c9aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f9a26f1ee40dea3fced3ee7e0c9aa9">&#9670;&nbsp;</a></span>interpolate_chebyshev()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; theoretica::interpolate_chebyshev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the interpolating polynomial of a real function using Chebyshev nodes as sampling points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to interpolate </td></tr>
    <tr><td class="paramname">a</td><td>Lower bound of the interval </td></tr>
    <tr><td class="paramname">b</td><td>Upper bound of the interval </td></tr>
    <tr><td class="paramname">order</td><td>Order of the resulting polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A polynomial of (n - 1) degree interpolating the function through the Chebyshev nodes.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetheoretica.html#af77c5c6195e30df1e423b0922cc0776e" title="Compute the n Chebyshev nodes on a given interval.">chebyshev_nodes</a> </dd>
<dd>
<a class="el" href="namespacetheoretica.html#a9b3f2ff840d6e5dae38dfc1e6176a7be" title="Compute the Lagrange polynomial interpolating a set of points.">lagrange_polynomial</a> </dd></dl>

</div>
</div>
<a id="a9dc2216d71f0d7147b5c0dacdeea80db" name="a9dc2216d71f0d7147b5c0dacdeea80db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dc2216d71f0d7147b5c0dacdeea80db">&#9670;&nbsp;</a></span>interpolate_grid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; theoretica::interpolate_grid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#ad60d62492ac4137c837c50b1fdc8a904">real_function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the interpolating polynomial of a real function on an equidistant point sample. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to interpolate </td></tr>
    <tr><td class="paramname">a</td><td>Lower bound of the interval </td></tr>
    <tr><td class="paramname">b</td><td>Upper bound of the interval </td></tr>
    <tr><td class="paramname">order</td><td>Order of the resulting polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A polynomial of (n - 1) degree interpolating the function </dd></dl>

</div>
</div>
<a id="abcf893a13dda9fd79be929e4dea4a80f" name="abcf893a13dda9fd79be929e4dea4a80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcf893a13dda9fd79be929e4dea4a80f">&#9670;&nbsp;</a></span>inverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a> theoretica::inverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the conjugate of a complex number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22e311a811c0c7e23c30e4496cfbe63d" name="a22e311a811c0c7e23c30e4496cfbe63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22e311a811c0c7e23c30e4496cfbe63d">&#9670;&nbsp;</a></span>is_nan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool theoretica::is_nan </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a generic variable is (equivalent to) a NaN number. </p>
<p >NaN numbers are the only variables which do not compare equal to themselves in floating point operations. This is valid for real types but also for any mathematical structure, as NaNs are used to report failure inside the library. </p>

</div>
</div>
<a id="a68914a563241494dfe7ac42f0462920c" name="a68914a563241494dfe7ac42f0462920c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68914a563241494dfe7ac42f0462920c">&#9670;&nbsp;</a></span>isqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnsignedIntType  = uint64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UnsignedIntType theoretica::isqrt </td>
          <td>(</td>
          <td class="paramtype">UnsignedIntType&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the integer square root of a positive integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A positive integer number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rounded down square root of n A binary search algorithm is used. </dd></dl>

</div>
</div>
<a id="a321928d10b6606c1cba0232a613e6dfe" name="a321928d10b6606c1cba0232a613e6dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a321928d10b6606c1cba0232a613e6dfe">&#9670;&nbsp;</a></span>kronecker_delta()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> T theoretica::kronecker_delta </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Kronecker delta, equals 1 if i is equal to j, 0 otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The first value to compare </td></tr>
    <tr><td class="paramname">j</td><td>The second value to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if i is equal to j, 0 otherwise </dd></dl>

</div>
</div>
<a id="a1180d17fc1d5e33e624efc299319b7bd" name="a1180d17fc1d5e33e624efc299319b7bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1180d17fc1d5e33e624efc299319b7bd">&#9670;&nbsp;</a></span>l1_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::l1_norm </td>
          <td>(</td>
          <td class="paramtype">Vector&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the L1 norm of a vector. </p>
<p >\(L_1(\vec v) = \Sigma_i \ |v_i|\) </p>

</div>
</div>
<a id="ae0dda0991b7f146cc8f53578508fef4f" name="ae0dda0991b7f146cc8f53578508fef4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0dda0991b7f146cc8f53578508fef4f">&#9670;&nbsp;</a></span>l2_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::l2_norm </td>
          <td>(</td>
          <td class="paramtype">Vector&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the L2 norm of a vector. </p>
<p >\(L_2(\vec v) = \sqrt{\Sigma_i \ v_i^2}\) </p>

</div>
</div>
<a id="a9b3f2ff840d6e5dae38dfc1e6176a7be" name="a9b3f2ff840d6e5dae38dfc1e6176a7be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b3f2ff840d6e5dae38dfc1e6176a7be">&#9670;&nbsp;</a></span>lagrange_polynomial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = real&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; T &gt; theoretica::lagrange_polynomial </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; 2, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Lagrange polynomial interpolating a set of points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>The set of n points to interpolate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A polynomial of (n - 1) degree interpolating the points </dd></dl>

</div>
</div>
<a id="acaa95392d9bfc3ddf34f3e82f4b6ae78" name="acaa95392d9bfc3ddf34f3e82f4b6ae78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa95392d9bfc3ddf34f3e82f4b6ae78">&#9670;&nbsp;</a></span>legendre_polynomial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; theoretica::legendre_polynomial </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the nth Legendre polynomial. </p>
<dl class="section note"><dt>Note</dt><dd>The result is not normalized </dd></dl>

</div>
</div>
<a id="ac209c3a6870eb4e610312a7725ccea9b" name="ac209c3a6870eb4e610312a7725ccea9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac209c3a6870eb4e610312a7725ccea9b">&#9670;&nbsp;</a></span>linf_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::linf_norm </td>
          <td>(</td>
          <td class="paramtype">Vector&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Linf norm of a vector. </p>
<p >\(L_{inf}(\vec v) = max(|v_i|)\) </p>

</div>
</div>
<a id="ace32efc4e4b7b555c8cdc340e7adff4a" name="ace32efc4e4b7b555c8cdc340e7adff4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace32efc4e4b7b555c8cdc340e7adff4a">&#9670;&nbsp;</a></span>ln() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a> theoretica::ln </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the complex logarithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a748eca731a8c05226332e5723b7a9d91" name="a748eca731a8c05226332e5723b7a9d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748eca731a8c05226332e5723b7a9d91">&#9670;&nbsp;</a></span>ln() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::ln </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the natural logarithm of x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number bigger than 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The natural logarithm of x</dd></dl>
<p>Domain: (0, +inf] <br  />
On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fyl2x</code> instruction will be used. </p>

</div>
</div>
<a id="adb04217fd0bd9dd23daaa186d3756d1e" name="adb04217fd0bd9dd23daaa186d3756d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb04217fd0bd9dd23daaa186d3756d1e">&#9670;&nbsp;</a></span>log10()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::log10 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the base-10 logarithm of x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number bigger than 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The base-10 logarithm of x</dd></dl>
<p>Domain: (0, +inf] <br  />
On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fyl2x</code> instruction will be used. </p>

</div>
</div>
<a id="abbd0ef7aa0b136fbd1b4579cec14f369" name="abbd0ef7aa0b136fbd1b4579cec14f369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd0ef7aa0b136fbd1b4579cec14f369">&#9670;&nbsp;</a></span>log2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::log2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the binary logarithm of a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number bigger than 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binary logarithm of x</dd></dl>
<p>Domain: (0, +inf] <br  />
On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fyl2x</code> instruction will be used. </p>

</div>
</div>
<a id="a42b0b721edddef75a47581c66048cb7e" name="a42b0b721edddef75a47581c66048cb7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42b0b721edddef75a47581c66048cb7e">&#9670;&nbsp;</a></span>lp_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::lp_norm </td>
          <td>(</td>
          <td class="paramtype">Vector&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Norms. </p>
<p >Compute the Lp norm of a vector. \(L_p(\vec v) = (\Sigma_i \ |v_i|^p)^{1/p}\) </p>

</div>
</div>
<a id="a07569756dda099ecabf425371da6a31d" name="a07569756dda099ecabf425371da6a31d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07569756dda099ecabf425371da6a31d">&#9670;&nbsp;</a></span>max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the greatest number between two real numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
    <tr><td class="paramname">y</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The greatest number between x and y</dd></dl>
<p>If <code>THEORETICA_BRANCHLESS</code> is defined, a branchless implementation will be used </p>

</div>
</div>
<a id="a5e295404d1712fb17851fe105715766e" name="a5e295404d1712fb17851fe105715766e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e295404d1712fb17851fe105715766e">&#9670;&nbsp;</a></span>max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T theoretica::max </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two objects and return the greatest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The first object to compare </td></tr>
    <tr><td class="paramname">y</td><td>The second object to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The greatest between the objects</dd></dl>
<p>The templated T type must have comparison operators. </p>

</div>
</div>
<a id="adeb593b1732cc1d59184ca33c0d82ac8" name="adeb593b1732cc1d59184ca33c0d82ac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeb593b1732cc1d59184ca33c0d82ac8">&#9670;&nbsp;</a></span>maximize_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; theoretica::maximize_grad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>guess</em> = <code><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt;N&gt;(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>gamma</em> = <code><a class="el" href="namespacetheoretica.html#ab33f363492da480d62e2e0b5ad2c4ee9">MINGRAD_GAMMA</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacetheoretica.html#a5ebee50e5a5a80baaa6532a736ce7d55">MINGRAD_TOLERANCE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#acd4ef8ed777e402e2ae0c7f736ba20cb">MINGRAD_MAX_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a local maximum of the given multivariate function using fixed-step gradient descent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to maximize </td></tr>
    <tr><td class="paramname">guess</td><td>The initial guess, defaults to {0, 0} </td></tr>
    <tr><td class="paramname">gamma</td><td>The fixed step size, defaults to MINGRAD_GAMMA </td></tr>
    <tr><td class="paramname">tolerance</td><td>The maximum magnitude of the gradient to stop the algorithm at, defaults to MINGRAD_TOLERANCE. </td></tr>
    <tr><td class="paramname">max_iter</td><td>The maximum number of iterations to perform before stopping execution of the routine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinates of the local maximum </dd></dl>

</div>
</div>
<a id="ac673920f8956ebea402eac4271f551ba" name="ac673920f8956ebea402eac4271f551ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac673920f8956ebea402eac4271f551ba">&#9670;&nbsp;</a></span>min() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the smallest number between two real numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
    <tr><td class="paramname">y</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest number between x and y</dd></dl>
<p>If <code>THEORETICA_BRANCHLESS</code> is defined, a branchless implementation will be used </p>

</div>
</div>
<a id="a70f4122359c1f32ba0741d098a5fbe69" name="a70f4122359c1f32ba0741d098a5fbe69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f4122359c1f32ba0741d098a5fbe69">&#9670;&nbsp;</a></span>min() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T theoretica::min </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two objects and return the greatest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The first object to compare </td></tr>
    <tr><td class="paramname">y</td><td>The second object to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest between the objects</dd></dl>
<p>The templated T type must have comparison operators. </p>

</div>
</div>
<a id="a6c8940cabdea5cdb34d24ba521f22939" name="a6c8940cabdea5cdb34d24ba521f22939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c8940cabdea5cdb34d24ba521f22939">&#9670;&nbsp;</a></span>minimize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; theoretica::minimize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>guess</em> = <code><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt;N&gt;(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use the best available algorithm to find a local minimum of the given multivariate function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to minimize </td></tr>
    <tr><td class="paramname">guess</td><td>The initial guess </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinates of the local minimum, NaN if the algorithm did not converge. </dd></dl>

</div>
</div>
<a id="aa38995aba223210db261b147df9efc1d" name="aa38995aba223210db261b147df9efc1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38995aba223210db261b147df9efc1d">&#9670;&nbsp;</a></span>minimize_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; theoretica::minimize_grad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>guess</em> = <code><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt;N&gt;(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>gamma</em> = <code><a class="el" href="namespacetheoretica.html#ab33f363492da480d62e2e0b5ad2c4ee9">MINGRAD_GAMMA</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacetheoretica.html#a5ebee50e5a5a80baaa6532a736ce7d55">MINGRAD_TOLERANCE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#acd4ef8ed777e402e2ae0c7f736ba20cb">MINGRAD_MAX_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a local minimum of the given multivariate function using fixed-step gradient descent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to minimize </td></tr>
    <tr><td class="paramname">guess</td><td>The initial guess, defaults to {0, 0} </td></tr>
    <tr><td class="paramname">gamma</td><td>The fixed step size, defaults to MINGRAD_GAMMA </td></tr>
    <tr><td class="paramname">tolerance</td><td>The maximum magnitude of the gradient to stop the algorithm at, defaults to MINGRAD_TOLERANCE. </td></tr>
    <tr><td class="paramname">max_iter</td><td>The maximum number of iterations to perform before stopping execution of the routine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinates of the local minimum </dd></dl>

</div>
</div>
<a id="a2c4c98e4f539167c2b5af80fe78fedd5" name="a2c4c98e4f539167c2b5af80fe78fedd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c4c98e4f539167c2b5af80fe78fedd5">&#9670;&nbsp;</a></span>minimize_lingrad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; theoretica::minimize_lingrad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>guess</em> = <code><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt;N&gt;(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespacetheoretica.html#a5ebee50e5a5a80baaa6532a736ce7d55">MINGRAD_TOLERANCE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#acd4ef8ed777e402e2ae0c7f736ba20cb">MINGRAD_MAX_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a local minimum of the given multivariate function using gradient descent with linear search. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to minimize </td></tr>
    <tr><td class="paramname">guess</td><td>The initial guess, defaults to {0, 0} </td></tr>
    <tr><td class="paramname">tolerance</td><td>The maximum magnitude of the gradient to stop the algorithm at, defaults to MINGRAD_TOLERANCE. </td></tr>
    <tr><td class="paramname">max_iter</td><td>The maximum number of iterations to perform before stopping execution of the routine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinates of the local minimum </dd></dl>

</div>
</div>
<a id="a672dbbc0ea824c71d7ca0dc26b346200" name="a672dbbc0ea824c71d7ca0dc26b346200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a672dbbc0ea824c71d7ca0dc26b346200">&#9670;&nbsp;</a></span>mix_mum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::mix_mum </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>MUM bit mixing function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first operand </td></tr>
    <tr><td class="paramname">b</td><td>The second operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca2b51694a7dd4ded3a140f92366aaed" name="aca2b51694a7dd4ded3a140f92366aaed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca2b51694a7dd4ded3a140f92366aaed">&#9670;&nbsp;</a></span>mul_uint128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void theoretica::mul_uint128 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>c_low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>c_high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply two 64-bit integers and store the result in two 64-bit variables, keeping 128 bits of the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first number to multiply </td></tr>
    <tr><td class="paramname">b</td><td>The second number to multiply </td></tr>
    <tr><td class="paramname">c_low</td><td>The variable where to store the lowest 64 bits of the result </td></tr>
    <tr><td class="paramname">c_high</td><td>The variable where to store the highest 64 bits of the result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13248f2e439afdb6f72e0f2c1e79cc55" name="a13248f2e439afdb6f72e0f2c1e79cc55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13248f2e439afdb6f72e0f2c1e79cc55">&#9670;&nbsp;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = real&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> T theoretica::pow </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the n-th power of x (where n is natural) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Any element of a multiplicative algebra </td></tr>
    <tr><td class="paramname">n</td><td>The integer exponent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x to the power n </dd></dl>

</div>
</div>
<a id="a6f12dd8e0fc650fa75c9961e51d1406c" name="a6f12dd8e0fc650fa75c9961e51d1406c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f12dd8e0fc650fa75c9961e51d1406c">&#9670;&nbsp;</a></span>powf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::powf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate x elevated to a real exponent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
    <tr><td class="paramname">a</td><td>A real exponent</td></tr>
  </table>
  </dd>
</dl>
<p>Approximated as \(e^{a ln(|x|) sgn(x)}\) </p>

</div>
</div>
<a id="aa7e523c1cc3621e7cbc1ac0df01913c3" name="aa7e523c1cc3621e7cbc1ac0df01913c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e523c1cc3621e7cbc1ac0df01913c3">&#9670;&nbsp;</a></span>qrand_weyl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::qrand_weyl </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>alpha</em> = <code><a class="el" href="namespacetheoretica.html#a6a6de16e5ee81d340ff91dbadb99edde">INVPHI</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Weyl quasi-random sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the element in the sequence </td></tr>
    <tr><td class="paramname">alpha</td><td>The base of the sequence, defaults to the inverse of the Golden Section</td></tr>
  </table>
  </dd>
</dl>
<p>The Weyl sequence is defined as \(x_n = \{n \alpha\}\), where \(\{ \}\) is the fractional part. </p><dl class="section note"><dt>Note</dt><dd>The alpha argument should be an irrational number. </dd></dl>

</div>
</div>
<a id="ac1d4be50bf77c6b368c94bb627305224" name="ac1d4be50bf77c6b368c94bb627305224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1d4be50bf77c6b368c94bb627305224">&#9670;&nbsp;</a></span>qrand_weyl2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a78450ba4db2e132788cc0566b22848b9">vec2</a> theoretica::qrand_weyl2 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>0.7548776662466927</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Weyl quasi-random sequence in 2 dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the element in the sequence </td></tr>
    <tr><td class="paramname">alpha</td><td>The base of the sequence</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The alpha argument should be an irrational number. </dd></dl>

</div>
</div>
<a id="ab52264b77696ac2b3b8a78ed540f092d" name="ab52264b77696ac2b3b8a78ed540f092d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab52264b77696ac2b3b8a78ed540f092d">&#9670;&nbsp;</a></span>qrand_weyl_multi()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; theoretica::qrand_weyl_multi </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Weyl quasi-random sequence in N dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the element in the sequence </td></tr>
    <tr><td class="paramname">alpha</td><td>The base of the sequence</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The alpha argument should be an irrational number. </dd></dl>

</div>
</div>
<a id="a6c5001951408c716ce4e6414cc45f420" name="a6c5001951408c716ce4e6414cc45f420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c5001951408c716ce4e6414cc45f420">&#9670;&nbsp;</a></span>qrand_weyl_recurr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::qrand_weyl_recurr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>prev</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>alpha</em> = <code><a class="el" href="namespacetheoretica.html#a6a6de16e5ee81d340ff91dbadb99edde">INVPHI</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Weyl quasi-random sequence (computed with recurrence relation) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prev</td><td>The previously computed value </td></tr>
    <tr><td class="paramname">alpha</td><td>The base of the sequence, defaults to the inverse of the Golden Section</td></tr>
  </table>
  </dd>
</dl>
<p>If no arguments are provided or prev is zero, the function computes the first element of the Weyl sequence associated to the parameter alpha. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetheoretica.html#aa7e523c1cc3621e7cbc1ac0df01913c3" title="Weyl quasi-random sequence.">qrand_weyl</a> </dd></dl>

</div>
</div>
<a id="a286f4d2ae42de1965c86c999927f128b" name="a286f4d2ae42de1965c86c999927f128b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a286f4d2ae42de1965c86c999927f128b">&#9670;&nbsp;</a></span>radians()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::radians </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>degrees</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert degrees to radians. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degrees</td><td>An angle in degrees </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted angle in radians</dd></dl>
<p>The <code>DEG2RAD</code> scalar factor is used. </p>

</div>
</div>
<a id="a473df88a9edd9ccc8dcf03665591575b" name="a473df88a9edd9ccc8dcf03665591575b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a473df88a9edd9ccc8dcf03665591575b">&#9670;&nbsp;</a></span>rand_cauchy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_cauchy </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper for rand_cauchy(real, real, PRNG) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>The parameters of the distribution </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36a41f7dda7d0ad8cc8a4559afcf2ad7" name="a36a41f7dda7d0ad8cc8a4559afcf2ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a41f7dda7d0ad8cc8a4559afcf2ad7">&#9670;&nbsp;</a></span>rand_congruential() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::rand_congruential </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Congruential pseudorandom number generation algorithm (wrapper) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The current recurrence value of the algorithm (x_n) </td></tr>
    <tr><td class="paramname">state</td><td>A vector containing the state of the algorithm (a, c, m in this order) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next generated pseudorandom number</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetheoretica.html#ab1025a8b933cfe7077936c4be27971c1" title="Congruential pseudorandom number generation algorithm.">rand_congruential</a> </dd></dl>

</div>
</div>
<a id="ab1025a8b933cfe7077936c4be27971c1" name="ab1025a8b933cfe7077936c4be27971c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1025a8b933cfe7077936c4be27971c1">&#9670;&nbsp;</a></span>rand_congruential() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::rand_congruential </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>a</em> = <code>48271</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>c</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>m</em> = <code>((uint64_t)&#160;1&#160;&lt;&lt;&#160;31)&#160;-&#160;1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Congruential pseudorandom number generation algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The current recurrence value of the algorithm (x_n) </td></tr>
    <tr><td class="paramname">a</td><td>The multiplier term </td></tr>
    <tr><td class="paramname">c</td><td>The increment term </td></tr>
    <tr><td class="paramname">m</td><td>The modulus term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next generated pseudorandom number</dd></dl>
<p>The congruential generator is defined by the recurrence formula \(x_{n+1} = (a x_n + c) mod m\) <br  />
If no parameters are passed, the generator defaults to a = 48271, c = 0, m = (1 &lt;&lt; 31) - 1. </p>

</div>
</div>
<a id="aeaab56ddec7d197600964cb78ada9a86" name="aeaab56ddec7d197600964cb78ada9a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaab56ddec7d197600964cb78ada9a86">&#9670;&nbsp;</a></span>rand_dist_tac()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_dist_tac </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a5955d73b5602813dca8d4d64bed8466d">stat_function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#a3299f783527ae72a24c832a7b1cd8ef8">MAX_TRYANDCATCH_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a pseudorandom value following any probability distribution function using the Try-and-Catch (rejection) algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A probability distribution function </td></tr>
    <tr><td class="paramname">theta</td><td>The parameters of the pdf </td></tr>
    <tr><td class="paramname">x1</td><td>The left extreme of the rectangle </td></tr>
    <tr><td class="paramname">x2</td><td>The right extreme of the rectangle </td></tr>
    <tr><td class="paramname">y1</td><td>The lower extreme of the rectangle </td></tr>
    <tr><td class="paramname">y2</td><td>The upper extreme of the rectangle </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> to use for number generation </td></tr>
    <tr><td class="paramname">max_iter</td><td>The maximum number of failed generations before stopping execution (defaults to MAX_TRYANDCATCH_ITER) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A real number following the given pdf</dd></dl>
<p>Random real numbers are generated inside a rectangle defined by x1, x2, y1 and y2 following a uniform distribution. Only numbers below the pdf are returned. </p>

</div>
</div>
<a id="aa2e6165f6c783179d1b3c2e321b3e7d4" name="aa2e6165f6c783179d1b3c2e321b3e7d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e6165f6c783179d1b3c2e321b3e7d4">&#9670;&nbsp;</a></span>rand_exponential()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_exponential </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper for rand_exponential(real, PRNG) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>The parameters of the distribution </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad2c1865b7a5639ed82643a069554e3d" name="aad2c1865b7a5639ed82643a069554e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad2c1865b7a5639ed82643a069554e3d">&#9670;&nbsp;</a></span>rand_gaussian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_gaussian </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper for rand_gaussian(real, real, PRNG) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>The parameters of the distribution </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91d0c9531b268c00e759cb571422e01f" name="a91d0c9531b268c00e759cb571422e01f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91d0c9531b268c00e759cb571422e01f">&#9670;&nbsp;</a></span>rand_gaussian_boxmuller()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_gaussian_boxmuller </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a random number following a Gaussian distribution using the Box-Muller method. </p>
<dl class="section note"><dt>Note</dt><dd>This function may not be thread-safe as it uses static variables to keep track of spare generated values. </dd></dl>

</div>
</div>
<a id="a8c36b22d9b1f9f2beeab1c7be35fe8b3" name="a8c36b22d9b1f9f2beeab1c7be35fe8b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c36b22d9b1f9f2beeab1c7be35fe8b3">&#9670;&nbsp;</a></span>rand_gaussian_clt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_gaussian_clt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a random number in a range following a Gaussian distribution by exploiting the Central Limit Theorem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mean</td><td>The mean of the target distribution </td></tr>
    <tr><td class="paramname">sigma</td><td>The sigma of the target distribution </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a></td></tr>
  </table>
  </dd>
</dl>
<p>Exactly 12 real numbers in a range are generated and the mean is computed to get a single real number following (asymptotically) a Gaussian distribution. </p>

</div>
</div>
<a id="af2b8d1fc98c8429d4b342e860cab6ed1" name="af2b8d1fc98c8429d4b342e860cab6ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b8d1fc98c8429d4b342e860cab6ed1">&#9670;&nbsp;</a></span>rand_gaussian_clt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_gaussian_clt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a random number in a range following a Gaussian distribution by exploiting the Central Limit Theorem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mean</td><td>The mean of the target distribution </td></tr>
    <tr><td class="paramname">sigma</td><td>The sigma of the target distribution </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
    <tr><td class="paramname">N</td><td>The number of random numbers to generate</td></tr>
  </table>
  </dd>
</dl>
<p>Many real numbers in a range are generated and the mean is computed to get a single real number following (asymptotically) a Gaussian distribution.</p>
<dl class="section note"><dt>Note</dt><dd>This function uses a square root (th::sqrt) to rescale the output for variable N, the constant N implementation has better performance. </dd></dl>

</div>
</div>
<a id="ac8bdf0dc89459fedaf6950c0f9b96df5" name="ac8bdf0dc89459fedaf6950c0f9b96df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8bdf0dc89459fedaf6950c0f9b96df5">&#9670;&nbsp;</a></span>rand_gaussian_polar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_gaussian_polar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a random number following a Gaussian distribution using Marsaglia's polar method. </p>
<dl class="section note"><dt>Note</dt><dd>This function may not be thread-safe as it uses static variables to keep track of spare generated values. </dd></dl>

</div>
</div>
<a id="ae66a655f57ef0f6e436dfc03e800585b" name="ae66a655f57ef0f6e436dfc03e800585b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66a655f57ef0f6e436dfc03e800585b">&#9670;&nbsp;</a></span>rand_pareto()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_pareto </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper for rand_pareto(real, real, PRNG) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>The parameters of the distribution </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a012d14c9ef85d6f3028bf8ceb1008787" name="a012d14c9ef85d6f3028bf8ceb1008787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a012d14c9ef85d6f3028bf8ceb1008787">&#9670;&nbsp;</a></span>rand_rayleigh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_rayleigh </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper for rand_rayleigh(real, PRNG) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>The parameters of the distribution </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a058181f973ba2744704e6c6211477a35" name="a058181f973ba2744704e6c6211477a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058181f973ba2744704e6c6211477a35">&#9670;&nbsp;</a></span>rand_splitmix64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::rand_splitmix64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SplitMix64 pseudorandom number generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The 64-bit state of the algorithm</td></tr>
  </table>
  </dd>
</dl>
<p>Adapted from the reference implementation by Sebastiano Vigna </p>

</div>
</div>
<a id="ad198dee1300488d1b3e51767d62beedf" name="ad198dee1300488d1b3e51767d62beedf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad198dee1300488d1b3e51767d62beedf">&#9670;&nbsp;</a></span>rand_splitmix64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::rand_splitmix64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SplitMix64 pseudorandom number generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The 64-bit state of the algorithm </td></tr>
    <tr><td class="paramname">p</td><td>Dummy variable (needed for function signature) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7e77a1836e1b966cdbb0934d5ebbbf2" name="ad7e77a1836e1b966cdbb0934d5ebbbf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e77a1836e1b966cdbb0934d5ebbbf2">&#9670;&nbsp;</a></span>rand_uniform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_uniform </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper for rand_uniform(real, real, PRNG) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>The parameters of the distribution </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a35e29644875a5421b3ac4d7203c28a" name="a6a35e29644875a5421b3ac4d7203c28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a35e29644875a5421b3ac4d7203c28a">&#9670;&nbsp;</a></span>rand_uniform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_uniform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="namespacetheoretica.html#a0e48eab9ce5928d0c754a40ddb2d068f">RAND_REAL_PREC</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a pseudorandom real number in [a, b] using a preexisting generator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The lower extreme of the interval </td></tr>
    <tr><td class="paramname">b</td><td>The higher extreme of the interval </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized pseudorandom number generator </td></tr>
    <tr><td class="paramname">prec</td><td>Precision parameters for the normalization, defaults to RAND_REAL_PREC.</td></tr>
  </table>
  </dd>
</dl>
<p>The algorithm generates a random integer number, computes its modulus and divides it by prec: \(x = \frac{(n mod p)}{2^p}\), where n is the random integer and p is the prec parameter </p>

</div>
</div>
<a id="a470e255aed45a7dba74af4af68b31d0d" name="a470e255aed45a7dba74af4af68b31d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a470e255aed45a7dba74af4af68b31d0d">&#9670;&nbsp;</a></span>rand_wyrand() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::rand_wyrand </td>
          <td>(</td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wyrand pseudorandom number generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>The (changing) seed of the algorithm </td></tr>
    <tr><td class="paramname">p0</td><td>Additive constant (ideally a large prime number) </td></tr>
    <tr><td class="paramname">p1</td><td>Mask for the algorithm</td></tr>
  </table>
  </dd>
</dl>
<p>Algorithm by Yi Wang </p>

</div>
</div>
<a id="a5deb3df62eb53ec187a4660d42d8d5f1" name="a5deb3df62eb53ec187a4660d42d8d5f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5deb3df62eb53ec187a4660d42d8d5f1">&#9670;&nbsp;</a></span>rand_wyrand() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::rand_wyrand </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wyrand pseudorandom number generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Dummy variable </td></tr>
    <tr><td class="paramname">p</td><td>Algorithm parameters</td></tr>
  </table>
  </dd>
</dl>
<p>p[0] is the initial seed, p[1] a large prime number and p[2] is the bit mask. </p>

</div>
</div>
<a id="aed6faedb3d913a589365b108f5ec304e" name="aed6faedb3d913a589365b108f5ec304e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed6faedb3d913a589365b108f5ec304e">&#9670;&nbsp;</a></span>rand_xoshiro() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::rand_xoshiro </td>
          <td>(</td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Xoshiro256++ pseudorandom number generation algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Dummy parameter (needed for function signature) </td></tr>
    <tr><td class="paramname">state</td><td>The four 64-bit integer state of the algorithm</td></tr>
  </table>
  </dd>
</dl>
<p>Adapted from the reference implementation by Sebastiano Vigna </p>

</div>
</div>
<a id="a13b30362a1d08c8522c5297efd6f4a47" name="a13b30362a1d08c8522c5297efd6f4a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b30362a1d08c8522c5297efd6f4a47">&#9670;&nbsp;</a></span>rand_xoshiro() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::rand_xoshiro </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Xoshiro256++ pseudorandom number generation algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Dummy parameter (needed for function signature) </td></tr>
    <tr><td class="paramname">state</td><td>The four 64-bit integer state of the algorithm </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac984b5416b7e1b86cb772f735d4cb42d" name="ac984b5416b7e1b86cb772f735d4cb42d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac984b5416b7e1b86cb772f735d4cb42d">&#9670;&nbsp;</a></span>rms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rms </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the quadratic mean (Root Mean Square) of a set of values m_q = sqrt(x1^2 + x2^2 + ...) </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetheoretica.html#a9e5247854c4b50f7ac1d71e7d23a9ef4" title="Compute the quadratic mean (Root Mean Square) of a set of values m_q = sqrt(x1^2 + x2^2 + ....">quadratic_mean</a> </dd></dl>

</div>
</div>
<a id="acf52f04c3a1cefbb9dabab21cac0abbb" name="acf52f04c3a1cefbb9dabab21cac0abbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf52f04c3a1cefbb9dabab21cac0abbb">&#9670;&nbsp;</a></span>root()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::root </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the n-th root of x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
    <tr><td class="paramname">n</td><td>The root number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The n-th real root of x</dd></dl>
<p>The Newton-Raphson method is used, limited by the <code>THEORETICA_MAX_NEWTON_ITER</code> macro constant. </p>

</div>
</div>
<a id="ad61e39abd4fd4cd8cd83add5d0752e2f" name="ad61e39abd4fd4cd8cd83add5d0752e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad61e39abd4fd4cd8cd83add5d0752e2f">&#9670;&nbsp;</a></span>sgn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int theoretica::sgn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the sign of x (1 if positive, -1 if negative, 0 if null) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sign of x </dd></dl>

</div>
</div>
<a id="a7a76685197faa15403e24b836830cf5d" name="a7a76685197faa15403e24b836830cf5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a76685197faa15403e24b836830cf5d">&#9670;&nbsp;</a></span>sigmoid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::sigmoid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the sigmoid function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sigmoid function for x defined as \(\frac{1}{1 + e^{-x}}\) </dd></dl>

</div>
</div>
<a id="a1b6f6e44aa2d8dabd4a2710e313f65d8" name="a1b6f6e44aa2d8dabd4a2710e313f65d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6f6e44aa2d8dabd4a2710e313f65d8">&#9670;&nbsp;</a></span>sin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a> theoretica::sin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computer the complex sine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c2ea0b1258dfe34df321901707d1808" name="a2c2ea0b1258dfe34df321901707d1808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c2ea0b1258dfe34df321901707d1808">&#9670;&nbsp;</a></span>sin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::sin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the sine of a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>An angle in <b>radians</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sine of x</dd></dl>
<p>On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fsin</code> instruction will be used. </p>

</div>
</div>
<a id="a1efe3bd7ff87719aab92b67cec535096" name="a1efe3bd7ff87719aab92b67cec535096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1efe3bd7ff87719aab92b67cec535096">&#9670;&nbsp;</a></span>sinc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::sinc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the normalized sinc function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The normalized sinc function for x defined as \(\frac{sin(\pi x)}{\pi x}\) </dd></dl>

</div>
</div>
<a id="a0650ea8e1435cc518e960bfcecf5b66e" name="a0650ea8e1435cc518e960bfcecf5b66e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0650ea8e1435cc518e960bfcecf5b66e">&#9670;&nbsp;</a></span>sinh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::sinh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the hyperbolic sine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic sine of x</dd></dl>
<p>\(sinh = \frac{e^x - e^{-x}}{2}\) </p>

</div>
</div>
<a id="ab5759776d0fbb1355ee30b05ff7dc854" name="ab5759776d0fbb1355ee30b05ff7dc854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5759776d0fbb1355ee30b05ff7dc854">&#9670;&nbsp;</a></span>sphere_inversion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, T &gt; theoretica::sphere_inversion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em> = <code><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt;N,&#160;T&gt;(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>r</em> = <code>T(1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sphere inversion of a point with respect to a sphere of radius r centered at a point c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The vector to transform </td></tr>
    <tr><td class="paramname">c</td><td>The center of the sphere </td></tr>
    <tr><td class="paramname">r</td><td>The radius of the sphere </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a366f1e5bb803f8fd91eb4776ea382d7b" name="a366f1e5bb803f8fd91eb4776ea382d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366f1e5bb803f8fd91eb4776ea382d7b">&#9670;&nbsp;</a></span>sphere_inversion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector theoretica::sphere_inversion </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>c</em> = <code>Vector(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>r</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sphere inversion of a point with respect to a sphere of radius r centered at a point c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The vector to transform </td></tr>
    <tr><td class="paramname">c</td><td>The center of the sphere </td></tr>
    <tr><td class="paramname">r</td><td>The radius of the sphere </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f593debadf5736178434aa3fe476a5c" name="a0f593debadf5736178434aa3fe476a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f593debadf5736178434aa3fe476a5c">&#9670;&nbsp;</a></span>sqrt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a> theoretica::sqrt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the complex square root. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2e4cf02f9bcb4caf5371ee05d67df8d" name="aa2e4cf02f9bcb4caf5371ee05d67df8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e4cf02f9bcb4caf5371ee05d67df8d">&#9670;&nbsp;</a></span>sqrt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::sqrt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the square root of a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The square root of x</dd></dl>
<p>Domain: [0, +inf] <br  />
The Newton-Raphson algorithm, optimized for the square root and limited by the <code>THEORETICA_MAX_NEWTON_ITER</code> macro constant, is used. Domain reduction to [0, 1] is applied to ensure convergence of the algorithm. On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fsqrt</code> instruction will be used. </p>

</div>
</div>
<a id="a9d09bcf107dc6230badf2b29e25ffcad" name="a9d09bcf107dc6230badf2b29e25ffcad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d09bcf107dc6230badf2b29e25ffcad">&#9670;&nbsp;</a></span>square() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a> theoretica::square </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the square of a complex number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a726a5e18c863dc41040f5df134553fa9" name="a726a5e18c863dc41040f5df134553fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726a5e18c863dc41040f5df134553fa9">&#9670;&nbsp;</a></span>square() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="constants_8h.html#aa0d72dcb7db38b3577234c144089a71a">TH_CONSTEXPR</a> <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::square </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the square of a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The square of x</dd></dl>
<p>Domain: [-inf, +inf] </p>

</div>
</div>
<a id="a3b0a5c7fbe93408ce58d40859bab3365" name="a3b0a5c7fbe93408ce58d40859bab3365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0a5c7fbe93408ce58d40859bab3365">&#9670;&nbsp;</a></span>sturm_liouville()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::sturm_liouville </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1dual.html">dual</a>(*)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; M, <a class="el" href="classtheoretica_1_1dual.html">dual</a> &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1dual.html">dual</a>(*)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; M, <a class="el" href="classtheoretica_1_1dual.html">dual</a> &gt;)&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; M &gt;&#160;</td>
          <td class="paramname"><em>eta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Sturm-Liouville operator on a generic function of the form \(f: \mathbb{R}^{2N} \rightarrow \mathbb{R}\) with respect to a given Hamiltonian function of the form \(H: \mathbb{R}^{2N} \rightarrow \mathbb{R}\) where the first N arguments are the coordinates in phase space and the last N arguments are the conjugate momenta, for a given point in phase space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to apply the operator to </td></tr>
    <tr><td class="paramname">H</td><td>The Hamiltonian </td></tr>
    <tr><td class="paramname">eta</td><td>A vector containing M = 2N elements, where the first N elements are the coordinates and the last N elements are the conjugate momenta. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc57357e424703aa6ea643697c2f6d24" name="abc57357e424703aa6ea643697c2f6d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc57357e424703aa6ea643697c2f6d24">&#9670;&nbsp;</a></span>tan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a> theoretica::tan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the complex tangent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe9d9a32dc2c9f00de35c1b1a49b218e" name="abe9d9a32dc2c9f00de35c1b1a49b218e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9d9a32dc2c9f00de35c1b1a49b218e">&#9670;&nbsp;</a></span>tan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::tan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the tangent of x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>An angle in <b>radians</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tangent of x</dd></dl>
<p>On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fsincos</code> instruction will be used. </p>

</div>
</div>
<a id="aaf6b8fc4bb2609507cd1fae0f7d6c8a7" name="aaf6b8fc4bb2609507cd1fae0f7d6c8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf6b8fc4bb2609507cd1fae0f7d6c8a7">&#9670;&nbsp;</a></span>tanh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::tanh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the hyperbolic tangent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic tangent of x </dd></dl>

</div>
</div>
<a id="a2a3acaf39bd4f7e9c87e1fb72768de32" name="a2a3acaf39bd4f7e9c87e1fb72768de32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3acaf39bd4f7e9c87e1fb72768de32">&#9670;&nbsp;</a></span>tss()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::tss </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total sum of squares (TSS) Computed as sum(square(x_i - x_mean)) </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetheoretica.html#ad0857f4b940f5790cd733317780b8ad3" title="Total sum of squares (TSS) Computed as sum(square(x_i - x_mean))">total_sum_squares</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacetheoretica.html">theoretica</a></li>
    <li class="footer">Generated on Sat Sep 24 2022 17:38:03 for Theoretica by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
