<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Theoretica: theoretica Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Theoretica
   </div>
   <div id="projectbrief">A C++ numerical and automatic mathematical library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacetheoretica.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">theoretica Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Main namespace of the library which contains all functions and objects.  
<a href="namespacetheoretica.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1complex.html">complex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex number in algebraic form \(a + ib\).  <a href="classtheoretica_1_1complex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1dual.html">dual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dual number class.  <a href="classtheoretica_1_1dual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1dual2.html">dual2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Second order dual number class.  <a href="classtheoretica_1_1dual2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1mat.html">mat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic matrix with real entries.  <a href="classtheoretica_1_1mat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multidual number algebra for functions of the form \(f: \mathbb{R}^n \rightarrow \mathbb{R}\).  <a href="classtheoretica_1_1multidual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1phasor.html">phasor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex number in exponential form \(\rho e^{i \theta}\).  <a href="classtheoretica_1_1phasor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A polynomial of arbitrary order.  <a href="classtheoretica_1_1polynomial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pseudorandom number generator.  <a href="classtheoretica_1_1_p_r_n_g.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1quat.html">quat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quaternion in the form \(a + bi + cj + dk\), stored as \((a + \vec v)\) where \(a \in \mathbb{R}\) and \(\vec v \in \mathbb{R}^3\).  <a href="classtheoretica_1_1quat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1ratio.html">ratio</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">representing a ratio between two objects, like a fraction or a rational polynomial.  <a href="classtheoretica_1_1ratio.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheoretica_1_1vec.html">vec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An N-dimensional vector of T type elements.  <a href="classtheoretica_1_1vec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a33850a221dc370e7a23083dd94a9abed"><td class="memItemLeft" align="right" valign="top"><a id="a33850a221dc370e7a23083dd94a9abed" name="a33850a221dc370e7a23083dd94a9abed"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>mat2</b> = <a class="el" href="classtheoretica_1_1mat.html">mat</a>&lt; 2, 2 &gt;</td></tr>
<tr class="memdesc:a33850a221dc370e7a23083dd94a9abed"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2x2 matrix with real entries. <br /></td></tr>
<tr class="separator:a33850a221dc370e7a23083dd94a9abed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2899e9929670cbd58f39d6f1642ce19"><td class="memItemLeft" align="right" valign="top"><a id="ae2899e9929670cbd58f39d6f1642ce19" name="ae2899e9929670cbd58f39d6f1642ce19"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>mat3</b> = <a class="el" href="classtheoretica_1_1mat.html">mat</a>&lt; 3, 3 &gt;</td></tr>
<tr class="memdesc:ae2899e9929670cbd58f39d6f1642ce19"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3x3 matrix with real entries. <br /></td></tr>
<tr class="separator:ae2899e9929670cbd58f39d6f1642ce19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28e3d5a1e0743ea34a6c627c47b421b"><td class="memItemLeft" align="right" valign="top"><a id="ae28e3d5a1e0743ea34a6c627c47b421b" name="ae28e3d5a1e0743ea34a6c627c47b421b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>mat4</b> = <a class="el" href="classtheoretica_1_1mat.html">mat</a>&lt; 4, 4 &gt;</td></tr>
<tr class="memdesc:ae28e3d5a1e0743ea34a6c627c47b421b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 4x4 matrix with real entries. <br /></td></tr>
<tr class="separator:ae28e3d5a1e0743ea34a6c627c47b421b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78450ba4db2e132788cc0566b22848b9"><td class="memItemLeft" align="right" valign="top"><a id="a78450ba4db2e132788cc0566b22848b9" name="a78450ba4db2e132788cc0566b22848b9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>vec2</b> = <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; 2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;</td></tr>
<tr class="memdesc:a78450ba4db2e132788cc0566b22848b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2-dimensional vector with real elements. <br /></td></tr>
<tr class="separator:a78450ba4db2e132788cc0566b22848b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9580d98118f2e1692c1f5d6dbf3ea5"><td class="memItemLeft" align="right" valign="top"><a id="a3a9580d98118f2e1692c1f5d6dbf3ea5" name="a3a9580d98118f2e1692c1f5d6dbf3ea5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>vec3</b> = <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; 3, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;</td></tr>
<tr class="memdesc:a3a9580d98118f2e1692c1f5d6dbf3ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3-dimensional vector with real elements. <br /></td></tr>
<tr class="separator:a3a9580d98118f2e1692c1f5d6dbf3ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b773a1d88bcfb2a577b25224fe5477"><td class="memItemLeft" align="right" valign="top"><a id="aa5b773a1d88bcfb2a577b25224fe5477" name="aa5b773a1d88bcfb2a577b25224fe5477"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>vec4</b> = <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; 4, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;</td></tr>
<tr class="memdesc:aa5b773a1d88bcfb2a577b25224fe5477"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 4-dimensional vector with real elements. <br /></td></tr>
<tr class="separator:aa5b773a1d88bcfb2a577b25224fe5477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049966946220f1f7e5eae57293703066"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> = double</td></tr>
<tr class="memdesc:a049966946220f1f7e5eae57293703066"><td class="mdescLeft">&#160;</td><td class="mdescRight">A real number, defined as a floating point type.  <a href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">More...</a><br /></td></tr>
<tr class="separator:a049966946220f1f7e5eae57293703066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d24f1c0c8357b26e2ea168b80eabeb"><td class="memItemLeft" align="right" valign="top"><a id="a55d24f1c0c8357b26e2ea168b80eabeb" name="a55d24f1c0c8357b26e2ea168b80eabeb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>real_function</b> = <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>)</td></tr>
<tr class="memdesc:a55d24f1c0c8357b26e2ea168b80eabeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointer to a real function. <br /></td></tr>
<tr class="separator:a55d24f1c0c8357b26e2ea168b80eabeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a59298cc8c996dcc372b55cc74fea43"><td class="memItemLeft" align="right" valign="top"><a id="a5a59298cc8c996dcc372b55cc74fea43" name="a5a59298cc8c996dcc372b55cc74fea43"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>complex_function</b> = <a class="el" href="classtheoretica_1_1complex.html">complex</a>(*)(<a class="el" href="classtheoretica_1_1complex.html">complex</a>)</td></tr>
<tr class="memdesc:a5a59298cc8c996dcc372b55cc74fea43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointer to a complex function. <br /></td></tr>
<tr class="separator:a5a59298cc8c996dcc372b55cc74fea43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007564925b46b1a8a4038ad371e9052b"><td class="memItemLeft" align="right" valign="top"><a id="a007564925b46b1a8a4038ad371e9052b" name="a007564925b46b1a8a4038ad371e9052b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>stat_function</b> = <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;)</td></tr>
<tr class="memdesc:a007564925b46b1a8a4038ad371e9052b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointer to a statistical function. <br /></td></tr>
<tr class="separator:a007564925b46b1a8a4038ad371e9052b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a50102b320dcdc6a61e5a15234327a7"><td class="memItemLeft" align="right" valign="top"><a id="a9a50102b320dcdc6a61e5a15234327a7" name="a9a50102b320dcdc6a61e5a15234327a7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>vec_buff</b> = std::vector&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;</td></tr>
<tr class="memdesc:a9a50102b320dcdc6a61e5a15234327a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamically allocated variable-size container Defined by default as an alias for <code>std::vector&lt;real&gt;</code> <br /></td></tr>
<tr class="separator:a9a50102b320dcdc6a61e5a15234327a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc230dfc9709da95a25790f260f0b95c"><td class="memItemLeft" align="right" valign="top"><a id="afc230dfc9709da95a25790f260f0b95c" name="afc230dfc9709da95a25790f260f0b95c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>rational_polynomial</b> = <a class="el" href="classtheoretica_1_1ratio.html">ratio</a>&lt; <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;, <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &gt;</td></tr>
<tr class="memdesc:afc230dfc9709da95a25790f260f0b95c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A rational polynomial of real coefficients. <br /></td></tr>
<tr class="separator:afc230dfc9709da95a25790f260f0b95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f8bd44356f8184466e4cc0d6986fe5"><td class="memItemLeft" align="right" valign="top"><a id="a99f8bd44356f8184466e4cc0d6986fe5" name="a99f8bd44356f8184466e4cc0d6986fe5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pseudorandom_function</b> = uint64_t(*)(uint64_t, std::vector&lt; uint64_t &gt; &amp;)</td></tr>
<tr class="memdesc:a99f8bd44356f8184466e4cc0d6986fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pseudorandom function pointer. <br /></td></tr>
<tr class="separator:a99f8bd44356f8184466e4cc0d6986fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a93838376629bab0a3f0b1a933178300d"><td class="memItemLeft" align="right" valign="top"><a id="a93838376629bab0a3f0b1a933178300d" name="a93838376629bab0a3f0b1a933178300d"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a93838376629bab0a3f0b1a933178300d">UMATH_ERRCODE</a> { <br />
&#160;&#160;<b>NO_ERROR</b> = 0x00
, <b>DIV_BY_ZERO</b> = 0x01
, <b>OUT_OF_DOMAIN</b> = 0x02
, <b>OUT_OF_RANGE</b> = 0x04
, <br />
&#160;&#160;<b>IMPOSSIBLE_OPERATION</b> = 0x08
, <b>NO_ALGO_CONVERGENCE</b> = 0x10
, <b>INVALID_ARGUMENT</b> = 0x20
<br />
 }</td></tr>
<tr class="memdesc:a93838376629bab0a3f0b1a933178300d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Math error enumeration. <br /></td></tr>
<tr class="separator:a93838376629bab0a3f0b1a933178300d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a329afffbc3c9e07e77e941d0f70d7467"><td class="memTemplParams" colspan="2"><a id="a329afffbc3c9e07e77e941d0f70d7467" name="a329afffbc3c9e07e77e941d0f70d7467"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a329afffbc3c9e07e77e941d0f70d7467"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>commuter</b> (T A, T B)</td></tr>
<tr class="memdesc:a329afffbc3c9e07e77e941d0f70d7467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ring commute of two elements A and B \([A, B] = AB - BA\). <br /></td></tr>
<tr class="separator:a329afffbc3c9e07e77e941d0f70d7467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46133a50196ddb171e0cf6a16321c92c"><td class="memTemplParams" colspan="2"><a id="a46133a50196ddb171e0cf6a16321c92c" name="a46133a50196ddb171e0cf6a16321c92c"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a46133a50196ddb171e0cf6a16321c92c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>solve</b> (<a class="el" href="classtheoretica_1_1mat.html">mat</a>&lt; N, N &gt; A, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; b)</td></tr>
<tr class="memdesc:a46133a50196ddb171e0cf6a16321c92c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a linear system. <br /></td></tr>
<tr class="separator:a46133a50196ddb171e0cf6a16321c92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a702b5e6317a8cb92da28782d857ddc47"><td class="memTemplParams" colspan="2"><a id="a702b5e6317a8cb92da28782d857ddc47" name="a702b5e6317a8cb92da28782d857ddc47"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a702b5e6317a8cb92da28782d857ddc47"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1mat.html">mat</a>&lt; N, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>solve</b> (<a class="el" href="classtheoretica_1_1mat.html">mat</a>&lt; N, N &gt; A, <a class="el" href="classtheoretica_1_1mat.html">mat</a>&lt; N, N &gt; B)</td></tr>
<tr class="memdesc:a702b5e6317a8cb92da28782d857ddc47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a linear system. <br /></td></tr>
<tr class="separator:a702b5e6317a8cb92da28782d857ddc47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac604670091580b82aa14b5c64d3d5121"><td class="memItemLeft" align="right" valign="top"><a id="ac604670091580b82aa14b5c64d3d5121" name="ac604670091580b82aa14b5c64d3d5121"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>distance</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> v1, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> v2)</td></tr>
<tr class="memdesc:ac604670091580b82aa14b5c64d3d5121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the (Euclidian) distance between two values. <br /></td></tr>
<tr class="separator:ac604670091580b82aa14b5c64d3d5121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf768724a71b849551b26b3fe55fe2b"><td class="memTemplParams" colspan="2"><a id="acaf768724a71b849551b26b3fe55fe2b" name="acaf768724a71b849551b26b3fe55fe2b"></a>
template&lt;unsigned int N, typename T &gt; </td></tr>
<tr class="memitem:acaf768724a71b849551b26b3fe55fe2b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>distance</b> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, T &gt; v1, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, T &gt; v2)</td></tr>
<tr class="memdesc:acaf768724a71b849551b26b3fe55fe2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the distance between two points. <br /></td></tr>
<tr class="separator:acaf768724a71b849551b26b3fe55fe2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee450a2e1c398352ccfc48cc5fe115ce"><td class="memTemplParams" colspan="2">template&lt;unsigned int N, typename T &gt; </td></tr>
<tr class="memitem:aee450a2e1c398352ccfc48cc5fe115ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aee450a2e1c398352ccfc48cc5fe115ce">lp_norm</a> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, T &gt; v, unsigned int p)</td></tr>
<tr class="memdesc:aee450a2e1c398352ccfc48cc5fe115ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Lp norm of a vector.  <a href="namespacetheoretica.html#aee450a2e1c398352ccfc48cc5fe115ce">More...</a><br /></td></tr>
<tr class="separator:aee450a2e1c398352ccfc48cc5fe115ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8981a9c3a9fb8084b2c4ab93a9b09a3b"><td class="memTemplParams" colspan="2">template&lt;unsigned int N, typename T &gt; </td></tr>
<tr class="memitem:a8981a9c3a9fb8084b2c4ab93a9b09a3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a8981a9c3a9fb8084b2c4ab93a9b09a3b">linf_norm</a> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, T &gt; v)</td></tr>
<tr class="memdesc:a8981a9c3a9fb8084b2c4ab93a9b09a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Linf norm of a vector.  <a href="namespacetheoretica.html#a8981a9c3a9fb8084b2c4ab93a9b09a3b">More...</a><br /></td></tr>
<tr class="separator:a8981a9c3a9fb8084b2c4ab93a9b09a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0cb6c51c58cfdc4fe13f6900266a83"><td class="memTemplParams" colspan="2"><a id="a8d0cb6c51c58cfdc4fe13f6900266a83" name="a8d0cb6c51c58cfdc4fe13f6900266a83"></a>
template&lt;unsigned int N, typename T &gt; </td></tr>
<tr class="memitem:a8d0cb6c51c58cfdc4fe13f6900266a83"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dot</b> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, T &gt; v1, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, T &gt; v2)</td></tr>
<tr class="memdesc:a8d0cb6c51c58cfdc4fe13f6900266a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dot product of two vectors. <br /></td></tr>
<tr class="separator:a8d0cb6c51c58cfdc4fe13f6900266a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12940c0bd43e6edcabb9064ccfd6cc5a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a12940c0bd43e6edcabb9064ccfd6cc5a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; 3, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a12940c0bd43e6edcabb9064ccfd6cc5a">cross</a> (const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; 3, T &gt; &amp;v1, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; 3, T &gt; &amp;v2)</td></tr>
<tr class="memdesc:a12940c0bd43e6edcabb9064ccfd6cc5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cross product of two vectors.  <a href="namespacetheoretica.html#a12940c0bd43e6edcabb9064ccfd6cc5a">More...</a><br /></td></tr>
<tr class="separator:a12940c0bd43e6edcabb9064ccfd6cc5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51aa3252df8991054c7c1f301912176c"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a51aa3252df8991054c7c1f301912176c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a51aa3252df8991054c7c1f301912176c">sphere_inversion</a> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; p, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; c, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> r)</td></tr>
<tr class="memdesc:a51aa3252df8991054c7c1f301912176c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sphere inversion of a point with respect to a sphere of radius r centered in a point c.  <a href="namespacetheoretica.html#a51aa3252df8991054c7c1f301912176c">More...</a><br /></td></tr>
<tr class="separator:a51aa3252df8991054c7c1f301912176c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5efdb832f0c39ba2f0030c99e4de728b"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a5efdb832f0c39ba2f0030c99e4de728b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a5efdb832f0c39ba2f0030c99e4de728b">sphere_inversion</a> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; p)</td></tr>
<tr class="memdesc:a5efdb832f0c39ba2f0030c99e4de728b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sphere inversion of a point with respect to a sphere of radius 1 centered in the origin.  <a href="namespacetheoretica.html#a5efdb832f0c39ba2f0030c99e4de728b">More...</a><br /></td></tr>
<tr class="separator:a5efdb832f0c39ba2f0030c99e4de728b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d7c82d6537146481899d24c372b7d5"><td class="memItemLeft" align="right" valign="top"><a id="a19d7c82d6537146481899d24c372b7d5" name="a19d7c82d6537146481899d24c372b7d5"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>approx_max_goldensection</b> (<a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b)</td></tr>
<tr class="memdesc:a19d7c82d6537146481899d24c372b7d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a function maximum using the Golden Section search algorithm. <br /></td></tr>
<tr class="separator:a19d7c82d6537146481899d24c372b7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a957c6f47d494d5762ae25d46abcd2"><td class="memItemLeft" align="right" valign="top"><a id="a04a957c6f47d494d5762ae25d46abcd2" name="a04a957c6f47d494d5762ae25d46abcd2"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>approx_min_goldensection</b> (<a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b)</td></tr>
<tr class="memdesc:a04a957c6f47d494d5762ae25d46abcd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a function minimum using the Golden Section search algorithm. <br /></td></tr>
<tr class="separator:a04a957c6f47d494d5762ae25d46abcd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23149368a5fbd07dbc4936593220ae6c"><td class="memItemLeft" align="right" valign="top"><a id="a23149368a5fbd07dbc4936593220ae6c" name="a23149368a5fbd07dbc4936593220ae6c"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>approx_max_newton</b> (<a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a> f, <a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a> Df, <a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a> D2f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:a23149368a5fbd07dbc4936593220ae6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a function maximum given the function and the first two derivatives using Newton-Raphson. <br /></td></tr>
<tr class="separator:a23149368a5fbd07dbc4936593220ae6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059402523c2a53acfc39e9f761f19d66"><td class="memItemLeft" align="right" valign="top"><a id="a059402523c2a53acfc39e9f761f19d66" name="a059402523c2a53acfc39e9f761f19d66"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>approx_min_newton</b> (<a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a> f, <a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a> Df, <a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a> D2f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:a059402523c2a53acfc39e9f761f19d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a function minimum given the function and the first two derivatives using Newton-Raphson. <br /></td></tr>
<tr class="separator:a059402523c2a53acfc39e9f761f19d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e3664de849d0c0498b14d51c4b54d3"><td class="memItemLeft" align="right" valign="top"><a id="a79e3664de849d0c0498b14d51c4b54d3" name="a79e3664de849d0c0498b14d51c4b54d3"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>approx_max_bisection</b> (<a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a> f, <a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a> Df, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b)</td></tr>
<tr class="memdesc:a79e3664de849d0c0498b14d51c4b54d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a function maximum inside an interval given the function and its first derivative using bisection on the derivative. <br /></td></tr>
<tr class="separator:a79e3664de849d0c0498b14d51c4b54d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058864dfb87cf0649def78657208c9d8"><td class="memItemLeft" align="right" valign="top"><a id="a058864dfb87cf0649def78657208c9d8" name="a058864dfb87cf0649def78657208c9d8"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>approx_min_bisection</b> (<a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a> f, <a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a> Df, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b)</td></tr>
<tr class="memdesc:a058864dfb87cf0649def78657208c9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a function minimum inside an interval given the function and its first derivative using bisection on the derivative. <br /></td></tr>
<tr class="separator:a058864dfb87cf0649def78657208c9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb3b820ae998f3e0bc9e66ac2337a91"><td class="memItemLeft" align="right" valign="top"><a id="a2eb3b820ae998f3e0bc9e66ac2337a91" name="a2eb3b820ae998f3e0bc9e66ac2337a91"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>approx_root_bisection</b> (<a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b)</td></tr>
<tr class="memdesc:a2eb3b820ae998f3e0bc9e66ac2337a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a root of an arbitrary function using bisection inside a compact interval [a, b] where f(a) * f(b) &lt; 0. <br /></td></tr>
<tr class="separator:a2eb3b820ae998f3e0bc9e66ac2337a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031c5b6433038d5bd4e6d613c11d5adc"><td class="memItemLeft" align="right" valign="top"><a id="a031c5b6433038d5bd4e6d613c11d5adc" name="a031c5b6433038d5bd4e6d613c11d5adc"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>approx_root_newton</b> (<a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a> f, <a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a> Df, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:a031c5b6433038d5bd4e6d613c11d5adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a root of an arbitrary function using Newthon's method. <br /></td></tr>
<tr class="separator:a031c5b6433038d5bd4e6d613c11d5adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a99a3c1aefa232bd14f4153eb4183c"><td class="memItemLeft" align="right" valign="top"><a id="a69a99a3c1aefa232bd14f4153eb4183c" name="a69a99a3c1aefa232bd14f4153eb4183c"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>approx_polyn_root_newton</b> (<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; p, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:a69a99a3c1aefa232bd14f4153eb4183c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a root of a polynomial using Newthon's method. <br /></td></tr>
<tr class="separator:a69a99a3c1aefa232bd14f4153eb4183c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ba3edd52e5cb42f73cb2f3009ad885"><td class="memItemLeft" align="right" valign="top"><a id="a08ba3edd52e5cb42f73cb2f3009ad885" name="a08ba3edd52e5cb42f73cb2f3009ad885"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>approx_root_halley</b> (<a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a> f, <a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a> Df, <a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a> D2f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:a08ba3edd52e5cb42f73cb2f3009ad885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a root of an arbitrary function using Halley's method. <br /></td></tr>
<tr class="separator:a08ba3edd52e5cb42f73cb2f3009ad885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e0bd719d5274d2179dbcd1be6988b3"><td class="memItemLeft" align="right" valign="top"><a id="a93e0bd719d5274d2179dbcd1be6988b3" name="a93e0bd719d5274d2179dbcd1be6988b3"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>approx_polyn_root_halley</b> (<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; p, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:a93e0bd719d5274d2179dbcd1be6988b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a root of a polynomial using Halley's method. <br /></td></tr>
<tr class="separator:a93e0bd719d5274d2179dbcd1be6988b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f085ca3372ca993ae9c09ef0bbcd87f"><td class="memItemLeft" align="right" valign="top"><a id="a4f085ca3372ca993ae9c09ef0bbcd87f" name="a4f085ca3372ca993ae9c09ef0bbcd87f"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>approx_root_steffensen</b> (<a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a> f, <a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a> Df, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:a4f085ca3372ca993ae9c09ef0bbcd87f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a root of an arbitrary function using Steffensen's method. <br /></td></tr>
<tr class="separator:a4f085ca3372ca993ae9c09ef0bbcd87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c661fbdbe2cadaddfbcbb844d8ff011"><td class="memItemLeft" align="right" valign="top"><a id="a0c661fbdbe2cadaddfbcbb844d8ff011" name="a0c661fbdbe2cadaddfbcbb844d8ff011"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>approx_polyn_root_steffensen</b> (<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; p, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:a0c661fbdbe2cadaddfbcbb844d8ff011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a root of a polynomial using Steffensen's method. <br /></td></tr>
<tr class="separator:a0c661fbdbe2cadaddfbcbb844d8ff011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1781e383c98150952fc22685b8c0b87"><td class="memItemLeft" align="right" valign="top"><a id="ad1781e383c98150952fc22685b8c0b87" name="ad1781e383c98150952fc22685b8c0b87"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>approx_root_chebyshev</b> (<a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a> f, <a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a> Df, <a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a> D2f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:ad1781e383c98150952fc22685b8c0b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a root of an arbitrary function using Chebyshev's method. <br /></td></tr>
<tr class="separator:ad1781e383c98150952fc22685b8c0b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ad6e0cf459b4fb68c41f781b0e7afc"><td class="memItemLeft" align="right" valign="top"><a id="ac1ad6e0cf459b4fb68c41f781b0e7afc" name="ac1ad6e0cf459b4fb68c41f781b0e7afc"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>approx_polyn_root_chebyshev</b> (<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; p, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> guess=0)</td></tr>
<tr class="memdesc:ac1ad6e0cf459b4fb68c41f781b0e7afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate a root of a polynomial using Chebyshev's method. <br /></td></tr>
<tr class="separator:ac1ad6e0cf459b4fb68c41f781b0e7afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29355ce24067808f588917c0e178408"><td class="memTemplParams" colspan="2"><a id="ac29355ce24067808f588917c0e178408" name="ac29355ce24067808f588917c0e178408"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ac29355ce24067808f588917c0e178408"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gradient</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; &gt;), const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;x)</td></tr>
<tr class="memdesc:ac29355ce24067808f588917c0e178408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient for a given \(\vec x\) of a function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\) using automatic differentiation. <br /></td></tr>
<tr class="separator:ac29355ce24067808f588917c0e178408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7945a9959534ed6da94246f568393cd2"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a7945a9959534ed6da94246f568393cd2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a7945a9959534ed6da94246f568393cd2">gradient_mono</a> (<a class="el" href="classtheoretica_1_1dual.html">dual</a>(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1dual.html">dual</a> &gt;), const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;x)</td></tr>
<tr class="memdesc:a7945a9959534ed6da94246f568393cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient for a given \(\vec x\) of a function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\) using automatic differentiation.  <a href="namespacetheoretica.html#a7945a9959534ed6da94246f568393cd2">More...</a><br /></td></tr>
<tr class="separator:a7945a9959534ed6da94246f568393cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e77327c03871aa02fa44593b5e9f4b2"><td class="memTemplParams" colspan="2"><a id="a7e77327c03871aa02fa44593b5e9f4b2" name="a7e77327c03871aa02fa44593b5e9f4b2"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a7e77327c03871aa02fa44593b5e9f4b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>divergence</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; &gt;), const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;x)</td></tr>
<tr class="memdesc:a7e77327c03871aa02fa44593b5e9f4b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the divergence for a given \(\vec x\) of a function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\) using automatic differentiation. <br /></td></tr>
<tr class="separator:a7e77327c03871aa02fa44593b5e9f4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01412973394e4d319502a0fed1f8a9da"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a01412973394e4d319502a0fed1f8a9da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a01412973394e4d319502a0fed1f8a9da">divergence_mono</a> (<a class="el" href="classtheoretica_1_1dual.html">dual</a>(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1dual.html">dual</a> &gt;), const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;x)</td></tr>
<tr class="memdesc:a01412973394e4d319502a0fed1f8a9da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the divergence for a given \(\vec x\) of a function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\) using automatic differentiation.  <a href="namespacetheoretica.html#a01412973394e4d319502a0fed1f8a9da">More...</a><br /></td></tr>
<tr class="separator:a01412973394e4d319502a0fed1f8a9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17677cb37084438facefae074e4b29c0"><td class="memTemplParams" colspan="2"><a id="a17677cb37084438facefae074e4b29c0" name="a17677cb37084438facefae074e4b29c0"></a>
template&lt;unsigned int N, unsigned int M&gt; </td></tr>
<tr class="memitem:a17677cb37084438facefae074e4b29c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1mat.html">mat</a>&lt; M, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>jacobian</b> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; M, <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; &gt;), const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;x)</td></tr>
<tr class="memdesc:a17677cb37084438facefae074e4b29c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the jacobian of a generic function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}^M\). <br /></td></tr>
<tr class="separator:a17677cb37084438facefae074e4b29c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a0cdad81523353415ad4b5913871e4"><td class="memItemLeft" align="right" valign="top"><a id="a46a0cdad81523353415ad4b5913871e4" name="a46a0cdad81523353415ad4b5913871e4"></a>
<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>curl</b> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; 3, <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; 3 &gt; &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; 3, <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; 3 &gt; &gt;), const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; 3, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;x)</td></tr>
<tr class="memdesc:a46a0cdad81523353415ad4b5913871e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the curl for a given \(\vec x\) of a vector field defined by \(f: \mathbb{R}^3 \rightarrow \mathbb{R}^3\) using automatic differentiation. <br /></td></tr>
<tr class="separator:a46a0cdad81523353415ad4b5913871e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed789cb9f8123584b3e1f1f9a334f47d"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:aed789cb9f8123584b3e1f1f9a334f47d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aed789cb9f8123584b3e1f1f9a334f47d">directional_derivative</a> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; &gt;), const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;x, const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;v)</td></tr>
<tr class="memdesc:aed789cb9f8123584b3e1f1f9a334f47d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the directional derivative of a generic function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\).  <a href="namespacetheoretica.html#aed789cb9f8123584b3e1f1f9a334f47d">More...</a><br /></td></tr>
<tr class="separator:aed789cb9f8123584b3e1f1f9a334f47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65eada1a479ebab6b5ae8ce46a34f251"><td class="memTemplParams" colspan="2"><a id="a65eada1a479ebab6b5ae8ce46a34f251" name="a65eada1a479ebab6b5ae8ce46a34f251"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a65eada1a479ebab6b5ae8ce46a34f251"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>laplacian</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1dual2.html">dual2</a> &gt;), const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; &amp;x)</td></tr>
<tr class="memdesc:a65eada1a479ebab6b5ae8ce46a34f251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the laplacian differential operator for a generic function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\). <br /></td></tr>
<tr class="separator:a65eada1a479ebab6b5ae8ce46a34f251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0a5c7fbe93408ce58d40859bab3365"><td class="memTemplParams" colspan="2">template&lt;unsigned int M&gt; </td></tr>
<tr class="memitem:a3b0a5c7fbe93408ce58d40859bab3365"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a3b0a5c7fbe93408ce58d40859bab3365">sturm_liouville</a> (<a class="el" href="classtheoretica_1_1dual.html">dual</a>(*f)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; M, <a class="el" href="classtheoretica_1_1dual.html">dual</a> &gt;), <a class="el" href="classtheoretica_1_1dual.html">dual</a>(*H)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; M, <a class="el" href="classtheoretica_1_1dual.html">dual</a> &gt;), <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; M &gt; eta)</td></tr>
<tr class="memdesc:a3b0a5c7fbe93408ce58d40859bab3365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computer the Sturm-Liouville operator on a generic function of the form \(f: \mathbb{R}^{2N} \rightarrow \mathbb{R}\) with respect to a given Hamiltonian function of the form \(H: \mathbb{R}^{2N} \rightarrow \mathbb{R}\) where the first N arguments are the coordinates in phase space and the last N arguments are the conjugate momenta, for a given point in phase space.  <a href="namespacetheoretica.html#a3b0a5c7fbe93408ce58d40859bab3365">More...</a><br /></td></tr>
<tr class="separator:a3b0a5c7fbe93408ce58d40859bab3365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6629ddaf5a84d7a8f3159b749ef4db0"><td class="memItemLeft" align="right" valign="top"><a id="ae6629ddaf5a84d7a8f3159b749ef4db0" name="ae6629ddaf5a84d7a8f3159b749ef4db0"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>square</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:ae6629ddaf5a84d7a8f3159b749ef4db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square of a second order dual number. <br /></td></tr>
<tr class="separator:ae6629ddaf5a84d7a8f3159b749ef4db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6bc324bd8ae6bbd91b89c7491fe988"><td class="memItemLeft" align="right" valign="top"><a id="afd6bc324bd8ae6bbd91b89c7491fe988" name="afd6bc324bd8ae6bbd91b89c7491fe988"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cube</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:afd6bc324bd8ae6bbd91b89c7491fe988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cube of a second order dual number. <br /></td></tr>
<tr class="separator:afd6bc324bd8ae6bbd91b89c7491fe988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce493c565b387c0496eff49e137edb6"><td class="memItemLeft" align="right" valign="top"><a id="afce493c565b387c0496eff49e137edb6" name="afce493c565b387c0496eff49e137edb6"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pow</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x, int n)</td></tr>
<tr class="memdesc:afce493c565b387c0496eff49e137edb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the n-th power of a second order dual number. <br /></td></tr>
<tr class="separator:afce493c565b387c0496eff49e137edb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19dd33456cffdbba3f29d85061779e7c"><td class="memItemLeft" align="right" valign="top"><a id="a19dd33456cffdbba3f29d85061779e7c" name="a19dd33456cffdbba3f29d85061779e7c"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sqrt</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a19dd33456cffdbba3f29d85061779e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square root of a second order dual number. <br /></td></tr>
<tr class="separator:a19dd33456cffdbba3f29d85061779e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a34ba6bb56c26ba50c1b2c21d2da7e"><td class="memItemLeft" align="right" valign="top"><a id="ad7a34ba6bb56c26ba50c1b2c21d2da7e" name="ad7a34ba6bb56c26ba50c1b2c21d2da7e"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sin</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:ad7a34ba6bb56c26ba50c1b2c21d2da7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sine of a second order dual number. <br /></td></tr>
<tr class="separator:ad7a34ba6bb56c26ba50c1b2c21d2da7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97cec74fe963806729cbdd0d43de5cd3"><td class="memItemLeft" align="right" valign="top"><a id="a97cec74fe963806729cbdd0d43de5cd3" name="a97cec74fe963806729cbdd0d43de5cd3"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cos</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a97cec74fe963806729cbdd0d43de5cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cosine of a second order dual number. <br /></td></tr>
<tr class="separator:a97cec74fe963806729cbdd0d43de5cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81dcde719b69b4d63ecd3127cb289d9"><td class="memItemLeft" align="right" valign="top"><a id="ac81dcde719b69b4d63ecd3127cb289d9" name="ac81dcde719b69b4d63ecd3127cb289d9"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tan</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:ac81dcde719b69b4d63ecd3127cb289d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the tangent of a second order dual number. <br /></td></tr>
<tr class="separator:ac81dcde719b69b4d63ecd3127cb289d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5fed4cfa9af5d148c59a6005422edc"><td class="memItemLeft" align="right" valign="top"><a id="a9d5fed4cfa9af5d148c59a6005422edc" name="a9d5fed4cfa9af5d148c59a6005422edc"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cot</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a9d5fed4cfa9af5d148c59a6005422edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cotangent of a second order dual number. <br /></td></tr>
<tr class="separator:a9d5fed4cfa9af5d148c59a6005422edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3def790003197bb019f5933b4db45c44"><td class="memItemLeft" align="right" valign="top"><a id="a3def790003197bb019f5933b4db45c44" name="a3def790003197bb019f5933b4db45c44"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>exp</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a3def790003197bb019f5933b4db45c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the exponential of a second order dual number. <br /></td></tr>
<tr class="separator:a3def790003197bb019f5933b4db45c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec5b4f8c9f0d58d65415cec30915d16"><td class="memItemLeft" align="right" valign="top"><a id="a1ec5b4f8c9f0d58d65415cec30915d16" name="a1ec5b4f8c9f0d58d65415cec30915d16"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ln</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a1ec5b4f8c9f0d58d65415cec30915d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a second order dual number. <br /></td></tr>
<tr class="separator:a1ec5b4f8c9f0d58d65415cec30915d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e46804be47f0c4865014a4a763cf76"><td class="memItemLeft" align="right" valign="top"><a id="a29e46804be47f0c4865014a4a763cf76" name="a29e46804be47f0c4865014a4a763cf76"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>log2</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a29e46804be47f0c4865014a4a763cf76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a second order dual number. <br /></td></tr>
<tr class="separator:a29e46804be47f0c4865014a4a763cf76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5101414a44ee9cfda63aea95ea40ef97"><td class="memItemLeft" align="right" valign="top"><a id="a5101414a44ee9cfda63aea95ea40ef97" name="a5101414a44ee9cfda63aea95ea40ef97"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>log10</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a5101414a44ee9cfda63aea95ea40ef97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a second order dual number. <br /></td></tr>
<tr class="separator:a5101414a44ee9cfda63aea95ea40ef97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29720d3e71b280bb3ea048aa71bc3655"><td class="memItemLeft" align="right" valign="top"><a id="a29720d3e71b280bb3ea048aa71bc3655" name="a29720d3e71b280bb3ea048aa71bc3655"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>abs</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a29720d3e71b280bb3ea048aa71bc3655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the absolute value of a second order dual number. <br /></td></tr>
<tr class="separator:a29720d3e71b280bb3ea048aa71bc3655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3761005d81ac85b7297426bfc3f62ea2"><td class="memItemLeft" align="right" valign="top"><a id="a3761005d81ac85b7297426bfc3f62ea2" name="a3761005d81ac85b7297426bfc3f62ea2"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>asin</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:a3761005d81ac85b7297426bfc3f62ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arcsine of a second order dual number. <br /></td></tr>
<tr class="separator:a3761005d81ac85b7297426bfc3f62ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf13d7437b2dbea2212cbff3d519b9e5"><td class="memItemLeft" align="right" valign="top"><a id="acf13d7437b2dbea2212cbff3d519b9e5" name="acf13d7437b2dbea2212cbff3d519b9e5"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>acos</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:acf13d7437b2dbea2212cbff3d519b9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arcosine of a second order dual number. <br /></td></tr>
<tr class="separator:acf13d7437b2dbea2212cbff3d519b9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0493013e208bb00505abbc4ca37f292"><td class="memItemLeft" align="right" valign="top"><a id="af0493013e208bb00505abbc4ca37f292" name="af0493013e208bb00505abbc4ca37f292"></a>
<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>atan</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a> x)</td></tr>
<tr class="memdesc:af0493013e208bb00505abbc4ca37f292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arctangent of a second order dual number. <br /></td></tr>
<tr class="separator:af0493013e208bb00505abbc4ca37f292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f05865ec8d49e6abf889d81e1cd428"><td class="memItemLeft" align="right" valign="top"><a id="ad5f05865ec8d49e6abf889d81e1cd428" name="ad5f05865ec8d49e6abf889d81e1cd428"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>square</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:ad5f05865ec8d49e6abf889d81e1cd428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square of a dual number. <br /></td></tr>
<tr class="separator:ad5f05865ec8d49e6abf889d81e1cd428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab28b5c479cfd017f81b9806aa27838e"><td class="memItemLeft" align="right" valign="top"><a id="aab28b5c479cfd017f81b9806aa27838e" name="aab28b5c479cfd017f81b9806aa27838e"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cube</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:aab28b5c479cfd017f81b9806aa27838e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cube of a dual number. <br /></td></tr>
<tr class="separator:aab28b5c479cfd017f81b9806aa27838e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad063ce053e951e9183799584090c0e"><td class="memItemLeft" align="right" valign="top"><a id="a4ad063ce053e951e9183799584090c0e" name="a4ad063ce053e951e9183799584090c0e"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pow</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x, int n)</td></tr>
<tr class="memdesc:a4ad063ce053e951e9183799584090c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the n-th power of a dual number. <br /></td></tr>
<tr class="separator:a4ad063ce053e951e9183799584090c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e64e0c5a3452708528e6fb46f97b84e"><td class="memItemLeft" align="right" valign="top"><a id="a6e64e0c5a3452708528e6fb46f97b84e" name="a6e64e0c5a3452708528e6fb46f97b84e"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sqrt</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a6e64e0c5a3452708528e6fb46f97b84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square root of a dual number. <br /></td></tr>
<tr class="separator:a6e64e0c5a3452708528e6fb46f97b84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8369c63cfe1b787c3916865de1ac534b"><td class="memItemLeft" align="right" valign="top"><a id="a8369c63cfe1b787c3916865de1ac534b" name="a8369c63cfe1b787c3916865de1ac534b"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sin</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a8369c63cfe1b787c3916865de1ac534b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sine of a dual number. <br /></td></tr>
<tr class="separator:a8369c63cfe1b787c3916865de1ac534b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39630b09f7294762464b1eb5301b508f"><td class="memItemLeft" align="right" valign="top"><a id="a39630b09f7294762464b1eb5301b508f" name="a39630b09f7294762464b1eb5301b508f"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cos</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a39630b09f7294762464b1eb5301b508f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cosine of a dual number. <br /></td></tr>
<tr class="separator:a39630b09f7294762464b1eb5301b508f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef33e5920ccf4cfe7f79c70ebc9dfbb"><td class="memItemLeft" align="right" valign="top"><a id="afef33e5920ccf4cfe7f79c70ebc9dfbb" name="afef33e5920ccf4cfe7f79c70ebc9dfbb"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tan</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:afef33e5920ccf4cfe7f79c70ebc9dfbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the tangent of a dual number. <br /></td></tr>
<tr class="separator:afef33e5920ccf4cfe7f79c70ebc9dfbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdf17b1485bdfb0f967caee134136b6"><td class="memItemLeft" align="right" valign="top"><a id="aacdf17b1485bdfb0f967caee134136b6" name="aacdf17b1485bdfb0f967caee134136b6"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cot</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:aacdf17b1485bdfb0f967caee134136b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cotangent of a dual number. <br /></td></tr>
<tr class="separator:aacdf17b1485bdfb0f967caee134136b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21974bc022495f59a7702ce937f4544c"><td class="memItemLeft" align="right" valign="top"><a id="a21974bc022495f59a7702ce937f4544c" name="a21974bc022495f59a7702ce937f4544c"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>exp</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a21974bc022495f59a7702ce937f4544c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the exponential of a dual number. <br /></td></tr>
<tr class="separator:a21974bc022495f59a7702ce937f4544c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8acf40b0d2b7e4f62d95dd4bec0b169d"><td class="memItemLeft" align="right" valign="top"><a id="a8acf40b0d2b7e4f62d95dd4bec0b169d" name="a8acf40b0d2b7e4f62d95dd4bec0b169d"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ln</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a8acf40b0d2b7e4f62d95dd4bec0b169d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a dual number. <br /></td></tr>
<tr class="separator:a8acf40b0d2b7e4f62d95dd4bec0b169d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d6466e16b24bd1dfac49fd0c50ed79"><td class="memItemLeft" align="right" valign="top"><a id="a30d6466e16b24bd1dfac49fd0c50ed79" name="a30d6466e16b24bd1dfac49fd0c50ed79"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>log2</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a30d6466e16b24bd1dfac49fd0c50ed79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a dual number. <br /></td></tr>
<tr class="separator:a30d6466e16b24bd1dfac49fd0c50ed79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254b955eacdab15792dcb9d871559499"><td class="memItemLeft" align="right" valign="top"><a id="a254b955eacdab15792dcb9d871559499" name="a254b955eacdab15792dcb9d871559499"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>log10</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a254b955eacdab15792dcb9d871559499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a dual number. <br /></td></tr>
<tr class="separator:a254b955eacdab15792dcb9d871559499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3796818092440b5f1745c67b1162ddcf"><td class="memItemLeft" align="right" valign="top"><a id="a3796818092440b5f1745c67b1162ddcf" name="a3796818092440b5f1745c67b1162ddcf"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>abs</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a3796818092440b5f1745c67b1162ddcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the absolute value of a dual number. <br /></td></tr>
<tr class="separator:a3796818092440b5f1745c67b1162ddcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892e7542b82c516e65023555a0e30f6b"><td class="memItemLeft" align="right" valign="top"><a id="a892e7542b82c516e65023555a0e30f6b" name="a892e7542b82c516e65023555a0e30f6b"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>asin</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a892e7542b82c516e65023555a0e30f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arcsine of a dual number. <br /></td></tr>
<tr class="separator:a892e7542b82c516e65023555a0e30f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7f07a4d7a0abca49824b5926f259f1"><td class="memItemLeft" align="right" valign="top"><a id="abd7f07a4d7a0abca49824b5926f259f1" name="abd7f07a4d7a0abca49824b5926f259f1"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>acos</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:abd7f07a4d7a0abca49824b5926f259f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arccosine of a dual number. <br /></td></tr>
<tr class="separator:abd7f07a4d7a0abca49824b5926f259f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9ae8cb187999582be3db40cf149f43"><td class="memItemLeft" align="right" valign="top"><a id="a6b9ae8cb187999582be3db40cf149f43" name="a6b9ae8cb187999582be3db40cf149f43"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>atan</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a6b9ae8cb187999582be3db40cf149f43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arctangent of a dual number. <br /></td></tr>
<tr class="separator:a6b9ae8cb187999582be3db40cf149f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8c95ef4ed4e4da6af87e9eee675f82"><td class="memItemLeft" align="right" valign="top"><a id="a1f8c95ef4ed4e4da6af87e9eee675f82" name="a1f8c95ef4ed4e4da6af87e9eee675f82"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sinh</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a1f8c95ef4ed4e4da6af87e9eee675f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic sine of a dual number. <br /></td></tr>
<tr class="separator:a1f8c95ef4ed4e4da6af87e9eee675f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8d81973a127a1e66c180cba58d08ee"><td class="memItemLeft" align="right" valign="top"><a id="a1b8d81973a127a1e66c180cba58d08ee" name="a1b8d81973a127a1e66c180cba58d08ee"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cosh</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:a1b8d81973a127a1e66c180cba58d08ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic cosine of a dual number. <br /></td></tr>
<tr class="separator:a1b8d81973a127a1e66c180cba58d08ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf2c5dcfac28891e1e8a3accdf7dd21"><td class="memItemLeft" align="right" valign="top"><a id="afbf2c5dcfac28891e1e8a3accdf7dd21" name="afbf2c5dcfac28891e1e8a3accdf7dd21"></a>
<a class="el" href="classtheoretica_1_1dual.html">dual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tanh</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a> x)</td></tr>
<tr class="memdesc:afbf2c5dcfac28891e1e8a3accdf7dd21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic tangent of a dual number. <br /></td></tr>
<tr class="separator:afbf2c5dcfac28891e1e8a3accdf7dd21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab864254bd5f629822f3d1fcee3cff6b7"><td class="memTemplParams" colspan="2"><a id="ab864254bd5f629822f3d1fcee3cff6b7" name="ab864254bd5f629822f3d1fcee3cff6b7"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ab864254bd5f629822f3d1fcee3cff6b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>square</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:ab864254bd5f629822f3d1fcee3cff6b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square of a multidual number. <br /></td></tr>
<tr class="separator:ab864254bd5f629822f3d1fcee3cff6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae356adeb60d93c78bd5d27ddf49a6c66"><td class="memTemplParams" colspan="2"><a id="ae356adeb60d93c78bd5d27ddf49a6c66" name="ae356adeb60d93c78bd5d27ddf49a6c66"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ae356adeb60d93c78bd5d27ddf49a6c66"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cube</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:ae356adeb60d93c78bd5d27ddf49a6c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cube of a multidual number. <br /></td></tr>
<tr class="separator:ae356adeb60d93c78bd5d27ddf49a6c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb716c77e812d83d2aed787ff39b62e"><td class="memTemplParams" colspan="2"><a id="adfb716c77e812d83d2aed787ff39b62e" name="adfb716c77e812d83d2aed787ff39b62e"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:adfb716c77e812d83d2aed787ff39b62e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>pow</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x, int n)</td></tr>
<tr class="memdesc:adfb716c77e812d83d2aed787ff39b62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the n-th power of a multidual number. <br /></td></tr>
<tr class="separator:adfb716c77e812d83d2aed787ff39b62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aaa215522430587c6c8dc7971269fb5"><td class="memTemplParams" colspan="2"><a id="a8aaa215522430587c6c8dc7971269fb5" name="a8aaa215522430587c6c8dc7971269fb5"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a8aaa215522430587c6c8dc7971269fb5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sqrt</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:a8aaa215522430587c6c8dc7971269fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square root of a multidual number. <br /></td></tr>
<tr class="separator:a8aaa215522430587c6c8dc7971269fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1444ff9faf0b4b247468462d7b7cb01"><td class="memTemplParams" colspan="2"><a id="af1444ff9faf0b4b247468462d7b7cb01" name="af1444ff9faf0b4b247468462d7b7cb01"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:af1444ff9faf0b4b247468462d7b7cb01"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sin</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:af1444ff9faf0b4b247468462d7b7cb01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sine of a multidual number. <br /></td></tr>
<tr class="separator:af1444ff9faf0b4b247468462d7b7cb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ac8631aae8f4c3ae5dc63cbabc57c8"><td class="memTemplParams" colspan="2"><a id="ac8ac8631aae8f4c3ae5dc63cbabc57c8" name="ac8ac8631aae8f4c3ae5dc63cbabc57c8"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ac8ac8631aae8f4c3ae5dc63cbabc57c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cos</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:ac8ac8631aae8f4c3ae5dc63cbabc57c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cosine of a multidual number. <br /></td></tr>
<tr class="separator:ac8ac8631aae8f4c3ae5dc63cbabc57c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe9ca76dc4db09890a618a1d77da20b"><td class="memTemplParams" colspan="2"><a id="aafe9ca76dc4db09890a618a1d77da20b" name="aafe9ca76dc4db09890a618a1d77da20b"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:aafe9ca76dc4db09890a618a1d77da20b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tan</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:aafe9ca76dc4db09890a618a1d77da20b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the tangent of a multidual number. <br /></td></tr>
<tr class="separator:aafe9ca76dc4db09890a618a1d77da20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8839aa97612a40db14f1c8818b463d0"><td class="memTemplParams" colspan="2"><a id="ac8839aa97612a40db14f1c8818b463d0" name="ac8839aa97612a40db14f1c8818b463d0"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ac8839aa97612a40db14f1c8818b463d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cot</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:ac8839aa97612a40db14f1c8818b463d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cotangent of a multidual number. <br /></td></tr>
<tr class="separator:ac8839aa97612a40db14f1c8818b463d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311ed7edb65295b9284b3f10e5fa5f90"><td class="memTemplParams" colspan="2"><a id="a311ed7edb65295b9284b3f10e5fa5f90" name="a311ed7edb65295b9284b3f10e5fa5f90"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a311ed7edb65295b9284b3f10e5fa5f90"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>exp</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:a311ed7edb65295b9284b3f10e5fa5f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the exponential of a multidual number. <br /></td></tr>
<tr class="separator:a311ed7edb65295b9284b3f10e5fa5f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecb01797f9cac464a6dea02d5a73e34"><td class="memTemplParams" colspan="2"><a id="adecb01797f9cac464a6dea02d5a73e34" name="adecb01797f9cac464a6dea02d5a73e34"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:adecb01797f9cac464a6dea02d5a73e34"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ln</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:adecb01797f9cac464a6dea02d5a73e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a multidual number. <br /></td></tr>
<tr class="separator:adecb01797f9cac464a6dea02d5a73e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84cf28a3ec07fef45f28617946e62961"><td class="memTemplParams" colspan="2"><a id="a84cf28a3ec07fef45f28617946e62961" name="a84cf28a3ec07fef45f28617946e62961"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a84cf28a3ec07fef45f28617946e62961"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>log2</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:a84cf28a3ec07fef45f28617946e62961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a multidual number. <br /></td></tr>
<tr class="separator:a84cf28a3ec07fef45f28617946e62961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace737cd7c21a314c33915adf9956a640"><td class="memTemplParams" colspan="2"><a id="ace737cd7c21a314c33915adf9956a640" name="ace737cd7c21a314c33915adf9956a640"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ace737cd7c21a314c33915adf9956a640"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>log10</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:ace737cd7c21a314c33915adf9956a640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of a multidual number. <br /></td></tr>
<tr class="separator:ace737cd7c21a314c33915adf9956a640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb87636665493a0584655ad754e4c53"><td class="memTemplParams" colspan="2"><a id="a4eb87636665493a0584655ad754e4c53" name="a4eb87636665493a0584655ad754e4c53"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a4eb87636665493a0584655ad754e4c53"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:a4eb87636665493a0584655ad754e4c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the absolute value of a multidual number. <br /></td></tr>
<tr class="separator:a4eb87636665493a0584655ad754e4c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9fac1b91317d696fc2b4ea479b30b9"><td class="memTemplParams" colspan="2"><a id="a5b9fac1b91317d696fc2b4ea479b30b9" name="a5b9fac1b91317d696fc2b4ea479b30b9"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a5b9fac1b91317d696fc2b4ea479b30b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>asin</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:a5b9fac1b91317d696fc2b4ea479b30b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arcsine of a multidual number. <br /></td></tr>
<tr class="separator:a5b9fac1b91317d696fc2b4ea479b30b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf0ac356621f93c30fc6bdd9a1977a3"><td class="memTemplParams" colspan="2"><a id="afcf0ac356621f93c30fc6bdd9a1977a3" name="afcf0ac356621f93c30fc6bdd9a1977a3"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:afcf0ac356621f93c30fc6bdd9a1977a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>acos</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:afcf0ac356621f93c30fc6bdd9a1977a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arccosine of a multidual number. <br /></td></tr>
<tr class="separator:afcf0ac356621f93c30fc6bdd9a1977a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f31ace8ee7a5730ba7f0b1a60df5835"><td class="memTemplParams" colspan="2"><a id="a0f31ace8ee7a5730ba7f0b1a60df5835" name="a0f31ace8ee7a5730ba7f0b1a60df5835"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a0f31ace8ee7a5730ba7f0b1a60df5835"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>atan</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:a0f31ace8ee7a5730ba7f0b1a60df5835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arctangent of a multidual number. <br /></td></tr>
<tr class="separator:a0f31ace8ee7a5730ba7f0b1a60df5835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c71523f7f9d97e48c2de258ef952500"><td class="memTemplParams" colspan="2"><a id="a8c71523f7f9d97e48c2de258ef952500" name="a8c71523f7f9d97e48c2de258ef952500"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a8c71523f7f9d97e48c2de258ef952500"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sinh</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:a8c71523f7f9d97e48c2de258ef952500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic sine of a multidual number. <br /></td></tr>
<tr class="separator:a8c71523f7f9d97e48c2de258ef952500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b0ad9b86faf6ab2d308f9f76d31010"><td class="memTemplParams" colspan="2"><a id="ae2b0ad9b86faf6ab2d308f9f76d31010" name="ae2b0ad9b86faf6ab2d308f9f76d31010"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ae2b0ad9b86faf6ab2d308f9f76d31010"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cosh</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:ae2b0ad9b86faf6ab2d308f9f76d31010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic cosine of a multidual number. <br /></td></tr>
<tr class="separator:ae2b0ad9b86faf6ab2d308f9f76d31010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa990eeebdd5fb8e93c96c4ed6ff91317"><td class="memTemplParams" colspan="2"><a id="aa990eeebdd5fb8e93c96c4ed6ff91317" name="aa990eeebdd5fb8e93c96c4ed6ff91317"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:aa990eeebdd5fb8e93c96c4ed6ff91317"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tanh</b> (<a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; x)</td></tr>
<tr class="memdesc:aa990eeebdd5fb8e93c96c4ed6ff91317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic tangent of a multidual number. <br /></td></tr>
<tr class="separator:aa990eeebdd5fb8e93c96c4ed6ff91317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82516ac375e12055479f9f9a96cfeada"><td class="memTemplParams" colspan="2"><a id="a82516ac375e12055479f9f9a96cfeada" name="a82516ac375e12055479f9f9a96cfeada"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a82516ac375e12055479f9f9a96cfeada"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>differentiate_polynomial</b> (<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; T &gt; p)</td></tr>
<tr class="separator:a82516ac375e12055479f9f9a96cfeada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c386089b5d62d57f3b10d171194cfb"><td class="memItemLeft" align="right" valign="top"><a id="aa0c386089b5d62d57f3b10d171194cfb" name="aa0c386089b5d62d57f3b10d171194cfb"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>approx_derivative_central</b> (<a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> dx=0.00000001)</td></tr>
<tr class="separator:aa0c386089b5d62d57f3b10d171194cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f418e9837fdbda0e8fe4b7717bc1e89"><td class="memItemLeft" align="right" valign="top"><a id="a5f418e9837fdbda0e8fe4b7717bc1e89" name="a5f418e9837fdbda0e8fe4b7717bc1e89"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>approx_derivative_forward</b> (<a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> dx=0.00000001)</td></tr>
<tr class="separator:a5f418e9837fdbda0e8fe4b7717bc1e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804f16f68b8bff5e9b0a0dbf9a2f3bd0"><td class="memItemLeft" align="right" valign="top"><a id="a804f16f68b8bff5e9b0a0dbf9a2f3bd0" name="a804f16f68b8bff5e9b0a0dbf9a2f3bd0"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>approx_derivative_backward</b> (<a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> dx=0.00000001)</td></tr>
<tr class="separator:a804f16f68b8bff5e9b0a0dbf9a2f3bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af57e86214e047cc08e30d7d19e4410"><td class="memItemLeft" align="right" valign="top"><a id="a0af57e86214e047cc08e30d7d19e4410" name="a0af57e86214e047cc08e30d7d19e4410"></a>
<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>integrate_polynomial</b> (const <a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;p)</td></tr>
<tr class="separator:a0af57e86214e047cc08e30d7d19e4410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a06e57043ca1271f70ab0e30f254c6"><td class="memItemLeft" align="right" valign="top"><a id="ad6a06e57043ca1271f70ab0e30f254c6" name="ad6a06e57043ca1271f70ab0e30f254c6"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>approx_integral_midpoint</b> (<a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int steps=<a class="el" href="namespacetheoretica.html#aa1f0e3448f94ada54d171499c0c95ae4">INTEGRATION_STEPS</a>)</td></tr>
<tr class="separator:ad6a06e57043ca1271f70ab0e30f254c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8f86464826de8abb7f63ac97d84872"><td class="memItemLeft" align="right" valign="top"><a id="adb8f86464826de8abb7f63ac97d84872" name="adb8f86464826de8abb7f63ac97d84872"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>approx_integral_trapezoid</b> (<a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int steps=<a class="el" href="namespacetheoretica.html#aa1f0e3448f94ada54d171499c0c95ae4">INTEGRATION_STEPS</a>)</td></tr>
<tr class="separator:adb8f86464826de8abb7f63ac97d84872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e821b7930d9f65671c2812b0a7e0ea9"><td class="memItemLeft" align="right" valign="top"><a id="a5e821b7930d9f65671c2812b0a7e0ea9" name="a5e821b7930d9f65671c2812b0a7e0ea9"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>approx_integral_simpson</b> (<a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int steps=<a class="el" href="namespacetheoretica.html#aa1f0e3448f94ada54d171499c0c95ae4">INTEGRATION_STEPS</a>)</td></tr>
<tr class="separator:a5e821b7930d9f65671c2812b0a7e0ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373859daf532daffbe84697d1f61e2e7"><td class="memItemLeft" align="right" valign="top"><a id="a373859daf532daffbe84697d1f61e2e7" name="a373859daf532daffbe84697d1f61e2e7"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>approx_integral_romberg</b> (<a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int order)</td></tr>
<tr class="separator:a373859daf532daffbe84697d1f61e2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db59bab217b8a1346c4de243fc2c355"><td class="memItemLeft" align="right" valign="top"><a id="a2db59bab217b8a1346c4de243fc2c355" name="a2db59bab217b8a1346c4de243fc2c355"></a>
<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>taylor_linear_expansion</b> (<a class="el" href="classtheoretica_1_1dual.html">dual</a>(*f)(<a class="el" href="classtheoretica_1_1dual.html">dual</a>), <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x0=0)</td></tr>
<tr class="memdesc:a2db59bab217b8a1346c4de243fc2c355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the first order Taylor expansion of a generic function around x0, computed using dual numbers. <br /></td></tr>
<tr class="separator:a2db59bab217b8a1346c4de243fc2c355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af083224f6ac10dfbc4a9b80f65c1172b"><td class="memItemLeft" align="right" valign="top"><a id="af083224f6ac10dfbc4a9b80f65c1172b" name="af083224f6ac10dfbc4a9b80f65c1172b"></a>
<a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>taylor_quadratic_expansion</b> (<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>(*f)(<a class="el" href="classtheoretica_1_1dual2.html">dual2</a>), <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x0=0)</td></tr>
<tr class="memdesc:af083224f6ac10dfbc4a9b80f65c1172b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the second order Taylor expansion of a generic function around x0, computed using dual numbers (of second order). <br /></td></tr>
<tr class="separator:af083224f6ac10dfbc4a9b80f65c1172b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb4b91af4396da05389a6af367c162f"><td class="memItemLeft" align="right" valign="top"><a id="a1bb4b91af4396da05389a6af367c162f" name="a1bb4b91af4396da05389a6af367c162f"></a>
<a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator&quot;&quot;_i</b> (long double b)</td></tr>
<tr class="memdesc:a1bb4b91af4396da05389a6af367c162f"><td class="mdescLeft">&#160;</td><td class="mdescRight">String literal template to enable notations like a + bi;. <br /></td></tr>
<tr class="separator:a1bb4b91af4396da05389a6af367c162f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d09bcf107dc6230badf2b29e25ffcad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a9d09bcf107dc6230badf2b29e25ffcad">square</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a> z)</td></tr>
<tr class="memdesc:a9d09bcf107dc6230badf2b29e25ffcad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square of a complex number.  <a href="namespacetheoretica.html#a9d09bcf107dc6230badf2b29e25ffcad">More...</a><br /></td></tr>
<tr class="separator:a9d09bcf107dc6230badf2b29e25ffcad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a0b9841198983905b57496cad4869e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa8a0b9841198983905b57496cad4869e">cube</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a> z)</td></tr>
<tr class="memdesc:aa8a0b9841198983905b57496cad4869e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cube of a complex number.  <a href="namespacetheoretica.html#aa8a0b9841198983905b57496cad4869e">More...</a><br /></td></tr>
<tr class="separator:aa8a0b9841198983905b57496cad4869e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463ef7c6f8731bab9581d4021e92a60b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a463ef7c6f8731bab9581d4021e92a60b">exp</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a> z)</td></tr>
<tr class="memdesc:a463ef7c6f8731bab9581d4021e92a60b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex exponential.  <a href="namespacetheoretica.html#a463ef7c6f8731bab9581d4021e92a60b">More...</a><br /></td></tr>
<tr class="separator:a463ef7c6f8731bab9581d4021e92a60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f49fa3c3999e2a64956c3cb44bf596c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a0f49fa3c3999e2a64956c3cb44bf596c">abs</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a> z)</td></tr>
<tr class="memdesc:a0f49fa3c3999e2a64956c3cb44bf596c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the modulus of a complex number.  <a href="namespacetheoretica.html#a0f49fa3c3999e2a64956c3cb44bf596c">More...</a><br /></td></tr>
<tr class="separator:a0f49fa3c3999e2a64956c3cb44bf596c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6f6e44aa2d8dabd4a2710e313f65d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a1b6f6e44aa2d8dabd4a2710e313f65d8">sin</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a> z)</td></tr>
<tr class="memdesc:a1b6f6e44aa2d8dabd4a2710e313f65d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computer the complex sine.  <a href="namespacetheoretica.html#a1b6f6e44aa2d8dabd4a2710e313f65d8">More...</a><br /></td></tr>
<tr class="separator:a1b6f6e44aa2d8dabd4a2710e313f65d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32015dfa47fc795e0fefcf26b5c0375d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a32015dfa47fc795e0fefcf26b5c0375d">cos</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a> z)</td></tr>
<tr class="memdesc:a32015dfa47fc795e0fefcf26b5c0375d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex cosine.  <a href="namespacetheoretica.html#a32015dfa47fc795e0fefcf26b5c0375d">More...</a><br /></td></tr>
<tr class="separator:a32015dfa47fc795e0fefcf26b5c0375d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc57357e424703aa6ea643697c2f6d24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#abc57357e424703aa6ea643697c2f6d24">tan</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a> z)</td></tr>
<tr class="memdesc:abc57357e424703aa6ea643697c2f6d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex tangent.  <a href="namespacetheoretica.html#abc57357e424703aa6ea643697c2f6d24">More...</a><br /></td></tr>
<tr class="separator:abc57357e424703aa6ea643697c2f6d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f593debadf5736178434aa3fe476a5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a0f593debadf5736178434aa3fe476a5c">sqrt</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a> z)</td></tr>
<tr class="memdesc:a0f593debadf5736178434aa3fe476a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex square root.  <a href="namespacetheoretica.html#a0f593debadf5736178434aa3fe476a5c">More...</a><br /></td></tr>
<tr class="separator:a0f593debadf5736178434aa3fe476a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace32efc4e4b7b555c8cdc340e7adff4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ace32efc4e4b7b555c8cdc340e7adff4a">ln</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a> z)</td></tr>
<tr class="memdesc:ace32efc4e4b7b555c8cdc340e7adff4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex logarithm.  <a href="namespacetheoretica.html#ace32efc4e4b7b555c8cdc340e7adff4a">More...</a><br /></td></tr>
<tr class="separator:ace32efc4e4b7b555c8cdc340e7adff4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c4590079678ebac8a917eeda049bf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ab6c4590079678ebac8a917eeda049bf4">asin</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a> z)</td></tr>
<tr class="memdesc:ab6c4590079678ebac8a917eeda049bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex arcsine.  <a href="namespacetheoretica.html#ab6c4590079678ebac8a917eeda049bf4">More...</a><br /></td></tr>
<tr class="separator:ab6c4590079678ebac8a917eeda049bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a281d198a95a4d2f0f85ccd003948f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a8a281d198a95a4d2f0f85ccd003948f6">acos</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a> z)</td></tr>
<tr class="memdesc:a8a281d198a95a4d2f0f85ccd003948f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex arccosine.  <a href="namespacetheoretica.html#a8a281d198a95a4d2f0f85ccd003948f6">More...</a><br /></td></tr>
<tr class="separator:a8a281d198a95a4d2f0f85ccd003948f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423991094f40604ba94e6ae9275d5ea8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a423991094f40604ba94e6ae9275d5ea8">atan</a> (<a class="el" href="classtheoretica_1_1complex.html">complex</a> z)</td></tr>
<tr class="memdesc:a423991094f40604ba94e6ae9275d5ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex arctangent.  <a href="namespacetheoretica.html#a423991094f40604ba94e6ae9275d5ea8">More...</a><br /></td></tr>
<tr class="separator:a423991094f40604ba94e6ae9275d5ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2b51694a7dd4ded3a140f92366aaed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aca2b51694a7dd4ded3a140f92366aaed">mul_uint128</a> (uint64_t a, uint64_t b, uint64_t &amp;c_low, uint64_t &amp;c_high)</td></tr>
<tr class="memdesc:aca2b51694a7dd4ded3a140f92366aaed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two 64-bit integers and store the result in two 64-bit variables, keeping 128 bits of the result.  <a href="namespacetheoretica.html#aca2b51694a7dd4ded3a140f92366aaed">More...</a><br /></td></tr>
<tr class="separator:aca2b51694a7dd4ded3a140f92366aaed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672dbbc0ea824c71d7ca0dc26b346200"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a672dbbc0ea824c71d7ca0dc26b346200">mix_mum</a> (uint64_t a, uint64_t b)</td></tr>
<tr class="memdesc:a672dbbc0ea824c71d7ca0dc26b346200"><td class="mdescLeft">&#160;</td><td class="mdescRight">MUM bit mixing function.  <a href="namespacetheoretica.html#a672dbbc0ea824c71d7ca0dc26b346200">More...</a><br /></td></tr>
<tr class="separator:a672dbbc0ea824c71d7ca0dc26b346200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249d8d6497120d311e2abbfc11c5f54d"><td class="memTemplParams" colspan="2">template&lt;typename ShiftableType &gt; </td></tr>
<tr class="memitem:a249d8d6497120d311e2abbfc11c5f54d"><td class="memTemplItemLeft" align="right" valign="top">ShiftableType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a249d8d6497120d311e2abbfc11c5f54d">bit_rotate</a> (ShiftableType x, unsigned int i)</td></tr>
<tr class="memdesc:a249d8d6497120d311e2abbfc11c5f54d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit rotation using shifting.  <a href="namespacetheoretica.html#a249d8d6497120d311e2abbfc11c5f54d">More...</a><br /></td></tr>
<tr class="separator:a249d8d6497120d311e2abbfc11c5f54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72fbdb4020853ffb29758ae00f515fb4"><td class="memItemLeft" align="right" valign="top"><a id="a72fbdb4020853ffb29758ae00f515fb4" name="a72fbdb4020853ffb29758ae00f515fb4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>th_errcode_to_errno</b> (<a class="el" href="namespacetheoretica.html#a93838376629bab0a3f0b1a933178300d">UMATH_ERRCODE</a> err)</td></tr>
<tr class="memdesc:a72fbdb4020853ffb29758ae00f515fb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a UMATH_ERRCODE to errno error codes. <br /></td></tr>
<tr class="separator:a72fbdb4020853ffb29758ae00f515fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95680d1669eee1549fe112b9a846519"><td class="memItemLeft" align="right" valign="top"><a id="ae95680d1669eee1549fe112b9a846519" name="ae95680d1669eee1549fe112b9a846519"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>nan</b> ()</td></tr>
<tr class="memdesc:ae95680d1669eee1549fe112b9a846519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a quiet NaN number in floating point representation. <br /></td></tr>
<tr class="separator:ae95680d1669eee1549fe112b9a846519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e311a811c0c7e23c30e4496cfbe63d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a22e311a811c0c7e23c30e4496cfbe63d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a22e311a811c0c7e23c30e4496cfbe63d">is_nan</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a22e311a811c0c7e23c30e4496cfbe63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a generic variable is (equivalent to) a NaN number.  <a href="namespacetheoretica.html#a22e311a811c0c7e23c30e4496cfbe63d">More...</a><br /></td></tr>
<tr class="separator:a22e311a811c0c7e23c30e4496cfbe63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252ec9220e4dab52b18b400381624538"><td class="memItemLeft" align="right" valign="top"><a id="a252ec9220e4dab52b18b400381624538" name="a252ec9220e4dab52b18b400381624538"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>inf</b> ()</td></tr>
<tr class="memdesc:a252ec9220e4dab52b18b400381624538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return positive infinity in floating point representation. <br /></td></tr>
<tr class="separator:a252ec9220e4dab52b18b400381624538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1826571ac9bbfb4adb6b92e17f99dd58"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a1826571ac9bbfb4adb6b92e17f99dd58">square</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a1826571ac9bbfb4adb6b92e17f99dd58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square of a real number.  <a href="namespacetheoretica.html#a1826571ac9bbfb4adb6b92e17f99dd58">More...</a><br /></td></tr>
<tr class="separator:a1826571ac9bbfb4adb6b92e17f99dd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5652a07723590cd9a0c9332634ec1db4"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a5652a07723590cd9a0c9332634ec1db4">cube</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a5652a07723590cd9a0c9332634ec1db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cube of a real number.  <a href="namespacetheoretica.html#a5652a07723590cd9a0c9332634ec1db4">More...</a><br /></td></tr>
<tr class="separator:a5652a07723590cd9a0c9332634ec1db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e4cf02f9bcb4caf5371ee05d67df8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa2e4cf02f9bcb4caf5371ee05d67df8d">sqrt</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:aa2e4cf02f9bcb4caf5371ee05d67df8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square root of a real number.  <a href="namespacetheoretica.html#aa2e4cf02f9bcb4caf5371ee05d67df8d">More...</a><br /></td></tr>
<tr class="separator:aa2e4cf02f9bcb4caf5371ee05d67df8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c3b797f94ec5bc22b4c22f85417c93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a61c3b797f94ec5bc22b4c22f85417c93">cbrt</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a61c3b797f94ec5bc22b4c22f85417c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cubic root of x.  <a href="namespacetheoretica.html#a61c3b797f94ec5bc22b4c22f85417c93">More...</a><br /></td></tr>
<tr class="separator:a61c3b797f94ec5bc22b4c22f85417c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5177ff64d981840e149d1e282f1b27e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa5177ff64d981840e149d1e282f1b27e">abs</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:aa5177ff64d981840e149d1e282f1b27e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the absolute value of a real number.  <a href="namespacetheoretica.html#aa5177ff64d981840e149d1e282f1b27e">More...</a><br /></td></tr>
<tr class="separator:aa5177ff64d981840e149d1e282f1b27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61e39abd4fd4cd8cd83add5d0752e2f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ad61e39abd4fd4cd8cd83add5d0752e2f">sgn</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:ad61e39abd4fd4cd8cd83add5d0752e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sign of x (1 if positive, -1 if negative, 0 if null)  <a href="namespacetheoretica.html#ad61e39abd4fd4cd8cd83add5d0752e2f">More...</a><br /></td></tr>
<tr class="separator:ad61e39abd4fd4cd8cd83add5d0752e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944a1ca627ace27061946b1fbf572545"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a944a1ca627ace27061946b1fbf572545">floor</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a944a1ca627ace27061946b1fbf572545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the floor of x Computes the maximum integer number that is smaller than x.  <a href="namespacetheoretica.html#a944a1ca627ace27061946b1fbf572545">More...</a><br /></td></tr>
<tr class="separator:a944a1ca627ace27061946b1fbf572545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d079c3d95f2bc80c4619d13ff7263a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a85d079c3d95f2bc80c4619d13ff7263a">fract</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a85d079c3d95f2bc80c4619d13ff7263a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the fractional part of a real number.  <a href="namespacetheoretica.html#a85d079c3d95f2bc80c4619d13ff7263a">More...</a><br /></td></tr>
<tr class="separator:a85d079c3d95f2bc80c4619d13ff7263a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07569756dda099ecabf425371da6a31d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a07569756dda099ecabf425371da6a31d">max</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> y)</td></tr>
<tr class="memdesc:a07569756dda099ecabf425371da6a31d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the greatest number between two real numbers.  <a href="namespacetheoretica.html#a07569756dda099ecabf425371da6a31d">More...</a><br /></td></tr>
<tr class="separator:a07569756dda099ecabf425371da6a31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e295404d1712fb17851fe105715766e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5e295404d1712fb17851fe105715766e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a5e295404d1712fb17851fe105715766e">max</a> (T x, T y)</td></tr>
<tr class="memdesc:a5e295404d1712fb17851fe105715766e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two objects and return the greatest.  <a href="namespacetheoretica.html#a5e295404d1712fb17851fe105715766e">More...</a><br /></td></tr>
<tr class="separator:a5e295404d1712fb17851fe105715766e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac673920f8956ebea402eac4271f551ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ac673920f8956ebea402eac4271f551ba">min</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> y)</td></tr>
<tr class="memdesc:ac673920f8956ebea402eac4271f551ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the smallest number between two real numbers.  <a href="namespacetheoretica.html#ac673920f8956ebea402eac4271f551ba">More...</a><br /></td></tr>
<tr class="separator:ac673920f8956ebea402eac4271f551ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f4122359c1f32ba0741d098a5fbe69"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a70f4122359c1f32ba0741d098a5fbe69"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a70f4122359c1f32ba0741d098a5fbe69">min</a> (T x, T y)</td></tr>
<tr class="memdesc:a70f4122359c1f32ba0741d098a5fbe69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two objects and return the greatest.  <a href="namespacetheoretica.html#a70f4122359c1f32ba0741d098a5fbe69">More...</a><br /></td></tr>
<tr class="separator:a70f4122359c1f32ba0741d098a5fbe69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a4ad4c5446986fe2d255a03be337a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#af1a4ad4c5446986fe2d255a03be337a1">clamp</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b)</td></tr>
<tr class="memdesc:af1a4ad4c5446986fe2d255a03be337a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamp x between a and b.  <a href="namespacetheoretica.html#af1a4ad4c5446986fe2d255a03be337a1">More...</a><br /></td></tr>
<tr class="separator:af1a4ad4c5446986fe2d255a03be337a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf4d125306e3fffc7287aa42f9005a1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acdf4d125306e3fffc7287aa42f9005a1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#acdf4d125306e3fffc7287aa42f9005a1">clamp</a> (T x, T a, T b)</td></tr>
<tr class="memdesc:acdf4d125306e3fffc7287aa42f9005a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamp a value between two other values.  <a href="namespacetheoretica.html#acdf4d125306e3fffc7287aa42f9005a1">More...</a><br /></td></tr>
<tr class="separator:acdf4d125306e3fffc7287aa42f9005a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd0ef7aa0b136fbd1b4579cec14f369"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#abbd0ef7aa0b136fbd1b4579cec14f369">log2</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:abbd0ef7aa0b136fbd1b4579cec14f369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the binary logarithm of a real number.  <a href="namespacetheoretica.html#abbd0ef7aa0b136fbd1b4579cec14f369">More...</a><br /></td></tr>
<tr class="separator:abbd0ef7aa0b136fbd1b4579cec14f369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb04217fd0bd9dd23daaa186d3756d1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#adb04217fd0bd9dd23daaa186d3756d1e">log10</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:adb04217fd0bd9dd23daaa186d3756d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the base-10 logarithm of x.  <a href="namespacetheoretica.html#adb04217fd0bd9dd23daaa186d3756d1e">More...</a><br /></td></tr>
<tr class="separator:adb04217fd0bd9dd23daaa186d3756d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748eca731a8c05226332e5723b7a9d91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a748eca731a8c05226332e5723b7a9d91">ln</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a748eca731a8c05226332e5723b7a9d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the natural logarithm of x.  <a href="namespacetheoretica.html#a748eca731a8c05226332e5723b7a9d91">More...</a><br /></td></tr>
<tr class="separator:a748eca731a8c05226332e5723b7a9d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba826811342f6bab2f306ec09cc2d753"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aba826811342f6bab2f306ec09cc2d753"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aba826811342f6bab2f306ec09cc2d753">pow</a> (T x, int n)</td></tr>
<tr class="memdesc:aba826811342f6bab2f306ec09cc2d753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the n-th power of x (where n is natural)  <a href="namespacetheoretica.html#aba826811342f6bab2f306ec09cc2d753">More...</a><br /></td></tr>
<tr class="separator:aba826811342f6bab2f306ec09cc2d753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf52f04c3a1cefbb9dabab21cac0abbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#acf52f04c3a1cefbb9dabab21cac0abbb">root</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, int n)</td></tr>
<tr class="memdesc:acf52f04c3a1cefbb9dabab21cac0abbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the n-th root of x.  <a href="namespacetheoretica.html#acf52f04c3a1cefbb9dabab21cac0abbb">More...</a><br /></td></tr>
<tr class="separator:acf52f04c3a1cefbb9dabab21cac0abbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f95b4f90f63e762ffddbf649015ecf"><td class="memTemplParams" colspan="2"><a id="ab9f95b4f90f63e762ffddbf649015ecf" name="ab9f95b4f90f63e762ffddbf649015ecf"></a>
template&lt;typename IntType  = unsigned long long int&gt; </td></tr>
<tr class="memitem:ab9f95b4f90f63e762ffddbf649015ecf"><td class="memTemplItemLeft" align="right" valign="top">constexpr IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fact</b> (unsigned int n)</td></tr>
<tr class="memdesc:ab9f95b4f90f63e762ffddbf649015ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the factorial of n. <br /></td></tr>
<tr class="separator:ab9f95b4f90f63e762ffddbf649015ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61f8810fcedeaa35f54c834e934828e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ac61f8810fcedeaa35f54c834e934828e">exp</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:ac61f8810fcedeaa35f54c834e934828e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute \(e^x\).  <a href="namespacetheoretica.html#ac61f8810fcedeaa35f54c834e934828e">More...</a><br /></td></tr>
<tr class="separator:ac61f8810fcedeaa35f54c834e934828e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f12dd8e0fc650fa75c9961e51d1406c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a6f12dd8e0fc650fa75c9961e51d1406c">powf</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a)</td></tr>
<tr class="memdesc:a6f12dd8e0fc650fa75c9961e51d1406c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate x elevated to a.  <a href="namespacetheoretica.html#a6f12dd8e0fc650fa75c9961e51d1406c">More...</a><br /></td></tr>
<tr class="separator:a6f12dd8e0fc650fa75c9961e51d1406c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2ea0b1258dfe34df321901707d1808"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a2c2ea0b1258dfe34df321901707d1808">sin</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a2c2ea0b1258dfe34df321901707d1808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sine of a real number.  <a href="namespacetheoretica.html#a2c2ea0b1258dfe34df321901707d1808">More...</a><br /></td></tr>
<tr class="separator:a2c2ea0b1258dfe34df321901707d1808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af684d7159e22012dc5229c31eb66fceb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#af684d7159e22012dc5229c31eb66fceb">cos</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:af684d7159e22012dc5229c31eb66fceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cosine of a real number.  <a href="namespacetheoretica.html#af684d7159e22012dc5229c31eb66fceb">More...</a><br /></td></tr>
<tr class="separator:af684d7159e22012dc5229c31eb66fceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9d9a32dc2c9f00de35c1b1a49b218e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#abe9d9a32dc2c9f00de35c1b1a49b218e">tan</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:abe9d9a32dc2c9f00de35c1b1a49b218e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the tangent of x.  <a href="namespacetheoretica.html#abe9d9a32dc2c9f00de35c1b1a49b218e">More...</a><br /></td></tr>
<tr class="separator:abe9d9a32dc2c9f00de35c1b1a49b218e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6f43e74456bea35fb757f17db47da8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aec6f43e74456bea35fb757f17db47da8">cot</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:aec6f43e74456bea35fb757f17db47da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cotangent of x.  <a href="namespacetheoretica.html#aec6f43e74456bea35fb757f17db47da8">More...</a><br /></td></tr>
<tr class="separator:aec6f43e74456bea35fb757f17db47da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426b70abe4783e75806e1ae8c9e9e2bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a426b70abe4783e75806e1ae8c9e9e2bd">atan</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a426b70abe4783e75806e1ae8c9e9e2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arctangent.  <a href="namespacetheoretica.html#a426b70abe4783e75806e1ae8c9e9e2bd">More...</a><br /></td></tr>
<tr class="separator:a426b70abe4783e75806e1ae8c9e9e2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b06e5bf997c4447c10f2fa96649347"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a79b06e5bf997c4447c10f2fa96649347">asin</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a79b06e5bf997c4447c10f2fa96649347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arcsine.  <a href="namespacetheoretica.html#a79b06e5bf997c4447c10f2fa96649347">More...</a><br /></td></tr>
<tr class="separator:a79b06e5bf997c4447c10f2fa96649347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2d69e3a3387958a27d4a03ed478a99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a7f2d69e3a3387958a27d4a03ed478a99">acos</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a7f2d69e3a3387958a27d4a03ed478a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arccosine.  <a href="namespacetheoretica.html#a7f2d69e3a3387958a27d4a03ed478a99">More...</a><br /></td></tr>
<tr class="separator:a7f2d69e3a3387958a27d4a03ed478a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae6ab14a39d6132b6858934dadaaf3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a6ae6ab14a39d6132b6858934dadaaf3e">atan2</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> y, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a6ae6ab14a39d6132b6858934dadaaf3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 2 argument arctangent.  <a href="namespacetheoretica.html#a6ae6ab14a39d6132b6858934dadaaf3e">More...</a><br /></td></tr>
<tr class="separator:a6ae6ab14a39d6132b6858934dadaaf3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0650ea8e1435cc518e960bfcecf5b66e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a0650ea8e1435cc518e960bfcecf5b66e">sinh</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a0650ea8e1435cc518e960bfcecf5b66e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic sine.  <a href="namespacetheoretica.html#a0650ea8e1435cc518e960bfcecf5b66e">More...</a><br /></td></tr>
<tr class="separator:a0650ea8e1435cc518e960bfcecf5b66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fc03cbb1de8180e51183bb82c0bb28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a12fc03cbb1de8180e51183bb82c0bb28">cosh</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a12fc03cbb1de8180e51183bb82c0bb28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic cosine.  <a href="namespacetheoretica.html#a12fc03cbb1de8180e51183bb82c0bb28">More...</a><br /></td></tr>
<tr class="separator:a12fc03cbb1de8180e51183bb82c0bb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6b8fc4bb2609507cd1fae0f7d6c8a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aaf6b8fc4bb2609507cd1fae0f7d6c8a7">tanh</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:aaf6b8fc4bb2609507cd1fae0f7d6c8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic tangent.  <a href="namespacetheoretica.html#aaf6b8fc4bb2609507cd1fae0f7d6c8a7">More...</a><br /></td></tr>
<tr class="separator:aaf6b8fc4bb2609507cd1fae0f7d6c8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f957ad9b2354268f56ab1ca3843080"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a96f957ad9b2354268f56ab1ca3843080">coth</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a96f957ad9b2354268f56ab1ca3843080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hyperbolic cotangent.  <a href="namespacetheoretica.html#a96f957ad9b2354268f56ab1ca3843080">More...</a><br /></td></tr>
<tr class="separator:a96f957ad9b2354268f56ab1ca3843080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a76685197faa15403e24b836830cf5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a7a76685197faa15403e24b836830cf5d">sigmoid</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a7a76685197faa15403e24b836830cf5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sigmoid function.  <a href="namespacetheoretica.html#a7a76685197faa15403e24b836830cf5d">More...</a><br /></td></tr>
<tr class="separator:a7a76685197faa15403e24b836830cf5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1efe3bd7ff87719aab92b67cec535096"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a1efe3bd7ff87719aab92b67cec535096">sinc</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x)</td></tr>
<tr class="memdesc:a1efe3bd7ff87719aab92b67cec535096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the normalized sinc function.  <a href="namespacetheoretica.html#a1efe3bd7ff87719aab92b67cec535096">More...</a><br /></td></tr>
<tr class="separator:a1efe3bd7ff87719aab92b67cec535096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65be0b914abdafbb96aa05d6fda14f98"><td class="memTemplParams" colspan="2">template&lt;typename IntType  = unsigned long long int&gt; </td></tr>
<tr class="memitem:a65be0b914abdafbb96aa05d6fda14f98"><td class="memTemplItemLeft" align="right" valign="top">constexpr IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a65be0b914abdafbb96aa05d6fda14f98">binomial_coeff</a> (unsigned int n, unsigned int m)</td></tr>
<tr class="memdesc:a65be0b914abdafbb96aa05d6fda14f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the binomial coefficient.  <a href="namespacetheoretica.html#a65be0b914abdafbb96aa05d6fda14f98">More...</a><br /></td></tr>
<tr class="separator:a65be0b914abdafbb96aa05d6fda14f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee874cdb0b2a00881f01de91e931854"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a4ee874cdb0b2a00881f01de91e931854">radians</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> <a class="el" href="namespacetheoretica.html#a0fd2bb549c191e40d2bf6c5e9f1e5dcc">degrees</a>)</td></tr>
<tr class="memdesc:a4ee874cdb0b2a00881f01de91e931854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert degrees to radians.  <a href="namespacetheoretica.html#a4ee874cdb0b2a00881f01de91e931854">More...</a><br /></td></tr>
<tr class="separator:a4ee874cdb0b2a00881f01de91e931854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd2bb549c191e40d2bf6c5e9f1e5dcc"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a0fd2bb549c191e40d2bf6c5e9f1e5dcc">degrees</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> <a class="el" href="namespacetheoretica.html#a4ee874cdb0b2a00881f01de91e931854">radians</a>)</td></tr>
<tr class="memdesc:a0fd2bb549c191e40d2bf6c5e9f1e5dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert radians to degrees.  <a href="namespacetheoretica.html#a0fd2bb549c191e40d2bf6c5e9f1e5dcc">More...</a><br /></td></tr>
<tr class="separator:a0fd2bb549c191e40d2bf6c5e9f1e5dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93fd0f7d8ed7baa75f8f2a3d6632132a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a93fd0f7d8ed7baa75f8f2a3d6632132a"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a93fd0f7d8ed7baa75f8f2a3d6632132a">kronecker_delta</a> (T i, T j)</td></tr>
<tr class="memdesc:a93fd0f7d8ed7baa75f8f2a3d6632132a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kronecker delta, equals 1 if i is equal to j, 0 otherwise.  <a href="namespacetheoretica.html#a93fd0f7d8ed7baa75f8f2a3d6632132a">More...</a><br /></td></tr>
<tr class="separator:a93fd0f7d8ed7baa75f8f2a3d6632132a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87fed634613f9a7756b807368d316cd9"><td class="memItemLeft" align="right" valign="top"><a id="a87fed634613f9a7756b807368d316cd9" name="a87fed634613f9a7756b807368d316cd9"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>product</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X)</td></tr>
<tr class="memdesc:a87fed634613f9a7756b807368d316cd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product of a set of values. <br /></td></tr>
<tr class="separator:a87fed634613f9a7756b807368d316cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d272b1cd91c9ac9f1c2049bd627f90e"><td class="memItemLeft" align="right" valign="top"><a id="a9d272b1cd91c9ac9f1c2049bd627f90e" name="a9d272b1cd91c9ac9f1c2049bd627f90e"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>product_sum</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y)</td></tr>
<tr class="memdesc:a9d272b1cd91c9ac9f1c2049bd627f90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum the products of two sets of values. <br /></td></tr>
<tr class="separator:a9d272b1cd91c9ac9f1c2049bd627f90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8e23a7720015a774c4cdcd119a434b"><td class="memItemLeft" align="right" valign="top"><a id="a8c8e23a7720015a774c4cdcd119a434b" name="a8c8e23a7720015a774c4cdcd119a434b"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>product_sum_squares</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y)</td></tr>
<tr class="memdesc:a8c8e23a7720015a774c4cdcd119a434b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum the products of the squares of two sets of data. <br /></td></tr>
<tr class="separator:a8c8e23a7720015a774c4cdcd119a434b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2455c2163719c1f26553aeff27dfe4"><td class="memItemLeft" align="right" valign="top"><a id="a0e2455c2163719c1f26553aeff27dfe4" name="a0e2455c2163719c1f26553aeff27dfe4"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>product_sum</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Z)</td></tr>
<tr class="memdesc:a0e2455c2163719c1f26553aeff27dfe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum the products of three sets of values. <br /></td></tr>
<tr class="separator:a0e2455c2163719c1f26553aeff27dfe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad506ec29923258e070ed286a31e2d9a6"><td class="memItemLeft" align="right" valign="top"><a id="ad506ec29923258e070ed286a31e2d9a6" name="ad506ec29923258e070ed286a31e2d9a6"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>quotient_sum</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y)</td></tr>
<tr class="memdesc:ad506ec29923258e070ed286a31e2d9a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum the quotients of two sets of values. <br /></td></tr>
<tr class="separator:ad506ec29923258e070ed286a31e2d9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2add9ac96bf83be926b67ac98871d519"><td class="memItemLeft" align="right" valign="top"><a id="a2add9ac96bf83be926b67ac98871d519" name="a2add9ac96bf83be926b67ac98871d519"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sum_squares</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X)</td></tr>
<tr class="memdesc:a2add9ac96bf83be926b67ac98871d519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum the squares of a set of values. <br /></td></tr>
<tr class="separator:a2add9ac96bf83be926b67ac98871d519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218096ebc25892ce56a9b64e1c9d38c0"><td class="memItemLeft" align="right" valign="top"><a id="a218096ebc25892ce56a9b64e1c9d38c0" name="a218096ebc25892ce56a9b64e1c9d38c0"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sum</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X)</td></tr>
<tr class="memdesc:a218096ebc25892ce56a9b64e1c9d38c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum together a set of values. <br /></td></tr>
<tr class="separator:a218096ebc25892ce56a9b64e1c9d38c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f1d3ea55880b60ec911458c6289aa0"><td class="memItemLeft" align="right" valign="top"><a id="a77f1d3ea55880b60ec911458c6289aa0" name="a77f1d3ea55880b60ec911458c6289aa0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>apply</b> (<a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>(*f)(<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>))</td></tr>
<tr class="memdesc:a77f1d3ea55880b60ec911458c6289aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function to a set of values. <br /></td></tr>
<tr class="separator:a77f1d3ea55880b60ec911458c6289aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3f2ff840d6e5dae38dfc1e6176a7be"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9b3f2ff840d6e5dae38dfc1e6176a7be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a9b3f2ff840d6e5dae38dfc1e6176a7be">lagrange_polynomial</a> (const std::vector&lt; <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; 2, T &gt; &gt; &amp;points)</td></tr>
<tr class="memdesc:a9b3f2ff840d6e5dae38dfc1e6176a7be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Lagrange polynomial interpolating a set of points.  <a href="namespacetheoretica.html#a9b3f2ff840d6e5dae38dfc1e6176a7be">More...</a><br /></td></tr>
<tr class="separator:a9b3f2ff840d6e5dae38dfc1e6176a7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77c5c6195e30df1e423b0922cc0776e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#af77c5c6195e30df1e423b0922cc0776e">chebyshev_nodes</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int n)</td></tr>
<tr class="memdesc:af77c5c6195e30df1e423b0922cc0776e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the n Chebyshev nodes on a given interval.  <a href="namespacetheoretica.html#af77c5c6195e30df1e423b0922cc0776e">More...</a><br /></td></tr>
<tr class="separator:af77c5c6195e30df1e423b0922cc0776e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc2216d71f0d7147b5c0dacdeea80db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a9dc2216d71f0d7147b5c0dacdeea80db">interpolate_grid</a> (<a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int order)</td></tr>
<tr class="memdesc:a9dc2216d71f0d7147b5c0dacdeea80db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the interpolating polynomial of a real function on an equidistant point sample.  <a href="namespacetheoretica.html#a9dc2216d71f0d7147b5c0dacdeea80db">More...</a><br /></td></tr>
<tr class="separator:a9dc2216d71f0d7147b5c0dacdeea80db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f9a26f1ee40dea3fced3ee7e0c9aa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a88f9a26f1ee40dea3fced3ee7e0c9aa9">interpolate_chebyshev</a> (<a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, unsigned int order)</td></tr>
<tr class="memdesc:a88f9a26f1ee40dea3fced3ee7e0c9aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the interpolating polynomial of a real function using Chebyshev nodes as sampling points.  <a href="namespacetheoretica.html#a88f9a26f1ee40dea3fced3ee7e0c9aa9">More...</a><br /></td></tr>
<tr class="separator:a88f9a26f1ee40dea3fced3ee7e0c9aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3565670d1234796d942171af74e3b9"><td class="memItemLeft" align="right" valign="top"><a id="a0b3565670d1234796d942171af74e3b9" name="a0b3565670d1234796d942171af74e3b9"></a>
<a class="el" href="namespacetheoretica.html#afc230dfc9709da95a25790f260f0b95c">rational_polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><b>interpolate_rational_sw</b> (const std::vector&lt; <a class="el" href="namespacetheoretica.html#a78450ba4db2e132788cc0566b22848b9">vec2</a> &gt; &amp;points)</td></tr>
<tr class="memdesc:a0b3565670d1234796d942171af74e3b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the ratio. <br /></td></tr>
<tr class="separator:a0b3565670d1234796d942171af74e3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0edd44311fc206d96919ab11d1977a9"><td class="memItemLeft" align="right" valign="top"><a id="aa0edd44311fc206d96919ab11d1977a9" name="aa0edd44311fc206d96919ab11d1977a9"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lerp</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x1, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> interp)</td></tr>
<tr class="memdesc:aa0edd44311fc206d96919ab11d1977a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear interpolation. <br /></td></tr>
<tr class="separator:aa0edd44311fc206d96919ab11d1977a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7765f4fbfe237744fe9819a6aaae2376"><td class="memTemplParams" colspan="2"><a id="a7765f4fbfe237744fe9819a6aaae2376" name="a7765f4fbfe237744fe9819a6aaae2376"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a7765f4fbfe237744fe9819a6aaae2376"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>lerp</b> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; P1, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; P2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> interp)</td></tr>
<tr class="memdesc:a7765f4fbfe237744fe9819a6aaae2376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear interpolation. <br /></td></tr>
<tr class="separator:a7765f4fbfe237744fe9819a6aaae2376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a854543c4d5334c61247aed920937c7"><td class="memItemLeft" align="right" valign="top"><a id="a7a854543c4d5334c61247aed920937c7" name="a7a854543c4d5334c61247aed920937c7"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>invlerp</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x1, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> value)</td></tr>
<tr class="memdesc:a7a854543c4d5334c61247aed920937c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse linear interpolation. <br /></td></tr>
<tr class="separator:a7a854543c4d5334c61247aed920937c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ed1580590487a3d2b7b0c836b23e7b"><td class="memTemplParams" colspan="2"><a id="a40ed1580590487a3d2b7b0c836b23e7b" name="a40ed1580590487a3d2b7b0c836b23e7b"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a40ed1580590487a3d2b7b0c836b23e7b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>invlerp</b> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; P1, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; P2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> value)</td></tr>
<tr class="memdesc:a40ed1580590487a3d2b7b0c836b23e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse linear interpolation. <br /></td></tr>
<tr class="separator:a40ed1580590487a3d2b7b0c836b23e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d55941e7aa059d066873e4116c531b0"><td class="memItemLeft" align="right" valign="top"><a id="a6d55941e7aa059d066873e4116c531b0" name="a6d55941e7aa059d066873e4116c531b0"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>remap</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> iFrom, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> iTo, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> oFrom, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> oTo, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> value)</td></tr>
<tr class="memdesc:a6d55941e7aa059d066873e4116c531b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remap a value from one range to another. <br /></td></tr>
<tr class="separator:a6d55941e7aa059d066873e4116c531b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289be70d029eee26d9ee9e975a40b5fa"><td class="memTemplParams" colspan="2"><a id="a289be70d029eee26d9ee9e975a40b5fa" name="a289be70d029eee26d9ee9e975a40b5fa"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a289be70d029eee26d9ee9e975a40b5fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>remap</b> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; iFrom, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; iTo, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; oFrom, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; oTo, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> value)</td></tr>
<tr class="memdesc:a289be70d029eee26d9ee9e975a40b5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remap a vector value from one range to another. <br /></td></tr>
<tr class="separator:a289be70d029eee26d9ee9e975a40b5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38cddd68590c7b5e6d70646776b648f9"><td class="memTemplParams" colspan="2"><a id="a38cddd68590c7b5e6d70646776b648f9" name="a38cddd68590c7b5e6d70646776b648f9"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a38cddd68590c7b5e6d70646776b648f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nlerp</b> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; P1, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; P2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> interp)</td></tr>
<tr class="memdesc:a38cddd68590c7b5e6d70646776b648f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalized linear interpolation. <br /></td></tr>
<tr class="separator:a38cddd68590c7b5e6d70646776b648f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c80e941d5c102eae47c3935afdc0e4"><td class="memTemplParams" colspan="2"><a id="aa8c80e941d5c102eae47c3935afdc0e4" name="aa8c80e941d5c102eae47c3935afdc0e4"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:aa8c80e941d5c102eae47c3935afdc0e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>slerp</b> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; P1, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; P2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> t)</td></tr>
<tr class="memdesc:aa8c80e941d5c102eae47c3935afdc0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spherical interpolation. <br /></td></tr>
<tr class="separator:aa8c80e941d5c102eae47c3935afdc0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b8a327e65a2d21993a28009828faae"><td class="memItemLeft" align="right" valign="top"><a id="a75b8a327e65a2d21993a28009828faae" name="a75b8a327e65a2d21993a28009828faae"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>smoothstep</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x1, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> interp)</td></tr>
<tr class="memdesc:a75b8a327e65a2d21993a28009828faae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smoothstep interpolation. <br /></td></tr>
<tr class="separator:a75b8a327e65a2d21993a28009828faae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423c4bdba84ea280878dcef43b5df206"><td class="memItemLeft" align="right" valign="top"><a id="a423c4bdba84ea280878dcef43b5df206" name="a423c4bdba84ea280878dcef43b5df206"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>smootherstep</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x1, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> interp)</td></tr>
<tr class="memdesc:a423c4bdba84ea280878dcef43b5df206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smootherstep interpolation. <br /></td></tr>
<tr class="separator:a423c4bdba84ea280878dcef43b5df206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69213a79c487ca5266077e64f7624fb3"><td class="memTemplParams" colspan="2"><a id="a69213a79c487ca5266077e64f7624fb3" name="a69213a79c487ca5266077e64f7624fb3"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a69213a79c487ca5266077e64f7624fb3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>quadratic_bezier</b> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; P0, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; P1, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; P2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> t)</td></tr>
<tr class="memdesc:a69213a79c487ca5266077e64f7624fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quadratic Bezier curve. <br /></td></tr>
<tr class="separator:a69213a79c487ca5266077e64f7624fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b261d224ea1a2878b802013eae0fbaf"><td class="memTemplParams" colspan="2"><a id="a2b261d224ea1a2878b802013eae0fbaf" name="a2b261d224ea1a2878b802013eae0fbaf"></a>
template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a2b261d224ea1a2878b802013eae0fbaf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cubic_bezier</b> (<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; P0, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; P1, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; P2, <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; P3, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> t)</td></tr>
<tr class="memdesc:a2b261d224ea1a2878b802013eae0fbaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cubic Bezier curve. <br /></td></tr>
<tr class="separator:a2b261d224ea1a2878b802013eae0fbaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaac9bb0b5b83e96e4312cef9d99af68"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:aeaac9bb0b5b83e96e4312cef9d99af68"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aeaac9bb0b5b83e96e4312cef9d99af68">bezier</a> (std::vector&lt; <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; &gt; points, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> t)</td></tr>
<tr class="memdesc:aeaac9bb0b5b83e96e4312cef9d99af68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic Bezier curve in N dimensions.  <a href="namespacetheoretica.html#aeaac9bb0b5b83e96e4312cef9d99af68">More...</a><br /></td></tr>
<tr class="separator:aeaac9bb0b5b83e96e4312cef9d99af68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99c87ef0ca077098ba3428a6e80956a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ab99c87ef0ca077098ba3428a6e80956a">approx_integral_montecarlo</a> (<a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a> f, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> f_max, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g, unsigned int N=10000)</td></tr>
<tr class="memdesc:ab99c87ef0ca077098ba3428a6e80956a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate an integral by using Monte Carlo integration.  <a href="namespacetheoretica.html#ab99c87ef0ca077098ba3428a6e80956a">More...</a><br /></td></tr>
<tr class="separator:ab99c87ef0ca077098ba3428a6e80956a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae266dabbc97f85eddaeb0466a07d325"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aae266dabbc97f85eddaeb0466a07d325">rand_real</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> b, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g, uint64_t prec=<a class="el" href="namespacetheoretica.html#a0e48eab9ce5928d0c754a40ddb2d068f">RAND_REAL_PREC</a>)</td></tr>
<tr class="memdesc:aae266dabbc97f85eddaeb0466a07d325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a pseudorandom real number in [a, b] using a preexisting generator.  <a href="namespacetheoretica.html#aae266dabbc97f85eddaeb0466a07d325">More...</a><br /></td></tr>
<tr class="separator:aae266dabbc97f85eddaeb0466a07d325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1025a8b933cfe7077936c4be27971c1"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ab1025a8b933cfe7077936c4be27971c1">rand_congruential</a> (uint64_t x, uint64_t a=48271, uint64_t c=0, uint64_t m=((uint64_t) 1&lt;&lt; 31) - 1)</td></tr>
<tr class="memdesc:ab1025a8b933cfe7077936c4be27971c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Congruential pseudorandom number generation algorithm.  <a href="namespacetheoretica.html#ab1025a8b933cfe7077936c4be27971c1">More...</a><br /></td></tr>
<tr class="separator:ab1025a8b933cfe7077936c4be27971c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a41f7dda7d0ad8cc8a4559afcf2ad7"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a36a41f7dda7d0ad8cc8a4559afcf2ad7">rand_congruential</a> (uint64_t x, std::vector&lt; uint64_t &gt; &amp;state)</td></tr>
<tr class="memdesc:a36a41f7dda7d0ad8cc8a4559afcf2ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Congruential pseudorandom number generation algorithm (wrapper)  <a href="namespacetheoretica.html#a36a41f7dda7d0ad8cc8a4559afcf2ad7">More...</a><br /></td></tr>
<tr class="separator:a36a41f7dda7d0ad8cc8a4559afcf2ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6faedb3d913a589365b108f5ec304e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aed6faedb3d913a589365b108f5ec304e">rand_xoshiro</a> (uint64_t &amp;a, uint64_t &amp;b, uint64_t &amp;c, uint64_t &amp;d)</td></tr>
<tr class="memdesc:aed6faedb3d913a589365b108f5ec304e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Xoshiro256++ pseudorandom number generation algorithm.  <a href="namespacetheoretica.html#aed6faedb3d913a589365b108f5ec304e">More...</a><br /></td></tr>
<tr class="separator:aed6faedb3d913a589365b108f5ec304e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b30362a1d08c8522c5297efd6f4a47"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a13b30362a1d08c8522c5297efd6f4a47">rand_xoshiro</a> (uint64_t x, std::vector&lt; uint64_t &gt; &amp;state)</td></tr>
<tr class="memdesc:a13b30362a1d08c8522c5297efd6f4a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Xoshiro256++ pseudorandom number generation algorithm.  <a href="namespacetheoretica.html#a13b30362a1d08c8522c5297efd6f4a47">More...</a><br /></td></tr>
<tr class="separator:a13b30362a1d08c8522c5297efd6f4a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058181f973ba2744704e6c6211477a35"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a058181f973ba2744704e6c6211477a35">rand_splitmix64</a> (uint64_t x)</td></tr>
<tr class="memdesc:a058181f973ba2744704e6c6211477a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">SplitMix64 pseudorandom number generation.  <a href="namespacetheoretica.html#a058181f973ba2744704e6c6211477a35">More...</a><br /></td></tr>
<tr class="separator:a058181f973ba2744704e6c6211477a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad198dee1300488d1b3e51767d62beedf"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ad198dee1300488d1b3e51767d62beedf">rand_splitmix64</a> (uint64_t x, std::vector&lt; uint64_t &gt; &amp;p)</td></tr>
<tr class="memdesc:ad198dee1300488d1b3e51767d62beedf"><td class="mdescLeft">&#160;</td><td class="mdescRight">SplitMix64 pseudorandom number generation.  <a href="namespacetheoretica.html#ad198dee1300488d1b3e51767d62beedf">More...</a><br /></td></tr>
<tr class="separator:ad198dee1300488d1b3e51767d62beedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470e255aed45a7dba74af4af68b31d0d"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a470e255aed45a7dba74af4af68b31d0d">rand_wyrand</a> (uint64_t &amp;seed, uint64_t p1, uint64_t p2)</td></tr>
<tr class="memdesc:a470e255aed45a7dba74af4af68b31d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wyrand pseudorandom number generation.  <a href="namespacetheoretica.html#a470e255aed45a7dba74af4af68b31d0d">More...</a><br /></td></tr>
<tr class="separator:a470e255aed45a7dba74af4af68b31d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5deb3df62eb53ec187a4660d42d8d5f1"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a5deb3df62eb53ec187a4660d42d8d5f1">rand_wyrand</a> (uint64_t x, std::vector&lt; uint64_t &gt; &amp;p)</td></tr>
<tr class="memdesc:a5deb3df62eb53ec187a4660d42d8d5f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wyrand pseudorandom number generation.  <a href="namespacetheoretica.html#a5deb3df62eb53ec187a4660d42d8d5f1">More...</a><br /></td></tr>
<tr class="separator:a5deb3df62eb53ec187a4660d42d8d5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e523c1cc3621e7cbc1ac0df01913c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aa7e523c1cc3621e7cbc1ac0df01913c3">qrand_weyl</a> (unsigned int n, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> alpha=<a class="el" href="namespacetheoretica.html#a6a6de16e5ee81d340ff91dbadb99edde">INVPHI</a>)</td></tr>
<tr class="memdesc:aa7e523c1cc3621e7cbc1ac0df01913c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weyl quasi-random sequence.  <a href="namespacetheoretica.html#aa7e523c1cc3621e7cbc1ac0df01913c3">More...</a><br /></td></tr>
<tr class="separator:aa7e523c1cc3621e7cbc1ac0df01913c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5001951408c716ce4e6414cc45f420"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#a6c5001951408c716ce4e6414cc45f420">qrand_weyl_recurr</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> prev=0, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> alpha=<a class="el" href="namespacetheoretica.html#a6a6de16e5ee81d340ff91dbadb99edde">INVPHI</a>)</td></tr>
<tr class="memdesc:a6c5001951408c716ce4e6414cc45f420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weyl quasi-random sequence (computed with recurrence relation)  <a href="namespacetheoretica.html#a6c5001951408c716ce4e6414cc45f420">More...</a><br /></td></tr>
<tr class="separator:a6c5001951408c716ce4e6414cc45f420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaab56ddec7d197600964cb78ada9a86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#aeaab56ddec7d197600964cb78ada9a86">rand_dist_tac</a> (<a class="el" href="namespacetheoretica.html#a007564925b46b1a8a4038ad371e9052b">stat_function</a> f, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;theta, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x1, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x2, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> y1, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> y2, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g, unsigned int max_iter=<a class="el" href="namespacetheoretica.html#a3299f783527ae72a24c832a7b1cd8ef8">MAX_TRYANDCATCH_ITER</a>)</td></tr>
<tr class="memdesc:aeaab56ddec7d197600964cb78ada9a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a pseudorandom value following any probability distribution function using the Try-and-Catch (rejection) algorithm.  <a href="namespacetheoretica.html#aeaab56ddec7d197600964cb78ada9a86">More...</a><br /></td></tr>
<tr class="separator:aeaab56ddec7d197600964cb78ada9a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bdf0dc89459fedaf6950c0f9b96df5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ac8bdf0dc89459fedaf6950c0f9b96df5">rand_gaussian_polar</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> <a class="el" href="namespacetheoretica.html#a63412fa6d4323c24f2c571dfc6b14e1d">mean</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> sigma, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:ac8bdf0dc89459fedaf6950c0f9b96df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number following a Gaussian distribution using Marsaglia's polar method.  <a href="namespacetheoretica.html#ac8bdf0dc89459fedaf6950c0f9b96df5">More...</a><br /></td></tr>
<tr class="separator:ac8bdf0dc89459fedaf6950c0f9b96df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae595e5ecfb8203ca342082a721180331"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetheoretica.html#ae595e5ecfb8203ca342082a721180331">rand_gaussian_clt</a> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x1, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x2, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g, unsigned int iter=10)</td></tr>
<tr class="memdesc:ae595e5ecfb8203ca342082a721180331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number in a range following a Gaussian distribution by exploiting the Central Limit Theorem.  <a href="namespacetheoretica.html#ae595e5ecfb8203ca342082a721180331">More...</a><br /></td></tr>
<tr class="separator:ae595e5ecfb8203ca342082a721180331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856e584fd661d664a36cb185c8abd6ba"><td class="memItemLeft" align="right" valign="top"><a id="a856e584fd661d664a36cb185c8abd6ba" name="a856e584fd661d664a36cb185c8abd6ba"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rand_gaussian</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> <a class="el" href="namespacetheoretica.html#a63412fa6d4323c24f2c571dfc6b14e1d">mean</a>, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> sigma, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a856e584fd661d664a36cb185c8abd6ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number following a Gaussian distribution using the best available algorithm. <br /></td></tr>
<tr class="separator:a856e584fd661d664a36cb185c8abd6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fc6d88e78808dfe4a4bbb03798a754"><td class="memItemLeft" align="right" valign="top"><a id="a40fc6d88e78808dfe4a4bbb03798a754" name="a40fc6d88e78808dfe4a4bbb03798a754"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rand_exponential</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> lambda, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a40fc6d88e78808dfe4a4bbb03798a754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number following an exponential distribution using the quantile (inverse) function method. <br /></td></tr>
<tr class="separator:a40fc6d88e78808dfe4a4bbb03798a754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34a4b6660c0287dc6dfa979a2f83002"><td class="memItemLeft" align="right" valign="top"><a id="ac34a4b6660c0287dc6dfa979a2f83002" name="ac34a4b6660c0287dc6dfa979a2f83002"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rand_cauchy</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> mu, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> alpha, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:ac34a4b6660c0287dc6dfa979a2f83002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number following a Cauchy distribution using the quantile (inverse) function method. <br /></td></tr>
<tr class="separator:ac34a4b6660c0287dc6dfa979a2f83002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b34801047d52afccf3b4120c3d2d74e"><td class="memItemLeft" align="right" valign="top"><a id="a2b34801047d52afccf3b4120c3d2d74e" name="a2b34801047d52afccf3b4120c3d2d74e"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rand_pareto</b> (<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x_m, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> alpha, <a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;g)</td></tr>
<tr class="memdesc:a2b34801047d52afccf3b4120c3d2d74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number following a Pareto distribution using the quantile (inverse) function method. <br /></td></tr>
<tr class="separator:a2b34801047d52afccf3b4120c3d2d74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8a4ddbcba09177b1ba63397ead6119"><td class="memItemLeft" align="right" valign="top"><a id="a8e8a4ddbcba09177b1ba63397ead6119" name="a8e8a4ddbcba09177b1ba63397ead6119"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>likelihood</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;theta, <a class="el" href="namespacetheoretica.html#a007564925b46b1a8a4038ad371e9052b">stat_function</a> f)</td></tr>
<tr class="memdesc:a8e8a4ddbcba09177b1ba63397ead6119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the likelihood of a distribution &lt;f&gt; with the given parameters &lt;theta&gt; and measures &lt;X&gt; <br /></td></tr>
<tr class="separator:a8e8a4ddbcba09177b1ba63397ead6119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a7d7ea9328cce28ccedceb3cbfe806"><td class="memItemLeft" align="right" valign="top"><a id="ad4a7d7ea9328cce28ccedceb3cbfe806" name="ad4a7d7ea9328cce28ccedceb3cbfe806"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>log_likelihood</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;theta, <a class="el" href="namespacetheoretica.html#a007564925b46b1a8a4038ad371e9052b">stat_function</a> f)</td></tr>
<tr class="memdesc:ad4a7d7ea9328cce28ccedceb3cbfe806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the log likelihood of a distribution &lt;f&gt; with the given parameters &lt;theta&gt; and measures &lt;X&gt; <br /></td></tr>
<tr class="separator:ad4a7d7ea9328cce28ccedceb3cbfe806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae123cdac0d487fd0cc12a32dc06672d6"><td class="memItemLeft" align="right" valign="top"><a id="ae123cdac0d487fd0cc12a32dc06672d6" name="ae123cdac0d487fd0cc12a32dc06672d6"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>arithmetic_mean</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data)</td></tr>
<tr class="memdesc:ae123cdac0d487fd0cc12a32dc06672d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arithmetic mean of a set of values. <br /></td></tr>
<tr class="separator:ae123cdac0d487fd0cc12a32dc06672d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63412fa6d4323c24f2c571dfc6b14e1d"><td class="memItemLeft" align="right" valign="top"><a id="a63412fa6d4323c24f2c571dfc6b14e1d" name="a63412fa6d4323c24f2c571dfc6b14e1d"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mean</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data)</td></tr>
<tr class="memdesc:a63412fa6d4323c24f2c571dfc6b14e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the arithmetic mean of a set of values Alias for arithmetic_mean. <br /></td></tr>
<tr class="separator:a63412fa6d4323c24f2c571dfc6b14e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417963e2cd3792705565275926c54f0c"><td class="memItemLeft" align="right" valign="top"><a id="a417963e2cd3792705565275926c54f0c" name="a417963e2cd3792705565275926c54f0c"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>harmonic_mean</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data)</td></tr>
<tr class="memdesc:a417963e2cd3792705565275926c54f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the harmonic mean of a set of values. <br /></td></tr>
<tr class="separator:a417963e2cd3792705565275926c54f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41411deb0f028d9ff90e06f9dd703b3f"><td class="memItemLeft" align="right" valign="top"><a id="a41411deb0f028d9ff90e06f9dd703b3f" name="a41411deb0f028d9ff90e06f9dd703b3f"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>geometric_mean</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data)</td></tr>
<tr class="memdesc:a41411deb0f028d9ff90e06f9dd703b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the geometric mean of a set of values as \(\sqrt[n]{\Pi_i x_i}\). <br /></td></tr>
<tr class="separator:a41411deb0f028d9ff90e06f9dd703b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301b9526d5e857f82786aa83af8f0d44"><td class="memItemLeft" align="right" valign="top"><a id="a301b9526d5e857f82786aa83af8f0d44" name="a301b9526d5e857f82786aa83af8f0d44"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>weighted_mean</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;weights)</td></tr>
<tr class="memdesc:a301b9526d5e857f82786aa83af8f0d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the weighted mean of a set of values &lt;data&gt; and &lt;weights&gt; must have the same size. <br /></td></tr>
<tr class="separator:a301b9526d5e857f82786aa83af8f0d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c42fd9cadef340b3420309453758078"><td class="memItemLeft" align="right" valign="top"><a id="a5c42fd9cadef340b3420309453758078" name="a5c42fd9cadef340b3420309453758078"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>propagate_sum</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;sigma)</td></tr>
<tr class="memdesc:a5c42fd9cadef340b3420309453758078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate error of a sum of values as sqrt(sigma_x^2 + sigma_y^2 + ...) <br /></td></tr>
<tr class="separator:a5c42fd9cadef340b3420309453758078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8729f104e3aec72c05706a8d56a1de"><td class="memItemLeft" align="right" valign="top"><a id="aad8729f104e3aec72c05706a8d56a1de" name="aad8729f104e3aec72c05706a8d56a1de"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>propagate_product</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;sigma, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;<a class="el" href="namespacetheoretica.html#a63412fa6d4323c24f2c571dfc6b14e1d">mean</a>)</td></tr>
<tr class="memdesc:aad8729f104e3aec72c05706a8d56a1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate error of a product (or quotient) of values as sqrt((sigma_x / x_mean)^2 + (sigma_y / y_mean)^2 + ...) The result is the propagated relative error. <br /></td></tr>
<tr class="separator:aad8729f104e3aec72c05706a8d56a1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139baf6d0864102002eb1f7973570f8a"><td class="memItemLeft" align="right" valign="top"><a id="a139baf6d0864102002eb1f7973570f8a" name="a139baf6d0864102002eb1f7973570f8a"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rms</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X)</td></tr>
<tr class="memdesc:a139baf6d0864102002eb1f7973570f8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Root Mean Square Computed as sqrt(sum(x_i^2) / N) <br /></td></tr>
<tr class="separator:a139baf6d0864102002eb1f7973570f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0857f4b940f5790cd733317780b8ad3"><td class="memItemLeft" align="right" valign="top"><a id="ad0857f4b940f5790cd733317780b8ad3" name="ad0857f4b940f5790cd733317780b8ad3"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>total_sum_squares</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X)</td></tr>
<tr class="memdesc:ad0857f4b940f5790cd733317780b8ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total sum of squares (TSS) Computed as sum(square(x_i - x_mean)) <br /></td></tr>
<tr class="separator:ad0857f4b940f5790cd733317780b8ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3acaf39bd4f7e9c87e1fb72768de32"><td class="memItemLeft" align="right" valign="top"><a id="a2a3acaf39bd4f7e9c87e1fb72768de32" name="a2a3acaf39bd4f7e9c87e1fb72768de32"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tss</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X)</td></tr>
<tr class="memdesc:a2a3acaf39bd4f7e9c87e1fb72768de32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total sum of squares (TSS) Computed as sum(square(x_i - x_mean)) <br /></td></tr>
<tr class="separator:a2a3acaf39bd4f7e9c87e1fb72768de32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c4321efb6e8ba42e62eef768e30924"><td class="memItemLeft" align="right" valign="top"><a id="a17c4321efb6e8ba42e62eef768e30924" name="a17c4321efb6e8ba42e62eef768e30924"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>variance</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data)</td></tr>
<tr class="memdesc:a17c4321efb6e8ba42e62eef768e30924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the variance of a population. <br /></td></tr>
<tr class="separator:a17c4321efb6e8ba42e62eef768e30924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638369113c0be46702092755e3b3d485"><td class="memItemLeft" align="right" valign="top"><a id="a638369113c0be46702092755e3b3d485" name="a638369113c0be46702092755e3b3d485"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sample_variance</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data)</td></tr>
<tr class="memdesc:a638369113c0be46702092755e3b3d485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the variance of a sample This function uses Bessel correction. <br /></td></tr>
<tr class="separator:a638369113c0be46702092755e3b3d485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b89c11ebe910e4da6eff8e23100fb3"><td class="memItemLeft" align="right" valign="top"><a id="af9b89c11ebe910e4da6eff8e23100fb3" name="af9b89c11ebe910e4da6eff8e23100fb3"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>standard_deviation</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data)</td></tr>
<tr class="memdesc:af9b89c11ebe910e4da6eff8e23100fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the standard deviation of a population. <br /></td></tr>
<tr class="separator:af9b89c11ebe910e4da6eff8e23100fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69e38f6bd2b461c238693537f5faa24"><td class="memItemLeft" align="right" valign="top"><a id="af69e38f6bd2b461c238693537f5faa24" name="af69e38f6bd2b461c238693537f5faa24"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>stdev</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data)</td></tr>
<tr class="memdesc:af69e38f6bd2b461c238693537f5faa24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the standard deviation of a population. <br /></td></tr>
<tr class="separator:af69e38f6bd2b461c238693537f5faa24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7748584aef1c94107441ca9e921daefb"><td class="memItemLeft" align="right" valign="top"><a id="a7748584aef1c94107441ca9e921daefb" name="a7748584aef1c94107441ca9e921daefb"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sample_standard_deviation</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data)</td></tr>
<tr class="memdesc:a7748584aef1c94107441ca9e921daefb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the standard deviation of a sample. <br /></td></tr>
<tr class="separator:a7748584aef1c94107441ca9e921daefb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c956ff97660f395a7b603673eb648e4"><td class="memItemLeft" align="right" valign="top"><a id="a7c956ff97660f395a7b603673eb648e4" name="a7c956ff97660f395a7b603673eb648e4"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>smpl_stdev</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data)</td></tr>
<tr class="memdesc:a7c956ff97660f395a7b603673eb648e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the standard deviation of a sample. <br /></td></tr>
<tr class="separator:a7c956ff97660f395a7b603673eb648e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83ed7e95c4ab0b5910c30384f48b554"><td class="memItemLeft" align="right" valign="top"><a id="ad83ed7e95c4ab0b5910c30384f48b554" name="ad83ed7e95c4ab0b5910c30384f48b554"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>standard_relative_error</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X)</td></tr>
<tr class="memdesc:ad83ed7e95c4ab0b5910c30384f48b554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the relative error on a population measure using standard deviation. <br /></td></tr>
<tr class="separator:ad83ed7e95c4ab0b5910c30384f48b554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b77710d75bde23b067dfe85aa460561"><td class="memItemLeft" align="right" valign="top"><a id="a9b77710d75bde23b067dfe85aa460561" name="a9b77710d75bde23b067dfe85aa460561"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sample_standard_relative_error</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X)</td></tr>
<tr class="memdesc:a9b77710d75bde23b067dfe85aa460561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the relative error on a sample measure using standard deviation. <br /></td></tr>
<tr class="separator:a9b77710d75bde23b067dfe85aa460561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac12b99fe1e96268796f1d2100f7649"><td class="memItemLeft" align="right" valign="top"><a id="a3ac12b99fe1e96268796f1d2100f7649" name="a3ac12b99fe1e96268796f1d2100f7649"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mean_standard_deviation</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data)</td></tr>
<tr class="memdesc:a3ac12b99fe1e96268796f1d2100f7649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the standard deviation on the mean of a set of values. <br /></td></tr>
<tr class="separator:a3ac12b99fe1e96268796f1d2100f7649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea2bd4390f09c4a28c18f12c67383c3"><td class="memItemLeft" align="right" valign="top"><a id="a1ea2bd4390f09c4a28c18f12c67383c3" name="a1ea2bd4390f09c4a28c18f12c67383c3"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>stdom</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data)</td></tr>
<tr class="memdesc:a1ea2bd4390f09c4a28c18f12c67383c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the standard deviation on the mean of a set of values. <br /></td></tr>
<tr class="separator:a1ea2bd4390f09c4a28c18f12c67383c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5783be076823764d2c2dbb91b365a4b"><td class="memItemLeft" align="right" valign="top"><a id="ab5783be076823764d2c2dbb91b365a4b" name="ab5783be076823764d2c2dbb91b365a4b"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sample_mean_standard_deviation</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data)</td></tr>
<tr class="memdesc:ab5783be076823764d2c2dbb91b365a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the standard deviation on the mean of a set of measures Bessel correction is used in the calculation of variance. <br /></td></tr>
<tr class="separator:ab5783be076823764d2c2dbb91b365a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533d837210e486032eaffee74aabc909"><td class="memItemLeft" align="right" valign="top"><a id="a533d837210e486032eaffee74aabc909" name="a533d837210e486032eaffee74aabc909"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>smpl_stdom</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data)</td></tr>
<tr class="memdesc:a533d837210e486032eaffee74aabc909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the standard deviation on the mean of a set of measures Bessel correction is used in the calculation of variance. <br /></td></tr>
<tr class="separator:a533d837210e486032eaffee74aabc909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866cc382ff78470c179bebec73ffd7a9"><td class="memItemLeft" align="right" valign="top"><a id="a866cc382ff78470c179bebec73ffd7a9" name="a866cc382ff78470c179bebec73ffd7a9"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>covariance</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y)</td></tr>
<tr class="memdesc:a866cc382ff78470c179bebec73ffd7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the covariance of two sets of measures. <br /></td></tr>
<tr class="separator:a866cc382ff78470c179bebec73ffd7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd67e52123a8b943d41216102e3248c"><td class="memItemLeft" align="right" valign="top"><a id="a9fd67e52123a8b943d41216102e3248c" name="a9fd67e52123a8b943d41216102e3248c"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sample_covariance</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y)</td></tr>
<tr class="memdesc:a9fd67e52123a8b943d41216102e3248c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the covariance between two sets of sample measures This function uses Bessel correction. <br /></td></tr>
<tr class="separator:a9fd67e52123a8b943d41216102e3248c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443605539362b54c90d073de610a5ee8"><td class="memItemLeft" align="right" valign="top"><a id="a443605539362b54c90d073de610a5ee8" name="a443605539362b54c90d073de610a5ee8"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>correlation_coefficient</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y)</td></tr>
<tr class="memdesc:a443605539362b54c90d073de610a5ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pearson's correlation coefficient R for a population. <br /></td></tr>
<tr class="separator:a443605539362b54c90d073de610a5ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d59f457c7baf9e58eb44e990d79c149"><td class="memItemLeft" align="right" valign="top"><a id="a6d59f457c7baf9e58eb44e990d79c149" name="a6d59f457c7baf9e58eb44e990d79c149"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sample_correlation_coefficient</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y)</td></tr>
<tr class="memdesc:a6d59f457c7baf9e58eb44e990d79c149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pearson's correlation coefficient r for a sample. <br /></td></tr>
<tr class="separator:a6d59f457c7baf9e58eb44e990d79c149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaeefec30503e31f02b0903ff766d757"><td class="memItemLeft" align="right" valign="top"><a id="aaaeefec30503e31f02b0903ff766d757" name="aaaeefec30503e31f02b0903ff766d757"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>chi_square_sigma</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X)</td></tr>
<tr class="memdesc:aaaeefec30503e31f02b0903ff766d757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normal distribution chi-square with 4 intervals calculated on a sample of measures. <br /></td></tr>
<tr class="separator:aaaeefec30503e31f02b0903ff766d757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84617261decc110caf3052d68f06d7d4"><td class="memItemLeft" align="right" valign="top"><a id="a84617261decc110caf3052d68f06d7d4" name="a84617261decc110caf3052d68f06d7d4"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>least_squares_linear_intercept</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y)</td></tr>
<tr class="memdesc:a84617261decc110caf3052d68f06d7d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the intercept of the minimum squares linearization of X and Y. <br /></td></tr>
<tr class="separator:a84617261decc110caf3052d68f06d7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6955f75727be37a27e0927224e5876"><td class="memItemLeft" align="right" valign="top"><a id="a0f6955f75727be37a27e0927224e5876" name="a0f6955f75727be37a27e0927224e5876"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lst_sqrs_lin_intercept</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y)</td></tr>
<tr class="memdesc:a0f6955f75727be37a27e0927224e5876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the intercept of the minimum squares linearization of X and Y. <br /></td></tr>
<tr class="separator:a0f6955f75727be37a27e0927224e5876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada975e288bf5570bca3945af38a51220"><td class="memItemLeft" align="right" valign="top"><a id="ada975e288bf5570bca3945af38a51220" name="ada975e288bf5570bca3945af38a51220"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>least_squares_linear_sigma_A</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> sigma_y)</td></tr>
<tr class="memdesc:ada975e288bf5570bca3945af38a51220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the error on the intercept (A) <br /></td></tr>
<tr class="separator:ada975e288bf5570bca3945af38a51220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6bb7752cf25bc4154c3487384eb0841"><td class="memItemLeft" align="right" valign="top"><a id="ab6bb7752cf25bc4154c3487384eb0841" name="ab6bb7752cf25bc4154c3487384eb0841"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>least_squares_linear_slope</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y)</td></tr>
<tr class="memdesc:ab6bb7752cf25bc4154c3487384eb0841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the slope of the minimum squares linearization of X and Y. <br /></td></tr>
<tr class="separator:ab6bb7752cf25bc4154c3487384eb0841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8eefa3fdd67863bd14365f6332935ed"><td class="memItemLeft" align="right" valign="top"><a id="ac8eefa3fdd67863bd14365f6332935ed" name="ac8eefa3fdd67863bd14365f6332935ed"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lst_sqrs_lin_slope</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y)</td></tr>
<tr class="memdesc:ac8eefa3fdd67863bd14365f6332935ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the slope of the minimum squares linearization of X and Y. <br /></td></tr>
<tr class="separator:ac8eefa3fdd67863bd14365f6332935ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa5671fbee3d70db0b7b71f7afe7d78"><td class="memItemLeft" align="right" valign="top"><a id="acfa5671fbee3d70db0b7b71f7afe7d78" name="acfa5671fbee3d70db0b7b71f7afe7d78"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>least_squares_linear_sigma_B</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> sigma_y)</td></tr>
<tr class="memdesc:acfa5671fbee3d70db0b7b71f7afe7d78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the error on the slope coefficient (B) <br /></td></tr>
<tr class="separator:acfa5671fbee3d70db0b7b71f7afe7d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c799e8666d59de6de60326dcc09294e"><td class="memItemLeft" align="right" valign="top"><a id="a3c799e8666d59de6de60326dcc09294e" name="a3c799e8666d59de6de60326dcc09294e"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>least_squares_linear_error</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> intercept, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> slope)</td></tr>
<tr class="memdesc:a3c799e8666d59de6de60326dcc09294e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the error of the minimum squares linearization of a sample. <br /></td></tr>
<tr class="separator:a3c799e8666d59de6de60326dcc09294e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543e7d1f53e6e88371ae148abcd3bbc3"><td class="memItemLeft" align="right" valign="top"><a id="a543e7d1f53e6e88371ae148abcd3bbc3" name="a543e7d1f53e6e88371ae148abcd3bbc3"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lst_sqrs_lin_error</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> intercept, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> slope)</td></tr>
<tr class="memdesc:a543e7d1f53e6e88371ae148abcd3bbc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the error of the minimum squares linearization of a sample. <br /></td></tr>
<tr class="separator:a543e7d1f53e6e88371ae148abcd3bbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad04a75aef8d4652b07e330779fb3ea3"><td class="memItemLeft" align="right" valign="top"><a id="aad04a75aef8d4652b07e330779fb3ea3" name="aad04a75aef8d4652b07e330779fb3ea3"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>chi_square_linearization</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;sigma, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> intercept, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> slope)</td></tr>
<tr class="memdesc:aad04a75aef8d4652b07e330779fb3ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the chi-square on a linearization. <br /></td></tr>
<tr class="separator:aad04a75aef8d4652b07e330779fb3ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba036e24bb6cda4b1f7dc901387f88ad"><td class="memItemLeft" align="right" valign="top"><a id="aba036e24bb6cda4b1f7dc901387f88ad" name="aba036e24bb6cda4b1f7dc901387f88ad"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>reduced_chi_square_linearization</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;sigma, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> intercept, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> slope)</td></tr>
<tr class="memdesc:aba036e24bb6cda4b1f7dc901387f88ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the reduced chi-squared on a linearization. <br /></td></tr>
<tr class="separator:aba036e24bb6cda4b1f7dc901387f88ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b76d028b67c36167f9b7b2b9ecc368"><td class="memItemLeft" align="right" valign="top"><a id="a38b76d028b67c36167f9b7b2b9ecc368" name="a38b76d028b67c36167f9b7b2b9ecc368"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>least_squares_weighted_linear_intercept</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;W)</td></tr>
<tr class="memdesc:a38b76d028b67c36167f9b7b2b9ecc368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the intercept of the weighted minimum squares linearization of X and Y. <br /></td></tr>
<tr class="separator:a38b76d028b67c36167f9b7b2b9ecc368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7787cd3050ea6b521f585061c8d8e024"><td class="memItemLeft" align="right" valign="top"><a id="a7787cd3050ea6b521f585061c8d8e024" name="a7787cd3050ea6b521f585061c8d8e024"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lst_sqrs_weight_lin_intercept</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;W)</td></tr>
<tr class="memdesc:a7787cd3050ea6b521f585061c8d8e024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the intercept of the weighted minimum squares linearization of X and Y. <br /></td></tr>
<tr class="separator:a7787cd3050ea6b521f585061c8d8e024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac738af92a679b937956c3aaba943363b"><td class="memItemLeft" align="right" valign="top"><a id="ac738af92a679b937956c3aaba943363b" name="ac738af92a679b937956c3aaba943363b"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>least_squares_weighted_linear_slope</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;W)</td></tr>
<tr class="memdesc:ac738af92a679b937956c3aaba943363b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the slope of the weighted minimum squares linearization of X and Y. <br /></td></tr>
<tr class="separator:ac738af92a679b937956c3aaba943363b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad340e45331b7332ee2fb72e6978d82a0"><td class="memItemLeft" align="right" valign="top"><a id="ad340e45331b7332ee2fb72e6978d82a0" name="ad340e45331b7332ee2fb72e6978d82a0"></a>
<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lst_sqrs_weight_lin_slope</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;Y, const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;W)</td></tr>
<tr class="memdesc:ad340e45331b7332ee2fb72e6978d82a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the slope of the weighted minimum squares linearization of X and Y. <br /></td></tr>
<tr class="separator:ad340e45331b7332ee2fb72e6978d82a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e6e2c5bdb91e13ded2b2dade8db313"><td class="memItemLeft" align="right" valign="top"><a id="a46e6e2c5bdb91e13ded2b2dade8db313" name="a46e6e2c5bdb91e13ded2b2dade8db313"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print_vec_buff</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;v)</td></tr>
<tr class="memdesc:a46e6e2c5bdb91e13ded2b2dade8db313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a <code>vec_buff</code> data set to standard output. <br /></td></tr>
<tr class="separator:a46e6e2c5bdb91e13ded2b2dade8db313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b9197f6d8fd21a23230a198f4f89cb"><td class="memItemLeft" align="right" valign="top"><a id="a75b9197f6d8fd21a23230a198f4f89cb" name="a75b9197f6d8fd21a23230a198f4f89cb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print_vec_buff_row</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;v)</td></tr>
<tr class="memdesc:a75b9197f6d8fd21a23230a198f4f89cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a <code>vec_buff</code> data set to standard output on a single row. <br /></td></tr>
<tr class="separator:a75b9197f6d8fd21a23230a198f4f89cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d109f364f62514400e78055bb20e37"><td class="memItemLeft" align="right" valign="top"><a id="ae1d109f364f62514400e78055bb20e37" name="ae1d109f364f62514400e78055bb20e37"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>insert_data</b> (<a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;data, std::string terminator)</td></tr>
<tr class="memdesc:ae1d109f364f62514400e78055bb20e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a <code>vec_buff</code> data set from standard input. <br /></td></tr>
<tr class="separator:ae1d109f364f62514400e78055bb20e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa6ab1410e345f5640776ae889a6be5"><td class="memItemLeft" align="right" valign="top"><a id="a2aa6ab1410e345f5640776ae889a6be5" name="a2aa6ab1410e345f5640776ae889a6be5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print_sample_stats</b> (const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;X)</td></tr>
<tr class="memdesc:a2aa6ab1410e345f5640776ae889a6be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print common statistical information about a <code>vec_buff</code> data set. <br /></td></tr>
<tr class="separator:a2aa6ab1410e345f5640776ae889a6be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa34d8798921a9b3b78e885a455ff4211"><td class="memItemLeft" align="right" valign="top"><a id="aa34d8798921a9b3b78e885a455ff4211" name="aa34d8798921a9b3b78e885a455ff4211"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MACH_EPSILON</b> = std::numeric_limits&lt;<a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&gt;::epsilon()</td></tr>
<tr class="memdesc:aa34d8798921a9b3b78e885a455ff4211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Machine epsilon for the real type. <br /></td></tr>
<tr class="separator:aa34d8798921a9b3b78e885a455ff4211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8245ba56baa7620ff9d0d9ccfbc53f"><td class="memItemLeft" align="right" valign="top"><a id="ace8245ba56baa7620ff9d0d9ccfbc53f" name="ace8245ba56baa7620ff9d0d9ccfbc53f"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PHI</b> = 1.6180339887498948482045868</td></tr>
<tr class="memdesc:ace8245ba56baa7620ff9d0d9ccfbc53f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Phi (Golden Section) mathematical constant. <br /></td></tr>
<tr class="separator:ace8245ba56baa7620ff9d0d9ccfbc53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6de16e5ee81d340ff91dbadb99edde"><td class="memItemLeft" align="right" valign="top"><a id="a6a6de16e5ee81d340ff91dbadb99edde" name="a6a6de16e5ee81d340ff91dbadb99edde"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>INVPHI</b> = 0.6180339887498948482045868</td></tr>
<tr class="memdesc:a6a6de16e5ee81d340ff91dbadb99edde"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse of the Golden Section mathematical constant. <br /></td></tr>
<tr class="separator:a6a6de16e5ee81d340ff91dbadb99edde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93349020a59cf77efcca5bb77c0e7f9"><td class="memItemLeft" align="right" valign="top"><a id="ae93349020a59cf77efcca5bb77c0e7f9" name="ae93349020a59cf77efcca5bb77c0e7f9"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PI</b> = 3.141592653589793238462643</td></tr>
<tr class="memdesc:ae93349020a59cf77efcca5bb77c0e7f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Pi mathematical constant. <br /></td></tr>
<tr class="separator:ae93349020a59cf77efcca5bb77c0e7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b5dac597409564afdc448fbef23eae"><td class="memItemLeft" align="right" valign="top"><a id="a27b5dac597409564afdc448fbef23eae" name="a27b5dac597409564afdc448fbef23eae"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PI2</b> = <a class="el" href="namespacetheoretica.html#ae93349020a59cf77efcca5bb77c0e7f9">PI</a> / 2.0</td></tr>
<tr class="memdesc:a27b5dac597409564afdc448fbef23eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Half of Pi. <br /></td></tr>
<tr class="separator:a27b5dac597409564afdc448fbef23eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f9025deb90bc4fd64fb9260340e3f2"><td class="memItemLeft" align="right" valign="top"><a id="ac7f9025deb90bc4fd64fb9260340e3f2" name="ac7f9025deb90bc4fd64fb9260340e3f2"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PI4</b> = <a class="el" href="namespacetheoretica.html#ae93349020a59cf77efcca5bb77c0e7f9">PI</a> / 4.0</td></tr>
<tr class="memdesc:ac7f9025deb90bc4fd64fb9260340e3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A quarter of Pi. <br /></td></tr>
<tr class="separator:ac7f9025deb90bc4fd64fb9260340e3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974f2fd34520034645cb5c96487c6ed4"><td class="memItemLeft" align="right" valign="top"><a id="a974f2fd34520034645cb5c96487c6ed4" name="a974f2fd34520034645cb5c96487c6ed4"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PIDOUBLE</b> = <a class="el" href="namespacetheoretica.html#ae93349020a59cf77efcca5bb77c0e7f9">PI</a> * 2</td></tr>
<tr class="memdesc:a974f2fd34520034645cb5c96487c6ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pi multiplied by 2. <br /></td></tr>
<tr class="separator:a974f2fd34520034645cb5c96487c6ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6a742ab030fe585063215a644f60df"><td class="memItemLeft" align="right" valign="top"><a id="aeb6a742ab030fe585063215a644f60df" name="aeb6a742ab030fe585063215a644f60df"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>TAU</b> = <a class="el" href="namespacetheoretica.html#ae93349020a59cf77efcca5bb77c0e7f9">PI</a> * 2</td></tr>
<tr class="memdesc:aeb6a742ab030fe585063215a644f60df"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Tau mathematical constant (Pi times 2) <br /></td></tr>
<tr class="separator:aeb6a742ab030fe585063215a644f60df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6916417c8d2b817cfc48b8e2a1abb5"><td class="memItemLeft" align="right" valign="top"><a id="a4d6916417c8d2b817cfc48b8e2a1abb5" name="a4d6916417c8d2b817cfc48b8e2a1abb5"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>INVPI</b> = 1.0 / <a class="el" href="namespacetheoretica.html#ae93349020a59cf77efcca5bb77c0e7f9">PI</a></td></tr>
<tr class="memdesc:a4d6916417c8d2b817cfc48b8e2a1abb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse of Pi. <br /></td></tr>
<tr class="separator:a4d6916417c8d2b817cfc48b8e2a1abb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37fb7f2271fa0e9cd55b47cf4641ca45"><td class="memItemLeft" align="right" valign="top"><a id="a37fb7f2271fa0e9cd55b47cf4641ca45" name="a37fb7f2271fa0e9cd55b47cf4641ca45"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SQRTPI</b> = 1.772454</td></tr>
<tr class="memdesc:a37fb7f2271fa0e9cd55b47cf4641ca45"><td class="mdescLeft">&#160;</td><td class="mdescRight">The square root of Pi. <br /></td></tr>
<tr class="separator:a37fb7f2271fa0e9cd55b47cf4641ca45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c0a5082e6b4428b15b7b02d16eafc7"><td class="memItemLeft" align="right" valign="top"><a id="aa3c0a5082e6b4428b15b7b02d16eafc7" name="aa3c0a5082e6b4428b15b7b02d16eafc7"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>E</b> = 2.718281828459045235360287</td></tr>
<tr class="memdesc:aa3c0a5082e6b4428b15b7b02d16eafc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Euler mathematical constant (e) <br /></td></tr>
<tr class="separator:aa3c0a5082e6b4428b15b7b02d16eafc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771e19568e0562e2fcccd740ec90dae4"><td class="memItemLeft" align="right" valign="top"><a id="a771e19568e0562e2fcccd740ec90dae4" name="a771e19568e0562e2fcccd740ec90dae4"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LOG2E</b> = 1.44269504088896338700465094</td></tr>
<tr class="memdesc:a771e19568e0562e2fcccd740ec90dae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The binary logarithm of e. <br /></td></tr>
<tr class="separator:a771e19568e0562e2fcccd740ec90dae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4145093692043269fa4c1ebef8b4890f"><td class="memItemLeft" align="right" valign="top"><a id="a4145093692043269fa4c1ebef8b4890f" name="a4145093692043269fa4c1ebef8b4890f"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LOG210</b> = 3.32192809488736218170856773213</td></tr>
<tr class="memdesc:a4145093692043269fa4c1ebef8b4890f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The binary logarithm of 10. <br /></td></tr>
<tr class="separator:a4145093692043269fa4c1ebef8b4890f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612238583a4ec50cebd32b4694d5cb9a"><td class="memItemLeft" align="right" valign="top"><a id="a612238583a4ec50cebd32b4694d5cb9a" name="a612238583a4ec50cebd32b4694d5cb9a"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LOG10E</b> = 0.434294481903</td></tr>
<tr class="memdesc:a612238583a4ec50cebd32b4694d5cb9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base-10 logarithm of e. <br /></td></tr>
<tr class="separator:a612238583a4ec50cebd32b4694d5cb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7021b7b588c9ea63d46679aaa1f7c6c4"><td class="memItemLeft" align="right" valign="top"><a id="a7021b7b588c9ea63d46679aaa1f7c6c4" name="a7021b7b588c9ea63d46679aaa1f7c6c4"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LN2</b> = 0.69314718056</td></tr>
<tr class="memdesc:a7021b7b588c9ea63d46679aaa1f7c6c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of 2. <br /></td></tr>
<tr class="separator:a7021b7b588c9ea63d46679aaa1f7c6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc384f25a1d4c7c19169a5ce6c51710"><td class="memItemLeft" align="right" valign="top"><a id="a3bc384f25a1d4c7c19169a5ce6c51710" name="a3bc384f25a1d4c7c19169a5ce6c51710"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LN10</b> = 2.30258509299</td></tr>
<tr class="memdesc:a3bc384f25a1d4c7c19169a5ce6c51710"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of 10. <br /></td></tr>
<tr class="separator:a3bc384f25a1d4c7c19169a5ce6c51710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0afb9f871b425c7454c388eb41a3c19"><td class="memItemLeft" align="right" valign="top"><a id="ae0afb9f871b425c7454c388eb41a3c19" name="ae0afb9f871b425c7454c388eb41a3c19"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DEG2RAD</b> = 0.017453292519943295474371680598</td></tr>
<tr class="memdesc:ae0afb9f871b425c7454c388eb41a3c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">The scalar conversion factor from degrees to radians. <br /></td></tr>
<tr class="separator:ae0afb9f871b425c7454c388eb41a3c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75cd5d78670f968bac3fbcfee6660b0"><td class="memItemLeft" align="right" valign="top"><a id="ae75cd5d78670f968bac3fbcfee6660b0" name="ae75cd5d78670f968bac3fbcfee6660b0"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RAD2DEG</b> = 57.2957795130823228646477218717</td></tr>
<tr class="memdesc:ae75cd5d78670f968bac3fbcfee6660b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The scalar conversion factor from radians to degrees. <br /></td></tr>
<tr class="separator:ae75cd5d78670f968bac3fbcfee6660b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3be7f003670e91509c8f2fac523fab8"><td class="memItemLeft" align="right" valign="top"><a id="ae3be7f003670e91509c8f2fac523fab8" name="ae3be7f003670e91509c8f2fac523fab8"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SQRT2</b> = 1.41421356237</td></tr>
<tr class="memdesc:ae3be7f003670e91509c8f2fac523fab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The square root of 2. <br /></td></tr>
<tr class="separator:ae3be7f003670e91509c8f2fac523fab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c1ffb22a0191558cafdaec71c3b81d"><td class="memItemLeft" align="right" valign="top"><a id="a42c1ffb22a0191558cafdaec71c3b81d" name="a42c1ffb22a0191558cafdaec71c3b81d"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>INVSQR2</b> = 0.707106781187</td></tr>
<tr class="memdesc:a42c1ffb22a0191558cafdaec71c3b81d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse of the square root of 2. <br /></td></tr>
<tr class="separator:a42c1ffb22a0191558cafdaec71c3b81d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b4341ceb440f57a5cae39fa7b5495c"><td class="memItemLeft" align="right" valign="top"><a id="ad6b4341ceb440f57a5cae39fa7b5495c" name="ad6b4341ceb440f57a5cae39fa7b5495c"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>TAYLOR_ORDER</b> = <a class="el" href="constants_8h.html#ad693d152d21cfd12f2d4c8bc8b1122e6">THEORETICA_TAYLOR_ORDER</a></td></tr>
<tr class="memdesc:ad6b4341ceb440f57a5cae39fa7b5495c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Order of Taylor series approximations. <br /></td></tr>
<tr class="separator:ad6b4341ceb440f57a5cae39fa7b5495c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f0e3448f94ada54d171499c0c95ae4"><td class="memItemLeft" align="right" valign="top"><a id="aa1f0e3448f94ada54d171499c0c95ae4" name="aa1f0e3448f94ada54d171499c0c95ae4"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>INTEGRATION_STEPS</b> = <a class="el" href="constants_8h.html#a95c498965a897914547a05283f79c804">THEORETICA_INTEGRATION_STEPS</a></td></tr>
<tr class="memdesc:aa1f0e3448f94ada54d171499c0c95ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default number of steps for integral approximation. <br /></td></tr>
<tr class="separator:aa1f0e3448f94ada54d171499c0c95ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbb4c38fc6708107926a7f3486036bc"><td class="memItemLeft" align="right" valign="top"><a id="a9dbb4c38fc6708107926a7f3486036bc" name="a9dbb4c38fc6708107926a7f3486036bc"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DERIV_PREC</b> = <a class="el" href="constants_8h.html#a6ff116b859afb29842f6366839e88cfd">THEORETICA_DERIV_PREC</a></td></tr>
<tr class="memdesc:a9dbb4c38fc6708107926a7f3486036bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relative precision for derivative approximation. <br /></td></tr>
<tr class="separator:a9dbb4c38fc6708107926a7f3486036bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c4976fd2f3c3dfdf02bffe927c4dd2"><td class="memItemLeft" align="right" valign="top"><a id="af0c4976fd2f3c3dfdf02bffe927c4dd2" name="af0c4976fd2f3c3dfdf02bffe927c4dd2"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>POWF_POWER_TOLERANCE</b> = <a class="el" href="constants_8h.html#a694c73eb196485f1bec84c5075600f89">THEORETICA_POWF_APPROX_TOL</a></td></tr>
<tr class="memdesc:af0c4976fd2f3c3dfdf02bffe927c4dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Biggest fractional part to ignore in powf computation. <br /></td></tr>
<tr class="separator:af0c4976fd2f3c3dfdf02bffe927c4dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4aa38ca4a41e22c4eeac0970da9b195"><td class="memItemLeft" align="right" valign="top"><a id="aa4aa38ca4a41e22c4eeac0970da9b195" name="aa4aa38ca4a41e22c4eeac0970da9b195"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ROOT_APPROX_TOL</b> = <a class="el" href="constants_8h.html#a021c58c225740fa33459a6378975e759">THEORETICA_ROOT_APPROX_TOL</a></td></tr>
<tr class="memdesc:aa4aa38ca4a41e22c4eeac0970da9b195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximation tolerance for root finding. <br /></td></tr>
<tr class="separator:aa4aa38ca4a41e22c4eeac0970da9b195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28fc38a93f999c3c98056f3dac665f42"><td class="memItemLeft" align="right" valign="top"><a id="a28fc38a93f999c3c98056f3dac665f42" name="a28fc38a93f999c3c98056f3dac665f42"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BISECTION_APPROX_TOL</b> = <a class="el" href="constants_8h.html#ae07bf3e063a76a489cc291c1684d2dda">THEORETICA_BISECTION_APPROX_TOL</a></td></tr>
<tr class="memdesc:a28fc38a93f999c3c98056f3dac665f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximation tolerance for the bisection algorithm. <br /></td></tr>
<tr class="separator:a28fc38a93f999c3c98056f3dac665f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a871a5ce0e15ea45205f3e15eec423"><td class="memItemLeft" align="right" valign="top"><a id="ae3a871a5ce0e15ea45205f3e15eec423" name="ae3a871a5ce0e15ea45205f3e15eec423"></a>
constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NEWTON_RAPHSON_TOL</b> = <a class="el" href="constants_8h.html#a961e7eb071044645d790bcf11974fa67">THEORETICA_NEWTON_RAPHSON_TOL</a></td></tr>
<tr class="memdesc:ae3a871a5ce0e15ea45205f3e15eec423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximation tolerance for the Newton-Raphson algorithm. <br /></td></tr>
<tr class="separator:ae3a871a5ce0e15ea45205f3e15eec423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0df4d0b21cc7dbcfaf869e88da40af"><td class="memItemLeft" align="right" valign="top"><a id="acf0df4d0b21cc7dbcfaf869e88da40af" name="acf0df4d0b21cc7dbcfaf869e88da40af"></a>
constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_BISECTION_ITER</b> = <a class="el" href="constants_8h.html#a81ceb9b6876df9fab0812a43d92a3c22">THEORETICA_MAX_BISECTION_ITER</a></td></tr>
<tr class="memdesc:acf0df4d0b21cc7dbcfaf869e88da40af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations for the bisection algorithm. <br /></td></tr>
<tr class="separator:acf0df4d0b21cc7dbcfaf869e88da40af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71451b0e74e1fe8a28d1c41bc954804"><td class="memItemLeft" align="right" valign="top"><a id="ac71451b0e74e1fe8a28d1c41bc954804" name="ac71451b0e74e1fe8a28d1c41bc954804"></a>
constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_GOLDENSECTION_ITER</b> = <a class="el" href="constants_8h.html#afeac310b6adedfb265330e760a147a80">THEORETICA_MAX_GOLDENSECTION_ITER</a></td></tr>
<tr class="memdesc:ac71451b0e74e1fe8a28d1c41bc954804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations for the golden section search algorithm. <br /></td></tr>
<tr class="separator:ac71451b0e74e1fe8a28d1c41bc954804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b14b1cb08bd3c634410570abf8258e"><td class="memItemLeft" align="right" valign="top"><a id="a10b14b1cb08bd3c634410570abf8258e" name="a10b14b1cb08bd3c634410570abf8258e"></a>
constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_HALLEY_ITER</b> = <a class="el" href="constants_8h.html#ab139026298fae1aafae59ac99dbcc2d6">THEORETICA_MAX_HALLEY_ITER</a></td></tr>
<tr class="memdesc:a10b14b1cb08bd3c634410570abf8258e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations for Halley's method. <br /></td></tr>
<tr class="separator:a10b14b1cb08bd3c634410570abf8258e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09bde3716d7598748a55fa65c9abb6e3"><td class="memItemLeft" align="right" valign="top"><a id="a09bde3716d7598748a55fa65c9abb6e3" name="a09bde3716d7598748a55fa65c9abb6e3"></a>
constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_NEWTON_ITER</b> = <a class="el" href="constants_8h.html#a7f8e8f98bdd6e74a743d5487d4b976aa">THEORETICA_MAX_NEWTON_ITER</a></td></tr>
<tr class="memdesc:a09bde3716d7598748a55fa65c9abb6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations for the Newton-Raphson algorithm. <br /></td></tr>
<tr class="separator:a09bde3716d7598748a55fa65c9abb6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3016878f7fd372f0c459c4776e8059"><td class="memItemLeft" align="right" valign="top"><a id="abe3016878f7fd372f0c459c4776e8059" name="abe3016878f7fd372f0c459c4776e8059"></a>
constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_STEFFENSEN_ITER</b> = <a class="el" href="constants_8h.html#a079d3def41600f49deb005b75b524adc">THEORETICA_MAX_STEFFENSEN_ITER</a></td></tr>
<tr class="memdesc:abe3016878f7fd372f0c459c4776e8059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations for the Steffensen algorithm. <br /></td></tr>
<tr class="separator:abe3016878f7fd372f0c459c4776e8059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f2aa11982032c3035e8458f17d9a43"><td class="memItemLeft" align="right" valign="top"><a id="a91f2aa11982032c3035e8458f17d9a43" name="a91f2aa11982032c3035e8458f17d9a43"></a>
constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_CHEBYSHEV_ITER</b> = <a class="el" href="constants_8h.html#a70db1d134cdacb5b4c1bc8ffac852a7b">THEORETICA_MAX_CHEBYSHEV_ITER</a></td></tr>
<tr class="memdesc:a91f2aa11982032c3035e8458f17d9a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations for the Chebyshev algorithm. <br /></td></tr>
<tr class="separator:a91f2aa11982032c3035e8458f17d9a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3299f783527ae72a24c832a7b1cd8ef8"><td class="memItemLeft" align="right" valign="top"><a id="a3299f783527ae72a24c832a7b1cd8ef8" name="a3299f783527ae72a24c832a7b1cd8ef8"></a>
constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_TRYANDCATCH_ITER</b> = <a class="el" href="constants_8h.html#a9185ccd5fcdd822ae6b8b06eb1437674">THEORETICA_MAX_TRYANDCATCH_ITER</a></td></tr>
<tr class="memdesc:a3299f783527ae72a24c832a7b1cd8ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of failed iterations for the Try-and-Catch algorithm. <br /></td></tr>
<tr class="separator:a3299f783527ae72a24c832a7b1cd8ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e48eab9ce5928d0c754a40ddb2d068f"><td class="memItemLeft" align="right" valign="top"><a id="a0e48eab9ce5928d0c754a40ddb2d068f" name="a0e48eab9ce5928d0c754a40ddb2d068f"></a>
constexpr uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>RAND_REAL_PREC</b> = <a class="el" href="constants_8h.html#ac13dd04d659ae36e514a06cd075f0e0e">THEORETICA_RAND_REAL_PREC</a></td></tr>
<tr class="memdesc:a0e48eab9ce5928d0c754a40ddb2d068f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default precision for random number generation using <a class="el" href="namespacetheoretica.html#aae266dabbc97f85eddaeb0466a07d325" title="Generate a pseudorandom real number in [a, b] using a preexisting generator.">rand_real()</a> <br /></td></tr>
<tr class="separator:a0e48eab9ce5928d0c754a40ddb2d068f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Main namespace of the library which contains all functions and objects. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a049966946220f1f7e5eae57293703066" name="a049966946220f1f7e5eae57293703066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a049966946220f1f7e5eae57293703066">&#9670;&nbsp;</a></span>real</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">theoretica::real</a> = typedef double</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A real number, defined as a floating point type. </p>
<p >The underlying type is determined by the defined macros: By default, <code>real</code> will be defined as the <code>double</code> type. If <code>THEORETICA_FLOAT_PREC</code> is defined, <code>real</code> will be defined as a <code>float</code>, if <code>THEORETICA_LONG_DOUBLE_PREC</code> is defined, <code>real</code> will be defined as a <code>long double</code> </p><dl class="section note"><dt>Note</dt><dd>The <code>THEORETICA_ARBITRARY_PREC</code> option is currently unsupported </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a0f49fa3c3999e2a64956c3cb44bf596c" name="a0f49fa3c3999e2a64956c3cb44bf596c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f49fa3c3999e2a64956c3cb44bf596c">&#9670;&nbsp;</a></span>abs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the modulus of a complex number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5177ff64d981840e149d1e282f1b27e" name="aa5177ff64d981840e149d1e282f1b27e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5177ff64d981840e149d1e282f1b27e">&#9670;&nbsp;</a></span>abs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the absolute value of a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The absolute value of x</dd></dl>
<p>On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fabs</code> instruction will be used. </p>

</div>
</div>
<a id="a8a281d198a95a4d2f0f85ccd003948f6" name="a8a281d198a95a4d2f0f85ccd003948f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a281d198a95a4d2f0f85ccd003948f6">&#9670;&nbsp;</a></span>acos() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a> theoretica::acos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the complex arccosine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f2d69e3a3387958a27d4a03ed478a99" name="a7f2d69e3a3387958a27d4a03ed478a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f2d69e3a3387958a27d4a03ed478a99">&#9670;&nbsp;</a></span>acos() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::acos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the arccosine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The arccosine of x</dd></dl>
<p>Domain: [-1, 1]. The identities \(asin(x) = atan(\frac{sqrt{1 - x^2}{x}})\) and \(asin(x) = atan(\frac{\sqrt{1 - x^2}{x}}) + \pi\) are used. </p>

</div>
</div>
<a id="ab99c87ef0ca077098ba3428a6e80956a" name="ab99c87ef0ca077098ba3428a6e80956a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99c87ef0ca077098ba3428a6e80956a">&#9670;&nbsp;</a></span>approx_integral_montecarlo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::approx_integral_montecarlo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>f_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>N</em> = <code>10000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate an integral by using Monte Carlo integration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate </td></tr>
    <tr><td class="paramname">a</td><td>The lower extreme of integration </td></tr>
    <tr><td class="paramname">b</td><td>The upper extreme of integration </td></tr>
    <tr><td class="paramname">f_max</td><td>The function maximum in the [a, b] interval </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> </td></tr>
    <tr><td class="paramname">N</td><td>The number of points to generate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6c4590079678ebac8a917eeda049bf4" name="ab6c4590079678ebac8a917eeda049bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c4590079678ebac8a917eeda049bf4">&#9670;&nbsp;</a></span>asin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a> theoretica::asin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the complex arcsine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79b06e5bf997c4447c10f2fa96649347" name="a79b06e5bf997c4447c10f2fa96649347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b06e5bf997c4447c10f2fa96649347">&#9670;&nbsp;</a></span>asin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::asin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the arcsine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The arcsine of x</dd></dl>
<p>Domain: [-1, 1]. The identity \(asin(x) = atan(\frac{x}{\sqrt{1 - x^2}})\) is used. </p>

</div>
</div>
<a id="a423991094f40604ba94e6ae9275d5ea8" name="a423991094f40604ba94e6ae9275d5ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a423991094f40604ba94e6ae9275d5ea8">&#9670;&nbsp;</a></span>atan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a> theoretica::atan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the complex arctangent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a426b70abe4783e75806e1ae8c9e9e2bd" name="a426b70abe4783e75806e1ae8c9e9e2bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a426b70abe4783e75806e1ae8c9e9e2bd">&#9670;&nbsp;</a></span>atan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::atan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the arctangent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>An angle in <b>radians</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The arctangent of x</dd></dl>
<p>A degree 9 interpolating polynomial through Chebyshev nodes is used to approximate \(atan(x)\). Domain reduction to [-1, 1] is performed. </p>

</div>
</div>
<a id="a6ae6ab14a39d6132b6858934dadaaf3e" name="a6ae6ab14a39d6132b6858934dadaaf3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae6ab14a39d6132b6858934dadaaf3e">&#9670;&nbsp;</a></span>atan2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::atan2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the 2 argument arctangent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>The y coordinate in cartesian space </td></tr>
    <tr><td class="paramname">x</td><td>The x coordinate in cartesian space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The counterclockwise angle between the vector described by x and y and the x axis.</dd></dl>
<p>Computed using identities on atan(x). </p>

</div>
</div>
<a id="aeaac9bb0b5b83e96e4312cef9d99af68" name="aeaac9bb0b5b83e96e4312cef9d99af68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaac9bb0b5b83e96e4312cef9d99af68">&#9670;&nbsp;</a></span>bezier()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; theoretica::bezier </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; &gt;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic Bezier curve in N dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>The control points </td></tr>
    <tr><td class="paramname">t</td><td>The curve parameter between 0 and 1</td></tr>
  </table>
  </dd>
</dl>
<p>The generic Bezier curve is computed by successive linear interpolations. For cubic and quadratic Bezier curves the related functions should be preferred. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetheoretica.html#a69213a79c487ca5266077e64f7624fb3" title="Quadratic Bezier curve.">quadratic_bezier</a> </dd>
<dd>
<a class="el" href="namespacetheoretica.html#a2b261d224ea1a2878b802013eae0fbaf" title="Cubic Bezier curve.">cubic_bezier</a> </dd></dl>

</div>
</div>
<a id="a65be0b914abdafbb96aa05d6fda14f98" name="a65be0b914abdafbb96aa05d6fda14f98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65be0b914abdafbb96aa05d6fda14f98">&#9670;&nbsp;</a></span>binomial_coeff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType  = unsigned long long int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr IntType theoretica::binomial_coeff </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the binomial coefficient. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A natural number </td></tr>
    <tr><td class="paramname">m</td><td>A natural number smaller than n </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binomial coefficient computed on (n, m) as \(\frac{n!}{m!(n - m)!}\) </dd></dl>

</div>
</div>
<a id="a249d8d6497120d311e2abbfc11c5f54d" name="a249d8d6497120d311e2abbfc11c5f54d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a249d8d6497120d311e2abbfc11c5f54d">&#9670;&nbsp;</a></span>bit_rotate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ShiftableType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ShiftableType theoretica::bit_rotate </td>
          <td>(</td>
          <td class="paramtype">ShiftableType&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bit rotation using shifting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The variable to rotate the bits of </td></tr>
    <tr><td class="paramname">i</td><td>The index of the rotated bits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61c3b797f94ec5bc22b4c22f85417c93" name="a61c3b797f94ec5bc22b4c22f85417c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c3b797f94ec5bc22b4c22f85417c93">&#9670;&nbsp;</a></span>cbrt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::cbrt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cubic root of x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cubic root of x</dd></dl>
<p>Domain: [-inf, +inf] <br  />
The Newton-Raphson algorithm, optimized for the cubic root and limited by the <code>THEORETICA_MAX_NEWTON_ITER</code> macro constant, is used. Domain reduction to [0, 1] is applied to ensure convergence of the algorithm. </p>

</div>
</div>
<a id="af77c5c6195e30df1e423b0922cc0776e" name="af77c5c6195e30df1e423b0922cc0776e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af77c5c6195e30df1e423b0922cc0776e">&#9670;&nbsp;</a></span>chebyshev_nodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> theoretica::chebyshev_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the n Chebyshev nodes on a given interval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The lower bound of the interval </td></tr>
    <tr><td class="paramname">b</td><td>The upper bound of the interval </td></tr>
    <tr><td class="paramname">n</td><td>The number of points to evaluate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1a4ad4c5446986fe2d255a03be337a1" name="af1a4ad4c5446986fe2d255a03be337a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1a4ad4c5446986fe2d255a03be337a1">&#9670;&nbsp;</a></span>clamp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::clamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clamp x between a and b. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The real number to clamp </td></tr>
    <tr><td class="paramname">a</td><td>The lower bound </td></tr>
    <tr><td class="paramname">b</td><td>The upper bound </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns x if x is between a and b, a if x is less than a, b if x is bigger than b </dd></dl>

</div>
</div>
<a id="acdf4d125306e3fffc7287aa42f9005a1" name="acdf4d125306e3fffc7287aa42f9005a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf4d125306e3fffc7287aa42f9005a1">&#9670;&nbsp;</a></span>clamp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T theoretica::clamp </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clamp a value between two other values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to clamp </td></tr>
    <tr><td class="paramname">a</td><td>The lower bound </td></tr>
    <tr><td class="paramname">b</td><td>The upper bound </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns x if x is between a and b, a if x is less than a, b if x is bigger than b</dd></dl>
<p>The templated T type must have comparison operators. </p>

</div>
</div>
<a id="a32015dfa47fc795e0fefcf26b5c0375d" name="a32015dfa47fc795e0fefcf26b5c0375d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32015dfa47fc795e0fefcf26b5c0375d">&#9670;&nbsp;</a></span>cos() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a> theoretica::cos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the complex cosine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af684d7159e22012dc5229c31eb66fceb" name="af684d7159e22012dc5229c31eb66fceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af684d7159e22012dc5229c31eb66fceb">&#9670;&nbsp;</a></span>cos() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::cos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cosine of a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>An angle in <b>radians</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cosine of x</dd></dl>
<p>On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fcos</code> instruction will be used. </p>

</div>
</div>
<a id="a12fc03cbb1de8180e51183bb82c0bb28" name="a12fc03cbb1de8180e51183bb82c0bb28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12fc03cbb1de8180e51183bb82c0bb28">&#9670;&nbsp;</a></span>cosh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::cosh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the hyperbolic cosine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic cosine of x</dd></dl>
<p>\(cosh = \frac{e^x + e^{-x}}{2}\) </p>

</div>
</div>
<a id="aec6f43e74456bea35fb757f17db47da8" name="aec6f43e74456bea35fb757f17db47da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6f43e74456bea35fb757f17db47da8">&#9670;&nbsp;</a></span>cot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::cot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cotangent of x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>An angle in <b>radians</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cotangent of x</dd></dl>
<p>On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fsincos</code> instruction will be used. </p>

</div>
</div>
<a id="a96f957ad9b2354268f56ab1ca3843080" name="a96f957ad9b2354268f56ab1ca3843080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f957ad9b2354268f56ab1ca3843080">&#9670;&nbsp;</a></span>coth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::coth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the hyperbolic cotangent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic cotangent of x </dd></dl>

</div>
</div>
<a id="a12940c0bd43e6edcabb9064ccfd6cc5a" name="a12940c0bd43e6edcabb9064ccfd6cc5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12940c0bd43e6edcabb9064ccfd6cc5a">&#9670;&nbsp;</a></span>cross()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; 3, T &gt; theoretica::cross </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; 3, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; 3, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the cross product of two vectors. </p>
<p >The vectors have to be 3-dimensional </p>

</div>
</div>
<a id="aa8a0b9841198983905b57496cad4869e" name="aa8a0b9841198983905b57496cad4869e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a0b9841198983905b57496cad4869e">&#9670;&nbsp;</a></span>cube() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a> theoretica::cube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cube of a complex number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5652a07723590cd9a0c9332634ec1db4" name="a5652a07723590cd9a0c9332634ec1db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5652a07723590cd9a0c9332634ec1db4">&#9670;&nbsp;</a></span>cube() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::cube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cube of a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cube of x</dd></dl>
<p>Domain: [-inf, +inf] </p>

</div>
</div>
<a id="a0fd2bb549c191e40d2bf6c5e9f1e5dcc" name="a0fd2bb549c191e40d2bf6c5e9f1e5dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd2bb549c191e40d2bf6c5e9f1e5dcc">&#9670;&nbsp;</a></span>degrees()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::degrees </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>radians</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert radians to degrees. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radians</td><td>An angle in radians </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted angle in degrees</dd></dl>
<p>The <code>RAD2DEG</code> scalar factor is used. </p>

</div>
</div>
<a id="aed789cb9f8123584b3e1f1f9a334f47d" name="aed789cb9f8123584b3e1f1f9a334f47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed789cb9f8123584b3e1f1f9a334f47d">&#9670;&nbsp;</a></span>directional_derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; theoretica::directional_derivative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt;(*)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1multidual.html">multidual</a>&lt; N &gt; &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the directional derivative of a generic function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to partially differentiate </td></tr>
    <tr><td class="paramname">x</td><td>The point to compute the derivative at </td></tr>
    <tr><td class="paramname">v</td><td>The direction to compute the derivative on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In most applications, the vector v should be a unit vector, but the function does not control whether the vector has unit length or not. </dd></dl>

</div>
</div>
<a id="a01412973394e4d319502a0fed1f8a9da" name="a01412973394e4d319502a0fed1f8a9da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01412973394e4d319502a0fed1f8a9da">&#9670;&nbsp;</a></span>divergence_mono()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::divergence_mono </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1dual.html">dual</a>(*)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1dual.html">dual</a> &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the divergence for a given \(\vec x\) of a function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\) using automatic differentiation. </p>
<dl class="section note"><dt>Note</dt><dd>The multidual implementation is more efficient as it does not need to compute the function value N times and should be preferred.</dd></dl>
<p>The <code>mono</code> suffix is used to emphasize the difference between simple dual numbers and multidual numbers and to avoid differentiation between overloads on the user's side. </p>

</div>
</div>
<a id="a463ef7c6f8731bab9581d4021e92a60b" name="a463ef7c6f8731bab9581d4021e92a60b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463ef7c6f8731bab9581d4021e92a60b">&#9670;&nbsp;</a></span>exp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a> theoretica::exp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the complex exponential. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac61f8810fcedeaa35f54c834e934828e" name="ac61f8810fcedeaa35f54c834e934828e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac61f8810fcedeaa35f54c834e934828e">&#9670;&nbsp;</a></span>exp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::exp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute \(e^x\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exponential of x</dd></dl>
<p>The exponential is computed as \(e^{floor(x)} e^{fract(x)}\), where \(e^{floor(x)} = pow(e, floor(x))\) and \(e^{fract(x)}\) is either approximated using Taylor series on [0, 0.5] or, if <code>THEORETICA_X86</code> is defined, using the <code>f2xm1</code> x86 assembly instruction. </p>

</div>
</div>
<a id="a944a1ca627ace27061946b1fbf572545" name="a944a1ca627ace27061946b1fbf572545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a944a1ca627ace27061946b1fbf572545">&#9670;&nbsp;</a></span>floor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int theoretica::floor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the floor of x Computes the maximum integer number that is smaller than x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The floor of x</dd></dl>
<p>e.g. floor(1.6) = 1 e.g. floor(-0.3) = -1 </p>

</div>
</div>
<a id="a85d079c3d95f2bc80c4619d13ff7263a" name="a85d079c3d95f2bc80c4619d13ff7263a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d079c3d95f2bc80c4619d13ff7263a">&#9670;&nbsp;</a></span>fract()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::fract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the fractional part of a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The fractional part of x</dd></dl>
<p>e.g. fract(2.5) = 0.5 e.g. fract(-0.2) = 0.2 </p>

</div>
</div>
<a id="a7945a9959534ed6da94246f568393cd2" name="a7945a9959534ed6da94246f568393cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7945a9959534ed6da94246f568393cd2">&#9670;&nbsp;</a></span>gradient_mono()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; theoretica::gradient_mono </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1dual.html">dual</a>(*)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="classtheoretica_1_1dual.html">dual</a> &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the gradient for a given \(\vec x\) of a function of the form \(f: \mathbb{R}^N \rightarrow \mathbb{R}\) using automatic differentiation. </p>
<dl class="section note"><dt>Note</dt><dd>The multidual implementation is more efficient as it does not need to compute the function value N times and should be preferred.</dd></dl>
<p>The <code>mono</code> suffix is used to emphasize the difference between simple dual numbers and multidual numbers and to avoid differentiation between overloads on the user's side. </p>

</div>
</div>
<a id="a88f9a26f1ee40dea3fced3ee7e0c9aa9" name="a88f9a26f1ee40dea3fced3ee7e0c9aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f9a26f1ee40dea3fced3ee7e0c9aa9">&#9670;&nbsp;</a></span>interpolate_chebyshev()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; theoretica::interpolate_chebyshev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the interpolating polynomial of a real function using Chebyshev nodes as sampling points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to interpolate </td></tr>
    <tr><td class="paramname">a</td><td>Lower bound of the interval </td></tr>
    <tr><td class="paramname">b</td><td>Upper bound of the interval </td></tr>
    <tr><td class="paramname">order</td><td>Order of the resulting polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A polynomial of (n - 1) degree interpolating the function through the Chebyshev nodes.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetheoretica.html#af77c5c6195e30df1e423b0922cc0776e" title="Compute the n Chebyshev nodes on a given interval.">chebyshev_nodes</a> </dd>
<dd>
<a class="el" href="namespacetheoretica.html#a9b3f2ff840d6e5dae38dfc1e6176a7be" title="Compute the Lagrange polynomial interpolating a set of points.">lagrange_polynomial</a> </dd></dl>

</div>
</div>
<a id="a9dc2216d71f0d7147b5c0dacdeea80db" name="a9dc2216d71f0d7147b5c0dacdeea80db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dc2216d71f0d7147b5c0dacdeea80db">&#9670;&nbsp;</a></span>interpolate_grid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> &gt; theoretica::interpolate_grid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a55d24f1c0c8357b26e2ea168b80eabeb">real_function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the interpolating polynomial of a real function on an equidistant point sample. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to interpolate </td></tr>
    <tr><td class="paramname">a</td><td>Lower bound of the interval </td></tr>
    <tr><td class="paramname">b</td><td>Upper bound of the interval </td></tr>
    <tr><td class="paramname">order</td><td>Order of the resulting polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A polynomial of (n - 1) degree interpolating the function </dd></dl>

</div>
</div>
<a id="a22e311a811c0c7e23c30e4496cfbe63d" name="a22e311a811c0c7e23c30e4496cfbe63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22e311a811c0c7e23c30e4496cfbe63d">&#9670;&nbsp;</a></span>is_nan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool theoretica::is_nan </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a generic variable is (equivalent to) a NaN number. </p>
<p >NaN numbers are the only variables which do not compare equal to themselves in floating point operations. This is valid for real types but also for any mathematical structure, as NaNs are used to report failure inside the library. </p>

</div>
</div>
<a id="a93fd0f7d8ed7baa75f8f2a3d6632132a" name="a93fd0f7d8ed7baa75f8f2a3d6632132a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93fd0f7d8ed7baa75f8f2a3d6632132a">&#9670;&nbsp;</a></span>kronecker_delta()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T theoretica::kronecker_delta </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Kronecker delta, equals 1 if i is equal to j, 0 otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The first value to compare </td></tr>
    <tr><td class="paramname">j</td><td>The second value to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if i is equal to j, 0 otherwise </dd></dl>

</div>
</div>
<a id="a9b3f2ff840d6e5dae38dfc1e6176a7be" name="a9b3f2ff840d6e5dae38dfc1e6176a7be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b3f2ff840d6e5dae38dfc1e6176a7be">&#9670;&nbsp;</a></span>lagrange_polynomial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1polynomial.html">polynomial</a>&lt; T &gt; theoretica::lagrange_polynomial </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; 2, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Lagrange polynomial interpolating a set of points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>The set of n points to interpolate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A polynomial of (n - 1) degree interpolating the points </dd></dl>

</div>
</div>
<a id="a8981a9c3a9fb8084b2c4ab93a9b09a3b" name="a8981a9c3a9fb8084b2c4ab93a9b09a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8981a9c3a9fb8084b2c4ab93a9b09a3b">&#9670;&nbsp;</a></span>linf_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::linf_norm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, T &gt;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Linf norm of a vector. </p>
<p >\(L_{inf}(\vec v) = max(|v_i|)\) </p>

</div>
</div>
<a id="ace32efc4e4b7b555c8cdc340e7adff4a" name="ace32efc4e4b7b555c8cdc340e7adff4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace32efc4e4b7b555c8cdc340e7adff4a">&#9670;&nbsp;</a></span>ln() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a> theoretica::ln </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the complex logarithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a748eca731a8c05226332e5723b7a9d91" name="a748eca731a8c05226332e5723b7a9d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748eca731a8c05226332e5723b7a9d91">&#9670;&nbsp;</a></span>ln() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::ln </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the natural logarithm of x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number bigger than 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The natural logarithm of x</dd></dl>
<p>Domain: (0, +inf] <br  />
On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fyl2x</code> instruction will be used. </p>

</div>
</div>
<a id="adb04217fd0bd9dd23daaa186d3756d1e" name="adb04217fd0bd9dd23daaa186d3756d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb04217fd0bd9dd23daaa186d3756d1e">&#9670;&nbsp;</a></span>log10()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::log10 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the base-10 logarithm of x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number bigger than 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The base-10 logarithm of x</dd></dl>
<p>Domain: (0, +inf] <br  />
On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fyl2x</code> instruction will be used. </p>

</div>
</div>
<a id="abbd0ef7aa0b136fbd1b4579cec14f369" name="abbd0ef7aa0b136fbd1b4579cec14f369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd0ef7aa0b136fbd1b4579cec14f369">&#9670;&nbsp;</a></span>log2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::log2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the binary logarithm of a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number bigger than 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binary logarithm of x</dd></dl>
<p>Domain: (0, +inf] <br  />
On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fyl2x</code> instruction will be used. </p>

</div>
</div>
<a id="aee450a2e1c398352ccfc48cc5fe115ce" name="aee450a2e1c398352ccfc48cc5fe115ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee450a2e1c398352ccfc48cc5fe115ce">&#9670;&nbsp;</a></span>lp_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::lp_norm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N, T &gt;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Lp norm of a vector. </p>
<p >\(L_p(\vec v) = (\Sigma_i \ |v_i|^p)^{1/p}\) </p>

</div>
</div>
<a id="a07569756dda099ecabf425371da6a31d" name="a07569756dda099ecabf425371da6a31d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07569756dda099ecabf425371da6a31d">&#9670;&nbsp;</a></span>max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the greatest number between two real numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
    <tr><td class="paramname">y</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The greatest number between x and y</dd></dl>
<p>If <code>THEORETICA_BRANCHLESS</code> is defined, a branchless implementation will be used </p>

</div>
</div>
<a id="a5e295404d1712fb17851fe105715766e" name="a5e295404d1712fb17851fe105715766e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e295404d1712fb17851fe105715766e">&#9670;&nbsp;</a></span>max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T theoretica::max </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two objects and return the greatest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The first object to compare </td></tr>
    <tr><td class="paramname">y</td><td>The second object to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The greatest between the objects</dd></dl>
<p>The templated T type must have comparison operators. </p>

</div>
</div>
<a id="ac673920f8956ebea402eac4271f551ba" name="ac673920f8956ebea402eac4271f551ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac673920f8956ebea402eac4271f551ba">&#9670;&nbsp;</a></span>min() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the smallest number between two real numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
    <tr><td class="paramname">y</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest number between x and y</dd></dl>
<p>If <code>THEORETICA_BRANCHLESS</code> is defined, a branchless implementation will be used </p>

</div>
</div>
<a id="a70f4122359c1f32ba0741d098a5fbe69" name="a70f4122359c1f32ba0741d098a5fbe69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f4122359c1f32ba0741d098a5fbe69">&#9670;&nbsp;</a></span>min() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T theoretica::min </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two objects and return the greatest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The first object to compare </td></tr>
    <tr><td class="paramname">y</td><td>The second object to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest between the objects</dd></dl>
<p>The templated T type must have comparison operators. </p>

</div>
</div>
<a id="a672dbbc0ea824c71d7ca0dc26b346200" name="a672dbbc0ea824c71d7ca0dc26b346200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a672dbbc0ea824c71d7ca0dc26b346200">&#9670;&nbsp;</a></span>mix_mum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::mix_mum </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>MUM bit mixing function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first operand </td></tr>
    <tr><td class="paramname">b</td><td>The second operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca2b51694a7dd4ded3a140f92366aaed" name="aca2b51694a7dd4ded3a140f92366aaed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca2b51694a7dd4ded3a140f92366aaed">&#9670;&nbsp;</a></span>mul_uint128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void theoretica::mul_uint128 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>c_low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>c_high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply two 64-bit integers and store the result in two 64-bit variables, keeping 128 bits of the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first number to multiply </td></tr>
    <tr><td class="paramname">b</td><td>The second number to multiply </td></tr>
    <tr><td class="paramname">c_low</td><td>The variable where to store the lowest 64 bits of the result </td></tr>
    <tr><td class="paramname">c_high</td><td>The variable where to store the highest 64 bits of the result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba826811342f6bab2f306ec09cc2d753" name="aba826811342f6bab2f306ec09cc2d753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba826811342f6bab2f306ec09cc2d753">&#9670;&nbsp;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T theoretica::pow </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the n-th power of x (where n is natural) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Any element of a multiplicative algebra </td></tr>
    <tr><td class="paramname">n</td><td>The integer exponent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x to the power n </dd></dl>

</div>
</div>
<a id="a6f12dd8e0fc650fa75c9961e51d1406c" name="a6f12dd8e0fc650fa75c9961e51d1406c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f12dd8e0fc650fa75c9961e51d1406c">&#9670;&nbsp;</a></span>powf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::powf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximate x elevated to a. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a A real exponent</dd></dl>
<p>Approximated as \(e^{a ln(|x|) sgn(x)}\) </p>

</div>
</div>
<a id="aa7e523c1cc3621e7cbc1ac0df01913c3" name="aa7e523c1cc3621e7cbc1ac0df01913c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e523c1cc3621e7cbc1ac0df01913c3">&#9670;&nbsp;</a></span>qrand_weyl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::qrand_weyl </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>alpha</em> = <code><a class="el" href="namespacetheoretica.html#a6a6de16e5ee81d340ff91dbadb99edde">INVPHI</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weyl quasi-random sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the element in the sequence </td></tr>
    <tr><td class="paramname">alpha</td><td>The base of the sequence, defaults to the inverse of the Golden Section</td></tr>
  </table>
  </dd>
</dl>
<p>The Weyl sequence is defined as \(x_n = {n \alpha}\), where \({ }\) is the fractional part. </p><dl class="section note"><dt>Note</dt><dd>The alpha argument should be an irrational number. </dd></dl>

</div>
</div>
<a id="a6c5001951408c716ce4e6414cc45f420" name="a6c5001951408c716ce4e6414cc45f420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c5001951408c716ce4e6414cc45f420">&#9670;&nbsp;</a></span>qrand_weyl_recurr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::qrand_weyl_recurr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>prev</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>alpha</em> = <code><a class="el" href="namespacetheoretica.html#a6a6de16e5ee81d340ff91dbadb99edde">INVPHI</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weyl quasi-random sequence (computed with recurrence relation) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prev</td><td>The previously computed value </td></tr>
    <tr><td class="paramname">alpha</td><td>The base of the sequence, defaults to the inverse of the Golden Section</td></tr>
  </table>
  </dd>
</dl>
<p>If no arguments are provided or prev is zero, the function computes the first element of the Weyl sequence associated to the parameter alpha. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetheoretica.html#aa7e523c1cc3621e7cbc1ac0df01913c3" title="Weyl quasi-random sequence.">qrand_weyl</a> </dd></dl>

</div>
</div>
<a id="a4ee874cdb0b2a00881f01de91e931854" name="a4ee874cdb0b2a00881f01de91e931854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ee874cdb0b2a00881f01de91e931854">&#9670;&nbsp;</a></span>radians()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::radians </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>degrees</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert degrees to radians. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degrees</td><td>An angle in degrees </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted angle in radians</dd></dl>
<p>The <code>DEG2RAD</code> scalar factor is used. </p>

</div>
</div>
<a id="a36a41f7dda7d0ad8cc8a4559afcf2ad7" name="a36a41f7dda7d0ad8cc8a4559afcf2ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a41f7dda7d0ad8cc8a4559afcf2ad7">&#9670;&nbsp;</a></span>rand_congruential() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::rand_congruential </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Congruential pseudorandom number generation algorithm (wrapper) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The current recurrence value of the algorithm (x_n) </td></tr>
    <tr><td class="paramname">state</td><td>A vector containing the state of the algorithm (a, c, m in this order) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next generated pseudorandom number</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetheoretica.html#ab1025a8b933cfe7077936c4be27971c1" title="Congruential pseudorandom number generation algorithm.">rand_congruential</a> </dd></dl>

</div>
</div>
<a id="ab1025a8b933cfe7077936c4be27971c1" name="ab1025a8b933cfe7077936c4be27971c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1025a8b933cfe7077936c4be27971c1">&#9670;&nbsp;</a></span>rand_congruential() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::rand_congruential </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>a</em> = <code>48271</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>c</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>m</em> = <code>((uint64_t)&#160;1&#160;&lt;&lt;&#160;31)&#160;-&#160;1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Congruential pseudorandom number generation algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The current recurrence value of the algorithm (x_n) </td></tr>
    <tr><td class="paramname">a</td><td>The multiplier term </td></tr>
    <tr><td class="paramname">c</td><td>The increment term </td></tr>
    <tr><td class="paramname">m</td><td>The modulus term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next generated pseudorandom number</dd></dl>
<p>The congruential generator is defined by the recurrence formula \(x_{n+1} = (a x_n + c) mod m\) <br  />
If no parameters are passed, the generator defaults to a = 48271, c = 0, m = (1 &lt;&lt; 31) - 1. </p>

</div>
</div>
<a id="aeaab56ddec7d197600964cb78ada9a86" name="aeaab56ddec7d197600964cb78ada9a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaab56ddec7d197600964cb78ada9a86">&#9670;&nbsp;</a></span>rand_dist_tac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_dist_tac </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a007564925b46b1a8a4038ad371e9052b">stat_function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code><a class="el" href="namespacetheoretica.html#a3299f783527ae72a24c832a7b1cd8ef8">MAX_TRYANDCATCH_ITER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a pseudorandom value following any probability distribution function using the Try-and-Catch (rejection) algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A probability distribution function </td></tr>
    <tr><td class="paramname">theta</td><td>The parameters of the pdf </td></tr>
    <tr><td class="paramname">x1</td><td>The left extreme of the rectangle </td></tr>
    <tr><td class="paramname">x2</td><td>The right extreme of the rectangle </td></tr>
    <tr><td class="paramname">y1</td><td>The lower extreme of the rectangle </td></tr>
    <tr><td class="paramname">y2</td><td>The upper extreme of the rectangle </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> to use for number generation </td></tr>
    <tr><td class="paramname">max_iter</td><td>The maximum number of failed generations before stopping execution (defaults to MAX_TRYANDCATCH_ITER) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A real number following the given pdf</dd></dl>
<p>Random real numbers are generated inside a rectangle defined by x1, x2, y1 and y2 following a uniform distribution. Only numbers below the pdf are returned. </p>

</div>
</div>
<a id="ae595e5ecfb8203ca342082a721180331" name="ae595e5ecfb8203ca342082a721180331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae595e5ecfb8203ca342082a721180331">&#9670;&nbsp;</a></span>rand_gaussian_clt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_gaussian_clt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iter</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a random number in a range following a Gaussian distribution by exploiting the Central Limit Theorem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>Lower extreme of the interval of generation </td></tr>
    <tr><td class="paramname">x2</td><td>Upper extreme of the interval of generation </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized <a class="el" href="classtheoretica_1_1_p_r_n_g.html" title="A pseudorandom number generator.">PRNG</a> to use </td></tr>
    <tr><td class="paramname">iter</td><td>The number of random number to generate</td></tr>
  </table>
  </dd>
</dl>
<p>Many real numbers in a range are generated and the mean is computed to get a single real number following (asymptotically) a Gaussian distribution. </p>

</div>
</div>
<a id="ac8bdf0dc89459fedaf6950c0f9b96df5" name="ac8bdf0dc89459fedaf6950c0f9b96df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8bdf0dc89459fedaf6950c0f9b96df5">&#9670;&nbsp;</a></span>rand_gaussian_polar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_gaussian_polar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a random number following a Gaussian distribution using Marsaglia's polar method. </p>
<dl class="section note"><dt>Note</dt><dd>This function may not be thread-safe as it uses static variables to keep track of spare generated values. </dd></dl>

</div>
</div>
<a id="aae266dabbc97f85eddaeb0466a07d325" name="aae266dabbc97f85eddaeb0466a07d325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae266dabbc97f85eddaeb0466a07d325">&#9670;&nbsp;</a></span>rand_real()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::rand_real </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1_p_r_n_g.html">PRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="namespacetheoretica.html#a0e48eab9ce5928d0c754a40ddb2d068f">RAND_REAL_PREC</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a pseudorandom real number in [a, b] using a preexisting generator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The lower extreme of the interval </td></tr>
    <tr><td class="paramname">b</td><td>The higher extreme of the interval </td></tr>
    <tr><td class="paramname">g</td><td>An already initialized pseudorandom number generator </td></tr>
    <tr><td class="paramname">prec</td><td>Precision parameters for the normalization, defaults to RAND_REAL_PREC.</td></tr>
  </table>
  </dd>
</dl>
<p>The algorithm generates a random integer number, computes its modulus and divides it by prec: \(x = (n mod p) / 2^p\), where n is the random integer and p is the prec parameter </p>

</div>
</div>
<a id="a058181f973ba2744704e6c6211477a35" name="a058181f973ba2744704e6c6211477a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058181f973ba2744704e6c6211477a35">&#9670;&nbsp;</a></span>rand_splitmix64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::rand_splitmix64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SplitMix64 pseudorandom number generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The 64-bit state of the algorithm</td></tr>
  </table>
  </dd>
</dl>
<p>Adapted from the reference implementation by Sebastiano Vigna </p>

</div>
</div>
<a id="ad198dee1300488d1b3e51767d62beedf" name="ad198dee1300488d1b3e51767d62beedf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad198dee1300488d1b3e51767d62beedf">&#9670;&nbsp;</a></span>rand_splitmix64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::rand_splitmix64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SplitMix64 pseudorandom number generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The 64-bit state of the algorithm </td></tr>
    <tr><td class="paramname">p</td><td>Dummy variable (needed for function signature) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a470e255aed45a7dba74af4af68b31d0d" name="a470e255aed45a7dba74af4af68b31d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a470e255aed45a7dba74af4af68b31d0d">&#9670;&nbsp;</a></span>rand_wyrand() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::rand_wyrand </td>
          <td>(</td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wyrand pseudorandom number generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>The (changing) seed of the algorithm </td></tr>
    <tr><td class="paramname">p0</td><td>Additive constant (ideally a large prime number) </td></tr>
    <tr><td class="paramname">p1</td><td>Mask for the algorithm</td></tr>
  </table>
  </dd>
</dl>
<p>Algorithm by Yi Wang </p>

</div>
</div>
<a id="a5deb3df62eb53ec187a4660d42d8d5f1" name="a5deb3df62eb53ec187a4660d42d8d5f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5deb3df62eb53ec187a4660d42d8d5f1">&#9670;&nbsp;</a></span>rand_wyrand() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::rand_wyrand </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wyrand pseudorandom number generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Dummy variable </td></tr>
    <tr><td class="paramname">p</td><td>Algorithm parameters</td></tr>
  </table>
  </dd>
</dl>
<p>p[0] is the initial seed, p[1] a large prime number and p[2] is the bit mask. </p>

</div>
</div>
<a id="aed6faedb3d913a589365b108f5ec304e" name="aed6faedb3d913a589365b108f5ec304e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed6faedb3d913a589365b108f5ec304e">&#9670;&nbsp;</a></span>rand_xoshiro() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::rand_xoshiro </td>
          <td>(</td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Xoshiro256++ pseudorandom number generation algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Dummy parameter (needed for function signature) </td></tr>
    <tr><td class="paramname">state</td><td>The four 64-bit integer state of the algorithm</td></tr>
  </table>
  </dd>
</dl>
<p>Adapted from the reference implementation by Sebastiano Vigna </p>

</div>
</div>
<a id="a13b30362a1d08c8522c5297efd6f4a47" name="a13b30362a1d08c8522c5297efd6f4a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b30362a1d08c8522c5297efd6f4a47">&#9670;&nbsp;</a></span>rand_xoshiro() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t theoretica::rand_xoshiro </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Xoshiro256++ pseudorandom number generation algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Dummy parameter (needed for function signature) </td></tr>
    <tr><td class="paramname">state</td><td>The four 64-bit integer state of the algorithm </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf52f04c3a1cefbb9dabab21cac0abbb" name="acf52f04c3a1cefbb9dabab21cac0abbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf52f04c3a1cefbb9dabab21cac0abbb">&#9670;&nbsp;</a></span>root()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::root </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the n-th root of x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
    <tr><td class="paramname">n</td><td>The root number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The n-th real root of x</dd></dl>
<p>The Newton-Raphson method is used, limited by the <code>THEORETICA_MAX_NEWTON_ITER</code> macro constant. </p>

</div>
</div>
<a id="ad61e39abd4fd4cd8cd83add5d0752e2f" name="ad61e39abd4fd4cd8cd83add5d0752e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad61e39abd4fd4cd8cd83add5d0752e2f">&#9670;&nbsp;</a></span>sgn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int theoretica::sgn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the sign of x (1 if positive, -1 if negative, 0 if null) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sign of x </dd></dl>

</div>
</div>
<a id="a7a76685197faa15403e24b836830cf5d" name="a7a76685197faa15403e24b836830cf5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a76685197faa15403e24b836830cf5d">&#9670;&nbsp;</a></span>sigmoid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::sigmoid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the sigmoid function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sigmoid function for x defined as \(\frac{1}{1 - e^{-x}}\) </dd></dl>

</div>
</div>
<a id="a1b6f6e44aa2d8dabd4a2710e313f65d8" name="a1b6f6e44aa2d8dabd4a2710e313f65d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6f6e44aa2d8dabd4a2710e313f65d8">&#9670;&nbsp;</a></span>sin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a> theoretica::sin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computer the complex sine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c2ea0b1258dfe34df321901707d1808" name="a2c2ea0b1258dfe34df321901707d1808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c2ea0b1258dfe34df321901707d1808">&#9670;&nbsp;</a></span>sin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::sin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the sine of a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>An angle in <b>radians</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sine of x</dd></dl>
<p>On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fsin</code> instruction will be used. </p>

</div>
</div>
<a id="a1efe3bd7ff87719aab92b67cec535096" name="a1efe3bd7ff87719aab92b67cec535096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1efe3bd7ff87719aab92b67cec535096">&#9670;&nbsp;</a></span>sinc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::sinc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the normalized sinc function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The normalized sinc function for x defined as \(\frac{sin(\pi x)}{\pi x}\) </dd></dl>

</div>
</div>
<a id="a0650ea8e1435cc518e960bfcecf5b66e" name="a0650ea8e1435cc518e960bfcecf5b66e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0650ea8e1435cc518e960bfcecf5b66e">&#9670;&nbsp;</a></span>sinh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::sinh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the hyperbolic sine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic sine of x</dd></dl>
<p>\(sinh = \frac{e^x - e^{-x}}{2}\) </p>

</div>
</div>
<a id="a5efdb832f0c39ba2f0030c99e4de728b" name="a5efdb832f0c39ba2f0030c99e4de728b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5efdb832f0c39ba2f0030c99e4de728b">&#9670;&nbsp;</a></span>sphere_inversion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; theoretica::sphere_inversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sphere inversion of a point with respect to a sphere of radius 1 centered in the origin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The vector to transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51aa3252df8991054c7c1f301912176c" name="a51aa3252df8991054c7c1f301912176c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51aa3252df8991054c7c1f301912176c">&#9670;&nbsp;</a></span>sphere_inversion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt; theoretica::sphere_inversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sphere inversion of a point with respect to a sphere of radius r centered in a point c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The vector to transform </td></tr>
    <tr><td class="paramname">c</td><td>The center of the sphere </td></tr>
    <tr><td class="paramname">r</td><td>The radius of the sphere </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f593debadf5736178434aa3fe476a5c" name="a0f593debadf5736178434aa3fe476a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f593debadf5736178434aa3fe476a5c">&#9670;&nbsp;</a></span>sqrt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a> theoretica::sqrt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the complex square root. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2e4cf02f9bcb4caf5371ee05d67df8d" name="aa2e4cf02f9bcb4caf5371ee05d67df8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e4cf02f9bcb4caf5371ee05d67df8d">&#9670;&nbsp;</a></span>sqrt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::sqrt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the square root of a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The square root of x</dd></dl>
<p>Domain: [0, +inf] <br  />
The Newton-Raphson algorithm, optimized for the square root and limited by the <code>THEORETICA_MAX_NEWTON_ITER</code> macro constant, is used. Domain reduction to [0, 1] is applied to ensure convergence of the algorithm. On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fsqrt</code> instruction will be used. </p>

</div>
</div>
<a id="a9d09bcf107dc6230badf2b29e25ffcad" name="a9d09bcf107dc6230badf2b29e25ffcad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d09bcf107dc6230badf2b29e25ffcad">&#9670;&nbsp;</a></span>square() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a> theoretica::square </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the square of a complex number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1826571ac9bbfb4adb6b92e17f99dd58" name="a1826571ac9bbfb4adb6b92e17f99dd58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1826571ac9bbfb4adb6b92e17f99dd58">&#9670;&nbsp;</a></span>square() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::square </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the square of a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The square of x</dd></dl>
<p>Domain: [-inf, +inf] </p>

</div>
</div>
<a id="a3b0a5c7fbe93408ce58d40859bab3365" name="a3b0a5c7fbe93408ce58d40859bab3365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0a5c7fbe93408ce58d40859bab3365">&#9670;&nbsp;</a></span>sturm_liouville()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::sturm_liouville </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1dual.html">dual</a>(*)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; M, <a class="el" href="classtheoretica_1_1dual.html">dual</a> &gt;)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1dual.html">dual</a>(*)(<a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; M, <a class="el" href="classtheoretica_1_1dual.html">dual</a> &gt;)&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1vec.html">vec</a>&lt; M &gt;&#160;</td>
          <td class="paramname"><em>eta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computer the Sturm-Liouville operator on a generic function of the form \(f: \mathbb{R}^{2N} \rightarrow \mathbb{R}\) with respect to a given Hamiltonian function of the form \(H: \mathbb{R}^{2N} \rightarrow \mathbb{R}\) where the first N arguments are the coordinates in phase space and the last N arguments are the conjugate momenta, for a given point in phase space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to apply the operator to </td></tr>
    <tr><td class="paramname">H</td><td>The Hamiltonian </td></tr>
    <tr><td class="paramname">eta</td><td>A vector containing M = 2N elements, where the first N elements are the coordinates and the last N elements are the conjugate momenta. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc57357e424703aa6ea643697c2f6d24" name="abc57357e424703aa6ea643697c2f6d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc57357e424703aa6ea643697c2f6d24">&#9670;&nbsp;</a></span>tan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtheoretica_1_1complex.html">complex</a> theoretica::tan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtheoretica_1_1complex.html">complex</a>&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the complex tangent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A complex number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe9d9a32dc2c9f00de35c1b1a49b218e" name="abe9d9a32dc2c9f00de35c1b1a49b218e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9d9a32dc2c9f00de35c1b1a49b218e">&#9670;&nbsp;</a></span>tan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::tan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the tangent of x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>An angle in <b>radians</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tangent of x</dd></dl>
<p>On x86 architectures, if <code>THEORETICA_X86</code> is defined, the <code>fsincos</code> instruction will be used. </p>

</div>
</div>
<a id="aaf6b8fc4bb2609507cd1fae0f7d6c8a7" name="aaf6b8fc4bb2609507cd1fae0f7d6c8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf6b8fc4bb2609507cd1fae0f7d6c8a7">&#9670;&nbsp;</a></span>tanh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> theoretica::tanh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the hyperbolic tangent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic tangent of x </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacetheoretica.html">theoretica</a></li>
    <li class="footer">Generated on Sat May 28 2022 19:56:24 for Theoretica by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
