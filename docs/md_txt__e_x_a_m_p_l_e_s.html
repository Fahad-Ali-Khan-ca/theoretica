<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Theoretica: Examples</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Theoretica
   </div>
   <div id="projectbrief">A C++ numerical and automatic mathematical library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_txt__e_x_a_m_p_l_e_s.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Examples </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md27"></a>
Including library headers</h1>
<div class="fragment"><div class="line"><span class="comment">// Include all headers instead</span></div>
<div class="line"><span class="comment">// of basic functionalities</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define THEORETICA_INCLUDE_ALL</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="theoretica_8h.html">theoretica.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacetheoretica.html">theoretica</a>;</div>
<div class="ttc" id="anamespacetheoretica_html"><div class="ttname"><a href="namespacetheoretica.html">theoretica</a></div><div class="ttdoc">Main namespace of the library which contains all functions and objects.</div><div class="ttdef"><b>Definition:</b> algebra.h:14</div></div>
<div class="ttc" id="atheoretica_8h_html"><div class="ttname"><a href="theoretica_8h.html">theoretica.h</a></div><div class="ttdoc">General include file.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md28"></a>
Using vectors</h1>
<p >Vector operations can be used through the <code>vec&lt;N, T = real&gt;</code> class, where <code>N</code> specifies the number of rows and <code>T</code> specifies the element type (<code>real</code> is used as default). Common vector types are defined as <code>vec2</code>, <code>vec3</code> and <code>vec4</code>.</p>
<p >Declare a vector: </p><div class="fragment"><div class="line"><span class="comment">// vec3 is the same as vec&lt;3, real&gt;</span></div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#a3a9580d98118f2e1692c1f5d6dbf3ea5">vec3</a> v1 = {1, 2, 3};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// You can initialize a vector from a bracketed list</span></div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#a3a9580d98118f2e1692c1f5d6dbf3ea5">vec3</a> v2 = {0, 1, 0};</div>
<div class="ttc" id="anamespacetheoretica_html_a3a9580d98118f2e1692c1f5d6dbf3ea5"><div class="ttname"><a href="namespacetheoretica.html#a3a9580d98118f2e1692c1f5d6dbf3ea5">theoretica::vec3</a></div><div class="ttdeci">vec&lt; 3, real &gt; vec3</div><div class="ttdoc">A 3-dimensional vector with real elements.</div><div class="ttdef"><b>Definition:</b> vec.h:358</div></div>
</div><!-- fragment --><p >Basic vector operations: </p><div class="fragment"><div class="line"><span class="comment">// Compute the lenght of a vector</span></div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> l = v1.lenght();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Access the i-th element (by reference)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// You can use the vec::at() function</span></div>
<div class="line">v1.at(1) = 2;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Or the [i] operator</span></div>
<div class="line">v1[1] = 2;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get and set the i-th element</span></div>
<div class="line">l = v1.get(1);</div>
<div class="line">v1.set(1, 2);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Multiply a vector by a scalar</span></div>
<div class="line">v1 = v1 * 2.0;</div>
<div class="line">v2 = v2 / 3.0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Normalize a vector</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// normalized() returns the normalized vector</span></div>
<div class="line"><span class="comment">// without changing the initial vector</span></div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#a3a9580d98118f2e1692c1f5d6dbf3ea5">vec3</a> v1_n = v1.<a class="code hl_function" href="classtheoretica_1_1vec.html#af8758bb09de2f785dffc493c37b99b2e">normalized</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Meanwhile normalize() normalizes the vector itself</span></div>
<div class="line">v1.normalize()</div>
<div class="ttc" id="aclasstheoretica_1_1vec_html_af8758bb09de2f785dffc493c37b99b2e"><div class="ttname"><a href="classtheoretica_1_1vec.html#af8758bb09de2f785dffc493c37b99b2e">theoretica::vec::normalized</a></div><div class="ttdeci">vec&lt; N, T &gt; normalized() const</div><div class="ttdoc">Return the normalized vector (v / |v|)</div><div class="ttdef"><b>Definition:</b> vec.h:262</div></div>
<div class="ttc" id="anamespacetheoretica_html_a049966946220f1f7e5eae57293703066"><div class="ttname"><a href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">theoretica::real</a></div><div class="ttdeci">double real</div><div class="ttdoc">A real number, defined as a floating point type.</div><div class="ttdef"><b>Definition:</b> constants.h:136</div></div>
</div><!-- fragment --><p >Dot product: </p><div class="fragment"><div class="line"><span class="comment">// You can use the class method</span></div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> d = v1.dot(v2);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Or the two-argument function</span></div>
<div class="line">d = <a class="code hl_function" href="namespacetheoretica.html#a8d0cb6c51c58cfdc4fe13f6900266a83">dot</a>(v1, v2);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Or simply the * operator</span></div>
<div class="line">d = v1 * v2;</div>
<div class="ttc" id="anamespacetheoretica_html_a8d0cb6c51c58cfdc4fe13f6900266a83"><div class="ttname"><a href="namespacetheoretica.html#a8d0cb6c51c58cfdc4fe13f6900266a83">theoretica::dot</a></div><div class="ttdeci">real dot(vec&lt; N, T &gt; v1, vec&lt; N, T &gt; v2)</div><div class="ttdoc">Compute the dot product of two vectors.</div><div class="ttdef"><b>Definition:</b> vec.h:407</div></div>
</div><!-- fragment --><p >Cross product: </p><div class="fragment"><div class="line"><span class="comment">// Same thing with the cross product</span></div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#a3a9580d98118f2e1692c1f5d6dbf3ea5">vec3</a> c;</div>
<div class="line">c = v1.<a class="code hl_function" href="classtheoretica_1_1vec.html#a9d0bc3bc79da15d0c3ced493be3970d0">cross</a>(v2);</div>
<div class="line">c = <a class="code hl_function" href="namespacetheoretica.html#a12940c0bd43e6edcabb9064ccfd6cc5a">cross</a>(v1, v2);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// But there is no cross product operator!</span></div>
<div class="ttc" id="aclasstheoretica_1_1vec_html_a9d0bc3bc79da15d0c3ced493be3970d0"><div class="ttname"><a href="classtheoretica_1_1vec.html#a9d0bc3bc79da15d0c3ced493be3970d0">theoretica::vec::cross</a></div><div class="ttdeci">vec&lt; 3 &gt; cross(const vec&lt; 3 &gt; &amp;other) const</div><div class="ttdoc">Cross product between vectors.</div><div class="ttdef"><b>Definition:</b> vec.h:153</div></div>
<div class="ttc" id="anamespacetheoretica_html_a12940c0bd43e6edcabb9064ccfd6cc5a"><div class="ttname"><a href="namespacetheoretica.html#a12940c0bd43e6edcabb9064ccfd6cc5a">theoretica::cross</a></div><div class="ttdeci">vec&lt; 3, T &gt; cross(const vec&lt; 3, T &gt; &amp;v1, const vec&lt; 3, T &gt; &amp;v2)</div><div class="ttdoc">Compute the cross product of two vectors.</div><div class="ttdef"><b>Definition:</b> vec.h:415</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md29"></a>
Using matrices</h1>
<p >Matrices are implemented in the <code>mat&lt;N, K&gt;</code> class, where N is the number of rows and K is the number of columns (colexicographical and column-first implementation). Common square matrix types are defines as <code>mat2</code>, <code>mat3</code>, <code>mat4</code></p>
<p >Initialize a matrix: </p><div class="fragment"><div class="line"><span class="comment">// 4x4 identity matrix</span></div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#ae28e3d5a1e0743ea34a6c627c47b421b">mat4</a> A1 = mat4::identity();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Diagonal matrix with 3 on the diagonal</span></div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#ae28e3d5a1e0743ea34a6c627c47b421b">mat4</a> A2 = <a class="code hl_typedef" href="namespacetheoretica.html#ae28e3d5a1e0743ea34a6c627c47b421b">mat4</a>(3.0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Zero matrix</span></div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#ae2899e9929670cbd58f39d6f1642ce19">mat3</a> B1 = <a class="code hl_typedef" href="namespacetheoretica.html#ae2899e9929670cbd58f39d6f1642ce19">mat3</a>();</div>
<div class="ttc" id="anamespacetheoretica_html_ae2899e9929670cbd58f39d6f1642ce19"><div class="ttname"><a href="namespacetheoretica.html#ae2899e9929670cbd58f39d6f1642ce19">theoretica::mat3</a></div><div class="ttdeci">mat&lt; 3, 3 &gt; mat3</div><div class="ttdoc">A 3x3 matrix with real entries.</div><div class="ttdef"><b>Definition:</b> mat.h:1204</div></div>
<div class="ttc" id="anamespacetheoretica_html_ae28e3d5a1e0743ea34a6c627c47b421b"><div class="ttname"><a href="namespacetheoretica.html#ae28e3d5a1e0743ea34a6c627c47b421b">theoretica::mat4</a></div><div class="ttdeci">mat&lt; 4, 4 &gt; mat4</div><div class="ttdoc">A 4x4 matrix with real entries.</div><div class="ttdef"><b>Definition:</b> mat.h:1207</div></div>
</div><!-- fragment --><p >Basic matrix operations: </p><div class="fragment"><div class="line"><span class="comment">// Access an element</span></div>
<div class="line">B1.at(1, 1) = 2.0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get or set and element</span></div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> a12 = A2.get(1, 2);</div>
<div class="line">A1.set(a12, 1, 2);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Scalar multiplication</span></div>
<div class="line">A1 = (A2 * 2.0) / 3.0;</div>
</div><!-- fragment --><p >Vector and matrix multiplication: </p><div class="fragment"><div class="line"><span class="comment">// Matrix-Vector multiplication</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// You can use transform()</span></div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#a3a9580d98118f2e1692c1f5d6dbf3ea5">vec3</a> u1;</div>
<div class="line">u1 = B1.transform(v1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Or simply the * operator</span></div>
<div class="line">u1 = B1 * v1;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Same with Matrix-Matrix multiplication</span></div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#ae28e3d5a1e0743ea34a6c627c47b421b">mat4</a> R1;</div>
<div class="line">R1 = A1.transform(A2);</div>
<div class="line">R1 = A1 * A2;</div>
</div><!-- fragment --><p >Matrix transposition: </p><div class="fragment"><div class="line"><span class="comment">// transposed() returns the transposed matrix</span></div>
<div class="line"><span class="comment">// without modifying the original matrix</span></div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#ae2899e9929670cbd58f39d6f1642ce19">mat3</a> R2 = R1.transposed();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Meanwhile transpose() transposes the matrix itself</span></div>
<div class="line">R1.transpose();</div>
</div><!-- fragment --><p >Matrix inversion: </p><div class="fragment"><div class="line"><span class="comment">// Compute the inverse of a matrix</span></div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#ae28e3d5a1e0743ea34a6c627c47b421b">mat4</a> I1 = A1.inverse();</div>
</div><!-- fragment --><p >Matrix determinant: </p><div class="fragment"><div class="line"><span class="comment">// Compute the determinant</span></div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> D = I1.det();</div>
</div><!-- fragment --><p >Transformations: </p><div class="fragment"><div class="line"><span class="comment">// Get the 3x3 rotation matrix around an arbitrary axis</span></div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#ae2899e9929670cbd58f39d6f1642ce19">mat3</a> Rot1 = mat3::rotation_3x3(<a class="code hl_variable" href="namespacetheoretica.html#a27b5dac597409564afdc448fbef23eae">PI2</a>, <a class="code hl_typedef" href="namespacetheoretica.html#a3a9580d98118f2e1692c1f5d6dbf3ea5">vec3</a>({1, 2, 3}));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Rotation around the x axis (same for y and z)</span></div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#ae2899e9929670cbd58f39d6f1642ce19">mat3</a> Rot2 = mat3::rotation_x_3x3(<a class="code hl_variable" href="namespacetheoretica.html#ac7f9025deb90bc4fd64fb9260340e3f2">PI4</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 4x4 rotation matrix around the z axis of 10 degrees</span></div>
<div class="line"><span class="comment">// (radians(real) converts degrees to radians, degrees does the opposite)</span></div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#ae28e3d5a1e0743ea34a6c627c47b421b">mat4</a> Rot3 = mat4::rotation_z_4x4(<a class="code hl_function" href="namespacetheoretica.html#a4ee874cdb0b2a00881f01de91e931854">radians</a>(10));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 4x4 translation matrix</span></div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#ae28e3d5a1e0743ea34a6c627c47b421b">mat4</a> T1 = mat4::translation(1, 2, 3);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// perspective(), ortho(), scaling_3x3(), scaling_4x4(),</span></div>
<div class="line"><span class="comment">// lookAt() functions are also supported</span></div>
<div class="ttc" id="anamespacetheoretica_html_a27b5dac597409564afdc448fbef23eae"><div class="ttname"><a href="namespacetheoretica.html#a27b5dac597409564afdc448fbef23eae">theoretica::PI2</a></div><div class="ttdeci">constexpr real PI2</div><div class="ttdoc">Half of Pi.</div><div class="ttdef"><b>Definition:</b> constants.h:154</div></div>
<div class="ttc" id="anamespacetheoretica_html_a4ee874cdb0b2a00881f01de91e931854"><div class="ttname"><a href="namespacetheoretica.html#a4ee874cdb0b2a00881f01de91e931854">theoretica::radians</a></div><div class="ttdeci">constexpr real radians(real degrees)</div><div class="ttdoc">Convert degrees to radians.</div><div class="ttdef"><b>Definition:</b> real_analysis.h:966</div></div>
<div class="ttc" id="anamespacetheoretica_html_ac7f9025deb90bc4fd64fb9260340e3f2"><div class="ttname"><a href="namespacetheoretica.html#ac7f9025deb90bc4fd64fb9260340e3f2">theoretica::PI4</a></div><div class="ttdeci">constexpr real PI4</div><div class="ttdoc">A quarter of Pi.</div><div class="ttdef"><b>Definition:</b> constants.h:157</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md30"></a>
Using complex numbers</h1>
<p >Declare a complex number using the <code>complex</code> class. </p><div class="fragment"><div class="line"><span class="comment">// You can initialize a complex number</span></div>
<div class="line"><span class="comment">// using a bracketed list</span></div>
<div class="line">complex z1 = {1, 1};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// And you can also access its elements directly</span></div>
<div class="line">z1.a = 1;</div>
<div class="line">z2.b = 1;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Or get its real and imaginary part</span></div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x = z1.Re() + z1.Im();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// A complex rotor</span></div>
<div class="line">complex z2 = complex::rotor(<a class="code hl_variable" href="namespacetheoretica.html#aeb6a742ab030fe585063215a644f60df">TAU</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Complex multiplication</span></div>
<div class="line">complex z3 = z1 * z2;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Complex conjugate</span></div>
<div class="line">complex z4 = z1.conjugate();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Complex analysis functions</span></div>
<div class="line">complex z5 = <a class="code hl_function" href="namespacetheoretica.html#a1ec5b4f8c9f0d58d65415cec30915d16">ln</a>(z3) + <a class="code hl_function" href="namespacetheoretica.html#af0493013e208bb00505abbc4ca37f292">atan</a>(z3);</div>
<div class="ttc" id="anamespacetheoretica_html_a1ec5b4f8c9f0d58d65415cec30915d16"><div class="ttname"><a href="namespacetheoretica.html#a1ec5b4f8c9f0d58d65415cec30915d16">theoretica::ln</a></div><div class="ttdeci">dual2 ln(dual2 x)</div><div class="ttdoc">Compute the natural logarithm of a second order dual number.</div><div class="ttdef"><b>Definition:</b> dual2_functions.h:135</div></div>
<div class="ttc" id="anamespacetheoretica_html_aeb6a742ab030fe585063215a644f60df"><div class="ttname"><a href="namespacetheoretica.html#aeb6a742ab030fe585063215a644f60df">theoretica::TAU</a></div><div class="ttdeci">constexpr real TAU</div><div class="ttdoc">The Tau mathematical constant (Pi times 2)</div><div class="ttdef"><b>Definition:</b> constants.h:163</div></div>
<div class="ttc" id="anamespacetheoretica_html_af0493013e208bb00505abbc4ca37f292"><div class="ttname"><a href="namespacetheoretica.html#af0493013e208bb00505abbc4ca37f292">theoretica::atan</a></div><div class="ttdeci">dual2 atan(dual2 x)</div><div class="ttdoc">Compute the arctangent of a second order dual number.</div><div class="ttdef"><b>Definition:</b> dual2_functions.h:219</div></div>
</div><!-- fragment --><p> Common complex functions such as <code>sqrt</code>, <code>ln</code>, complex trigonometric functions and many more are also supported (<code><a class="el" href="complex__analysis_8h.html" title="Functions of complex variable.">complex_analysis.h</a></code>).</p>
<h1><a class="anchor" id="autotoc_md31"></a>
Using quaternions</h1>
<p >Declare a quaternion using the <code>quat</code> class. </p><div class="fragment"><div class="line"><span class="comment">// Initialize a quaternion as 1 + 2i + 3j + 4k</span></div>
<div class="line">quat q = {1, 2, 3, 4};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Compute the inverse of a quaternion</span></div>
<div class="line">quat p = q.inverse();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Compute the normalized quaternion</span></div>
<div class="line">quat p_n = p.normalized();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Normalize the quaternion itself</span></div>
<div class="line">p.normalize();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Return a quaternion representing a rotation around an arbitrary axis</span></div>
<div class="line">quat r = quat::rotation(<a class="code hl_variable" href="namespacetheoretica.html#ae93349020a59cf77efcca5bb77c0e7f9">PI</a>, v);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Rotate a vector around an arbitrary axis using quaternions</span></div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#a3a9580d98118f2e1692c1f5d6dbf3ea5">vec3</a> v_1 = quat::rotate(w, <a class="code hl_variable" href="namespacetheoretica.html#ae93349020a59cf77efcca5bb77c0e7f9">PI</a> / 2.0, v);</div>
<div class="ttc" id="anamespacetheoretica_html_ae93349020a59cf77efcca5bb77c0e7f9"><div class="ttname"><a href="namespacetheoretica.html#ae93349020a59cf77efcca5bb77c0e7f9">theoretica::PI</a></div><div class="ttdeci">constexpr real PI</div><div class="ttdoc">The Pi mathematical constant.</div><div class="ttdef"><b>Definition:</b> constants.h:151</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md32"></a>
Using polynomials</h1>
<p >Polynomials are stored and manipulated using the <code>polynomial&lt;T = real&gt;</code> class, where <code>T</code> is the type of the coefficients of the polynomial (<code>real</code> by default). </p><div class="fragment"><div class="line"><span class="comment">// Represents the polynomial 1 + 2x + 3x^2</span></div>
<div class="line">polynomial&lt;real&gt; P1 = {1, 2, 3};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// x + 2x^3</span></div>
<div class="line">polynomial&lt;real&gt; P2 = {0, 1, 0, 2};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Access the polynomial&#39;s coefficients</span></div>
<div class="line">P2[1] = 2;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Polynomial operations</span></div>
<div class="line">polynomial&lt;real&gt; Pr = (P1 * P2) + P1;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Evaluate the polynomial for a given value</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// You can use the eval function</span></div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> res;</div>
<div class="line">res = Pr.eval(1.0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Or simply the () operator</span></div>
<div class="line">res = Pr(1.0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Find the (effective) order of a polynomial</span></div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> order = Pr.find_order();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Trim unneeded higher-order null coefficients</span></div>
<div class="line">Pr.trim();</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md33"></a>
Using statistical functions</h1>
<p >The header <code><a class="el" href="statistics_8h.html" title="Statistical functions.">statistics/statistics.h</a></code> defines many statistical functions of common use. The <code>vec_buff</code> type (alias for <code>std::vector&lt;real&gt;</code>) is used to store data. Many aliases are defined to shorten function names (e.g. <code>sample_standard_deviation</code> = <code>smpl_stdev</code>).</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> data = {1.0, 1.1, 1.3, 0.9, 1.0, 0.9, 0.8};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x_m = <a class="code hl_function" href="namespacetheoretica.html#a63412fa6d4323c24f2c571dfc6b14e1d">mean</a>(data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Standard deviation of a sample (same as sample_standard_deviation)</span></div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> sigma = <a class="code hl_function" href="namespacetheoretica.html#a7c956ff97660f395a7b603673eb648e4">smpl_stdev</a>(data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// STDOM of a sample (same as sample_mean_standard_deviation)</span></div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> sigma_m = <a class="code hl_function" href="namespacetheoretica.html#a533d837210e486032eaffee74aabc909">smpl_stdom</a>(data);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> X = {0.9, 2.1, 3.2, 3.9, 5.2};</div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> Y = {0.11, 0.22, 0.29, 0.41, 0.53};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Weights of the errors on Y</span></div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">vec_buff</a> W = {0.01, 0.01, 0.02, 0.01, 0.03};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Covariance of two datasets</span></div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> c = <a class="code hl_function" href="namespacetheoretica.html#a9fd67e52123a8b943d41216102e3248c">sample_covariance</a>(X, Y);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Linearization using least squares</span></div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> intercept = <a class="code hl_function" href="namespacetheoretica.html#a0f6955f75727be37a27e0927224e5876">lst_sqrs_lin_intercept</a>(X, Y);</div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> slope = <a class="code hl_function" href="namespacetheoretica.html#ac8eefa3fdd67863bd14365f6332935ed">lst_sqrs_lin_slope</a>(X, Y);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> intercept2 = <a class="code hl_function" href="namespacetheoretica.html#a7787cd3050ea6b521f585061c8d8e024">lst_sqrs_weight_lin_intercept</a>(X, Y);</div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> slope2 = <a class="code hl_function" href="namespacetheoretica.html#ad340e45331b7332ee2fb72e6978d82a0">lst_sqrs_weight_lin_slope</a>(X, Y);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Correlation coefficient of two datasets</span></div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> r = <a class="code hl_function" href="namespacetheoretica.html#a6d59f457c7baf9e58eb44e990d79c149">sample_correlation_coefficient</a>(X, Y);</div>
<div class="ttc" id="anamespacetheoretica_html_a0f6955f75727be37a27e0927224e5876"><div class="ttname"><a href="namespacetheoretica.html#a0f6955f75727be37a27e0927224e5876">theoretica::lst_sqrs_lin_intercept</a></div><div class="ttdeci">real lst_sqrs_lin_intercept(const vec_buff &amp;X, const vec_buff &amp;Y)</div><div class="ttdoc">Compute the intercept of the minimum squares linearization of X and Y.</div><div class="ttdef"><b>Definition:</b> statistics.h:360</div></div>
<div class="ttc" id="anamespacetheoretica_html_a533d837210e486032eaffee74aabc909"><div class="ttname"><a href="namespacetheoretica.html#a533d837210e486032eaffee74aabc909">theoretica::smpl_stdom</a></div><div class="ttdeci">real smpl_stdom(const vec_buff &amp;data)</div><div class="ttdoc">Compute the standard deviation on the mean of a set of measures Bessel correction is used in the calc...</div><div class="ttdef"><b>Definition:</b> statistics.h:245</div></div>
<div class="ttc" id="anamespacetheoretica_html_a63412fa6d4323c24f2c571dfc6b14e1d"><div class="ttname"><a href="namespacetheoretica.html#a63412fa6d4323c24f2c571dfc6b14e1d">theoretica::mean</a></div><div class="ttdeci">real mean(const vec_buff &amp;data)</div><div class="ttdoc">Compute the arithmetic mean of a set of values Alias for arithmetic_mean.</div><div class="ttdef"><b>Definition:</b> statistics.h:33</div></div>
<div class="ttc" id="anamespacetheoretica_html_a6d59f457c7baf9e58eb44e990d79c149"><div class="ttname"><a href="namespacetheoretica.html#a6d59f457c7baf9e58eb44e990d79c149">theoretica::sample_correlation_coefficient</a></div><div class="ttdeci">real sample_correlation_coefficient(const vec_buff &amp;X, const vec_buff &amp;Y)</div><div class="ttdoc">Pearson's correlation coefficient r for a sample.</div><div class="ttdef"><b>Definition:</b> statistics.h:297</div></div>
<div class="ttc" id="anamespacetheoretica_html_a7787cd3050ea6b521f585061c8d8e024"><div class="ttname"><a href="namespacetheoretica.html#a7787cd3050ea6b521f585061c8d8e024">theoretica::lst_sqrs_weight_lin_intercept</a></div><div class="ttdeci">real lst_sqrs_weight_lin_intercept(const vec_buff &amp;X, const vec_buff &amp;Y, const vec_buff &amp;W)</div><div class="ttdoc">Compute the intercept of the weighted minimum squares linearization of X and Y.</div><div class="ttdef"><b>Definition:</b> statistics.h:486</div></div>
<div class="ttc" id="anamespacetheoretica_html_a7c956ff97660f395a7b603673eb648e4"><div class="ttname"><a href="namespacetheoretica.html#a7c956ff97660f395a7b603673eb648e4">theoretica::smpl_stdev</a></div><div class="ttdeci">real smpl_stdev(const vec_buff &amp;data)</div><div class="ttdoc">Compute the standard deviation of a sample.</div><div class="ttdef"><b>Definition:</b> statistics.h:189</div></div>
<div class="ttc" id="anamespacetheoretica_html_a9a50102b320dcdc6a61e5a15234327a7"><div class="ttname"><a href="namespacetheoretica.html#a9a50102b320dcdc6a61e5a15234327a7">theoretica::vec_buff</a></div><div class="ttdeci">std::vector&lt; real &gt; vec_buff</div><div class="ttdoc">A dynamically allocated variable-size container Defined by default as an alias for std::vector&lt;real&gt;</div><div class="ttdef"><b>Definition:</b> vec_buff.h:18</div></div>
<div class="ttc" id="anamespacetheoretica_html_a9fd67e52123a8b943d41216102e3248c"><div class="ttname"><a href="namespacetheoretica.html#a9fd67e52123a8b943d41216102e3248c">theoretica::sample_covariance</a></div><div class="ttdeci">real sample_covariance(const vec_buff &amp;X, const vec_buff &amp;Y)</div><div class="ttdoc">Compute the covariance between two sets of sample measures This function uses Bessel correction.</div><div class="ttdef"><b>Definition:</b> statistics.h:271</div></div>
<div class="ttc" id="anamespacetheoretica_html_ac8eefa3fdd67863bd14365f6332935ed"><div class="ttname"><a href="namespacetheoretica.html#ac8eefa3fdd67863bd14365f6332935ed">theoretica::lst_sqrs_lin_slope</a></div><div class="ttdeci">real lst_sqrs_lin_slope(const vec_buff &amp;X, const vec_buff &amp;Y)</div><div class="ttdoc">Compute the slope of the minimum squares linearization of X and Y.</div><div class="ttdef"><b>Definition:</b> statistics.h:391</div></div>
<div class="ttc" id="anamespacetheoretica_html_ad340e45331b7332ee2fb72e6978d82a0"><div class="ttname"><a href="namespacetheoretica.html#ad340e45331b7332ee2fb72e6978d82a0">theoretica::lst_sqrs_weight_lin_slope</a></div><div class="ttdeci">real lst_sqrs_weight_lin_slope(const vec_buff &amp;X, const vec_buff &amp;Y, const vec_buff &amp;W)</div><div class="ttdoc">Compute the slope of the weighted minimum squares linearization of X and Y.</div><div class="ttdef"><b>Definition:</b> statistics.h:513</div></div>
</div><!-- fragment --><p >Many probability distribution functions are implemented in <code><a class="el" href="distributions_8h.html" title="Probability distribution functions.">statistics/distributions.h</a></code> and can be used through the <code>distribution</code> namespace. These include Gaussian, Binomial, Log-Normal, Poisson, Bernoulli, Cauchy and Breit Wigner. </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x1 = distribution::gaussian(1, 2.1, 0.7);</div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x2 = distribution::binomial(1, 3, 0.75);</div>
<div class="line"><a class="code hl_typedef" href="namespacetheoretica.html#a049966946220f1f7e5eae57293703066">real</a> x3 = distribution::poisson(2, 3);</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat May 28 2022 19:56:24 for Theoretica by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
